var RChainToolkitBrowserUtils = (function (exports) {
  'use strict';

  var rhoUnforgeableToJs = function (expr) {
      var unforgeable = {};
      Object.keys(expr.ExprUnforg.data).forEach(function (u) {
          if (u === "UnforgPrivate") {
              unforgeable.UnforgPrivate = expr.ExprUnforg.data[u].data;
          }
          else if (u === "UnforgDeploy") {
              unforgeable.UnforgDeploy = expr.ExprUnforg.data[u].data;
          }
          else if (u === "UnforgDeployer") {
              unforgeable.UnforgDeployer = expr.ExprUnforg.data[u].data;
          }
      });
      return unforgeable;
  };
  var rholangMapToJsObject = function (expr) {
      var obj = {};
      Object.keys(expr.ExprMap.data).forEach(function (k) {
          obj[k] = rhoValToJs(expr.ExprMap.data[k]);
      });
      return obj;
  };
  var rhoExprStringToJs = function (expr) {
      return expr.ExprString.data;
  };
  var rhoExprUriToJs = function (expr) {
      return expr.ExprUri.data;
  };
  var rhoExprBoolToJs = function (expr) {
      return expr.ExprBool.data;
  };
  var rhoExprIntToJs = function (expr) {
      return expr.ExprInt.data;
  };
  var rhoExprListToJs = function (expr) {
      return expr.ExprList.data.map(function (e) { return rhoValToJs(e); });
  };
  var rhoExprTupleToJs = function (expr) {
      return expr.ExprTuple.data.map(function (e) { return rhoValToJs(e); });
  };
  var rhoExprSetToJs = function (expr) {
      return expr.ExprSet.data.map(function (e) { return rhoValToJs(e); });
  };
  var rhoValToJs = function (expr) {
      /* if (val.ids && val.ids[0]) {
            return rhoIdsToJs(val.ids);
          } else  */
      if (expr.ExprUnforg) {
          return rhoUnforgeableToJs(expr);
      }
      else if (expr.ExprMap) {
          return rholangMapToJsObject(expr);
      }
      else if (expr.ExprString) {
          return rhoExprStringToJs(expr);
      }
      else if (expr.ExprUri) {
          return rhoExprUriToJs(expr);
      }
      else if (expr.ExprBool) {
          return rhoExprBoolToJs(expr);
      }
      else if (expr.ExprInt) {
          return rhoExprIntToJs(expr);
      }
      else if (expr.ExprList) {
          return rhoExprListToJs(expr);
      }
      else if (expr.ExprTuple) {
          return rhoExprTupleToJs(expr);
      }
      else if (expr.ExprSet) {
          return rhoExprSetToJs(expr);
      }
      else {
          console.warn("Not implemented", expr);
          return null;
      }
  };

  /*
    converts expr received by decoding buffers
    and decoding Par to javascript variables
  */
  var rhoExprToVar = function (a) {
      if (a.g_string) {
          return a.g_string;
      }
      else if (a.g_uri) {
          return a.g_uri;
      }
      else if (a.g_int) {
          return parseInt(a.g_int, 10);
      }
      else if (a.g_bool) {
          return a.g_bool;
      }
      else if (a.e_list_body) {
          if (a.e_list_body && a.e_list_body.ps) {
              return a.e_list_body.ps.map(function (ps) {
                  if (ps.exprs && ps.exprs[0]) {
                      return rhoExprToVar(ps.exprs[0]);
                  }
                  else {
                      return null;
                  }
              });
          }
          else {
              return [];
          }
      }
      else if (a.e_tuple_body) {
          if (a.e_tuple_body && a.e_tuple_body.ps) {
              return a.e_tuple_body.ps.map(function (ps) {
                  if (ps.exprs && ps.exprs[0]) {
                      return rhoExprToVar(ps.exprs[0]);
                  }
                  else {
                      return null;
                  }
              });
          }
          else {
              return [];
          }
      }
      else if (a.e_set_body) {
          if (a.e_set_body && a.e_set_body.ps) {
              return a.e_set_body.ps.map(function (ps) {
                  if (ps.exprs && ps.exprs[0]) {
                      return rhoExprToVar(ps.exprs[0]);
                  }
                  else {
                      return null;
                  }
              });
          }
          else {
              return [];
          }
      }
      else if (a.e_map_body) {
          var obj_1 = {};
          if (a.e_map_body.kvs) {
              a.e_map_body.kvs.forEach(function (kv) {
                  if (kv.key && kv.key.exprs && kv.key.exprs[0]) {
                      if (kv.value && kv.value.exprs && kv.value.exprs[0]) {
                          obj_1[rhoExprToVar(kv.key.exprs[0])] = rhoExprToVar(kv.value.exprs[0]);
                      }
                      else {
                          obj_1[rhoExprToVar(kv.key.exprs[0])] = null;
                      }
                  }
              });
              return obj_1;
          }
          else {
              return {};
          }
      }
      else {
          console.warn("Not implemented", a);
          return null;
      }
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var aspromise = asPromise;

  /**
   * Callback as used by {@link util.asPromise}.
   * @typedef asPromiseCallback
   * @type {function}
   * @param {Error|null} error Error, if any
   * @param {...*} params Additional arguments
   * @returns {undefined}
   */

  /**
   * Returns a promise from a node-style callback function.
   * @memberof util
   * @param {asPromiseCallback} fn Function to call
   * @param {*} ctx Function context
   * @param {...*} params Function arguments
   * @returns {Promise<*>} Promisified function
   */
  function asPromise(fn, ctx/*, varargs */) {
      var params  = new Array(arguments.length - 1),
          offset  = 0,
          index   = 2,
          pending = true;
      while (index < arguments.length)
          params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err/*, varargs */) {
              if (pending) {
                  pending = false;
                  if (err)
                      reject(err);
                  else {
                      var params = new Array(arguments.length - 1),
                          offset = 0;
                      while (offset < params.length)
                          params[offset++] = arguments[offset];
                      resolve.apply(null, params);
                  }
              }
          };
          try {
              fn.apply(ctx || null, params);
          } catch (err) {
              if (pending) {
                  pending = false;
                  reject(err);
              }
          }
      });
  }

  var base64_1 = createCommonjsModule(function (module, exports) {

  /**
   * A minimal base64 implementation for number arrays.
   * @memberof util
   * @namespace
   */
  var base64 = exports;

  /**
   * Calculates the byte length of a base64 encoded string.
   * @param {string} string Base64 encoded string
   * @returns {number} Byte length
   */
  base64.length = function length(string) {
      var p = string.length;
      if (!p)
          return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
          ++n;
      return Math.ceil(string.length * 3) / 4 - n;
  };

  // Base64 encoding table
  var b64 = new Array(64);

  // Base64 decoding table
  var s64 = new Array(123);

  // 65..90, 97..122, 48..57, 43, 47
  for (var i = 0; i < 64;)
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

  /**
   * Encodes a buffer to a base64 encoded string.
   * @param {Uint8Array} buffer Source buffer
   * @param {number} start Source start
   * @param {number} end Source end
   * @returns {string} Base64 encoded string
   */
  base64.encode = function encode(buffer, start, end) {
      var parts = null,
          chunk = [];
      var i = 0, // output index
          j = 0, // goto index
          t;     // temporary
      while (start < end) {
          var b = buffer[start++];
          switch (j) {
              case 0:
                  chunk[i++] = b64[b >> 2];
                  t = (b & 3) << 4;
                  j = 1;
                  break;
              case 1:
                  chunk[i++] = b64[t | b >> 4];
                  t = (b & 15) << 2;
                  j = 2;
                  break;
              case 2:
                  chunk[i++] = b64[t | b >> 6];
                  chunk[i++] = b64[b & 63];
                  j = 0;
                  break;
          }
          if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
          }
      }
      if (j) {
          chunk[i++] = b64[t];
          chunk[i++] = 61;
          if (j === 1)
              chunk[i++] = 61;
      }
      if (parts) {
          if (i)
              parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
  };

  var invalidEncoding = "invalid encoding";

  /**
   * Decodes a base64 encoded string to a buffer.
   * @param {string} string Source string
   * @param {Uint8Array} buffer Destination buffer
   * @param {number} offset Destination offset
   * @returns {number} Number of bytes written
   * @throws {Error} If encoding is invalid
   */
  base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, // goto index
          t;     // temporary
      for (var i = 0; i < string.length;) {
          var c = string.charCodeAt(i++);
          if (c === 61 && j > 1)
              break;
          if ((c = s64[c]) === undefined)
              throw Error(invalidEncoding);
          switch (j) {
              case 0:
                  t = c;
                  j = 1;
                  break;
              case 1:
                  buffer[offset++] = t << 2 | (c & 48) >> 4;
                  t = c;
                  j = 2;
                  break;
              case 2:
                  buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                  t = c;
                  j = 3;
                  break;
              case 3:
                  buffer[offset++] = (t & 3) << 6 | c;
                  j = 0;
                  break;
          }
      }
      if (j === 1)
          throw Error(invalidEncoding);
      return offset - start;
  };

  /**
   * Tests if the specified string appears to be base64 encoded.
   * @param {string} string String to test
   * @returns {boolean} `true` if probably base64 encoded, otherwise false
   */
  base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
  });

  var eventemitter = EventEmitter;

  /**
   * Constructs a new event emitter instance.
   * @classdesc A minimal event emitter.
   * @memberof util
   * @constructor
   */
  function EventEmitter() {

      /**
       * Registered listeners.
       * @type {Object.<string,*>}
       * @private
       */
      this._listeners = {};
  }

  /**
   * Registers an event listener.
   * @param {string} evt Event name
   * @param {function} fn Listener
   * @param {*} [ctx] Listener context
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn  : fn,
          ctx : ctx || this
      });
      return this;
  };

  /**
   * Removes an event listener or any matching listeners if arguments are omitted.
   * @param {string} [evt] Event name. Removes all listeners if omitted.
   * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === undefined)
          this._listeners = {};
      else {
          if (fn === undefined)
              this._listeners[evt] = [];
          else {
              var listeners = this._listeners[evt];
              for (var i = 0; i < listeners.length;)
                  if (listeners[i].fn === fn)
                      listeners.splice(i, 1);
                  else
                      ++i;
          }
      }
      return this;
  };

  /**
   * Emits an event by calling its listeners with the specified arguments.
   * @param {string} evt Event name
   * @param {...*} args Arguments
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
          var args = [],
              i = 1;
          for (; i < arguments.length;)
              args.push(arguments[i++]);
          for (i = 0; i < listeners.length;)
              listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
  };

  var float_1 = factory(factory);

  /**
   * Reads / writes floats / doubles from / to buffers.
   * @name util.float
   * @namespace
   */

  /**
   * Writes a 32 bit float to a buffer using little endian byte order.
   * @name util.float.writeFloatLE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Writes a 32 bit float to a buffer using big endian byte order.
   * @name util.float.writeFloatBE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Reads a 32 bit float from a buffer using little endian byte order.
   * @name util.float.readFloatLE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Reads a 32 bit float from a buffer using big endian byte order.
   * @name util.float.readFloatBE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Writes a 64 bit double to a buffer using little endian byte order.
   * @name util.float.writeDoubleLE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Writes a 64 bit double to a buffer using big endian byte order.
   * @name util.float.writeDoubleBE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Reads a 64 bit double from a buffer using little endian byte order.
   * @name util.float.readDoubleLE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Reads a 64 bit double from a buffer using big endian byte order.
   * @name util.float.readDoubleBE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  // Factory function for the purpose of node-based testing in modified global environments
  function factory(exports) {

      // float: typed array
      if (typeof Float32Array !== "undefined") (function() {

          var f32 = new Float32Array([ -0 ]),
              f8b = new Uint8Array(f32.buffer),
              le  = f8b[3] === 128;

          function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos    ] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
          }

          function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos    ] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
          }

          /* istanbul ignore next */
          exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          /* istanbul ignore next */
          exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

          function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos    ];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
          }

          function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos    ];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
          }

          /* istanbul ignore next */
          exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          /* istanbul ignore next */
          exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

      // float: ieee754
      })(); else (function() {

          function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                  val = -val;
              if (val === 0)
                  writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
              else if (isNaN(val))
                  writeUint(2143289344, buf, pos);
              else if (val > 3.4028234663852886e+38) // +-Infinity
                  writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 1.1754943508222875e-38) // denormal
                  writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
              else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2),
                      mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                  writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
          }

          exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

          function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos),
                  sign = (uint >> 31) * 2 + 1,
                  exponent = uint >>> 23 & 255,
                  mantissa = uint & 8388607;
              return exponent === 255
                  ? mantissa
                  ? NaN
                  : sign * Infinity
                  : exponent === 0 // denormal
                  ? sign * 1.401298464324817e-45 * mantissa
                  : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }

          exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

      })();

      // double: typed array
      if (typeof Float64Array !== "undefined") (function() {

          var f64 = new Float64Array([-0]),
              f8b = new Uint8Array(f64.buffer),
              le  = f8b[7] === 128;

          function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos    ] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
          }

          function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos    ] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
          }

          /* istanbul ignore next */
          exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          /* istanbul ignore next */
          exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

          function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos    ];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
          }

          function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos    ];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
          }

          /* istanbul ignore next */
          exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          /* istanbul ignore next */
          exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

      // double: ieee754
      })(); else (function() {

          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                  val = -val;
              if (val === 0) {
                  writeUint(0, buf, pos + off0);
                  writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
              } else if (isNaN(val)) {
                  writeUint(0, buf, pos + off0);
                  writeUint(2146959360, buf, pos + off1);
              } else if (val > 1.7976931348623157e+308) { // +-Infinity
                  writeUint(0, buf, pos + off0);
                  writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                  var mantissa;
                  if (val < 2.2250738585072014e-308) { // denormal
                      mantissa = val / 5e-324;
                      writeUint(mantissa >>> 0, buf, pos + off0);
                      writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                  } else {
                      var exponent = Math.floor(Math.log(val) / Math.LN2);
                      if (exponent === 1024)
                          exponent = 1023;
                      mantissa = val * Math.pow(2, -exponent);
                      writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                      writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                  }
              }
          }

          exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0),
                  hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1,
                  exponent = hi >>> 20 & 2047,
                  mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047
                  ? mantissa
                  ? NaN
                  : sign * Infinity
                  : exponent === 0 // denormal
                  ? sign * 5e-324 * mantissa
                  : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }

          exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

      })();

      return exports;
  }

  // uint helpers

  function writeUintLE(val, buf, pos) {
      buf[pos    ] =  val        & 255;
      buf[pos + 1] =  val >>> 8  & 255;
      buf[pos + 2] =  val >>> 16 & 255;
      buf[pos + 3] =  val >>> 24;
  }

  function writeUintBE(val, buf, pos) {
      buf[pos    ] =  val >>> 24;
      buf[pos + 1] =  val >>> 16 & 255;
      buf[pos + 2] =  val >>> 8  & 255;
      buf[pos + 3] =  val        & 255;
  }

  function readUintLE(buf, pos) {
      return (buf[pos    ]
            | buf[pos + 1] << 8
            | buf[pos + 2] << 16
            | buf[pos + 3] << 24) >>> 0;
  }

  function readUintBE(buf, pos) {
      return (buf[pos    ] << 24
            | buf[pos + 1] << 16
            | buf[pos + 2] << 8
            | buf[pos + 3]) >>> 0;
  }

  var inquire_1 = inquire;

  /**
   * Requires a module only if available.
   * @memberof util
   * @param {string} moduleName Module to require
   * @returns {?Object} Required module if available and not empty, otherwise `null`
   */
  function inquire(moduleName) {
      try {
          var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
          if (mod && (mod.length || Object.keys(mod).length))
              return mod;
      } catch (e) {} // eslint-disable-line no-empty
      return null;
  }

  var utf8_1 = createCommonjsModule(function (module, exports) {

  /**
   * A minimal UTF8 implementation for number arrays.
   * @memberof util
   * @namespace
   */
  var utf8 = exports;

  /**
   * Calculates the UTF8 byte length of a string.
   * @param {string} string String
   * @returns {number} Byte length
   */
  utf8.length = function utf8_length(string) {
      var len = 0,
          c = 0;
      for (var i = 0; i < string.length; ++i) {
          c = string.charCodeAt(i);
          if (c < 128)
              len += 1;
          else if (c < 2048)
              len += 2;
          else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
              ++i;
              len += 4;
          } else
              len += 3;
      }
      return len;
  };

  /**
   * Reads UTF8 bytes as a string.
   * @param {Uint8Array} buffer Source buffer
   * @param {number} start Source start
   * @param {number} end Source end
   * @returns {string} String read
   */
  utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
          return "";
      var parts = null,
          chunk = [],
          i = 0, // char offset
          t;     // temporary
      while (start < end) {
          t = buffer[start++];
          if (t < 128)
              chunk[i++] = t;
          else if (t > 191 && t < 224)
              chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
          else if (t > 239 && t < 365) {
              t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
              chunk[i++] = 0xD800 + (t >> 10);
              chunk[i++] = 0xDC00 + (t & 1023);
          } else
              chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i > 8191) {
              (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
              i = 0;
          }
      }
      if (parts) {
          if (i)
              parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
  };

  /**
   * Writes a string as UTF8 bytes.
   * @param {string} string Source string
   * @param {Uint8Array} buffer Destination buffer
   * @param {number} offset Destination offset
   * @returns {number} Bytes written
   */
  utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset,
          c1, // character 1
          c2; // character 2
      for (var i = 0; i < string.length; ++i) {
          c1 = string.charCodeAt(i);
          if (c1 < 128) {
              buffer[offset++] = c1;
          } else if (c1 < 2048) {
              buffer[offset++] = c1 >> 6       | 192;
              buffer[offset++] = c1       & 63 | 128;
          } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
              ++i;
              buffer[offset++] = c1 >> 18      | 240;
              buffer[offset++] = c1 >> 12 & 63 | 128;
              buffer[offset++] = c1 >> 6  & 63 | 128;
              buffer[offset++] = c1       & 63 | 128;
          } else {
              buffer[offset++] = c1 >> 12      | 224;
              buffer[offset++] = c1 >> 6  & 63 | 128;
              buffer[offset++] = c1       & 63 | 128;
          }
      }
      return offset - start;
  };
  });

  var pool_1 = pool;

  /**
   * An allocator as used by {@link util.pool}.
   * @typedef PoolAllocator
   * @type {function}
   * @param {number} size Buffer size
   * @returns {Uint8Array} Buffer
   */

  /**
   * A slicer as used by {@link util.pool}.
   * @typedef PoolSlicer
   * @type {function}
   * @param {number} start Start offset
   * @param {number} end End offset
   * @returns {Uint8Array} Buffer slice
   * @this {Uint8Array}
   */

  /**
   * A general purpose buffer pool.
   * @memberof util
   * @function
   * @param {PoolAllocator} alloc Allocator
   * @param {PoolSlicer} slice Slicer
   * @param {number} [size=8192] Slab size
   * @returns {PoolAllocator} Pooled allocator
   */
  function pool(alloc, slice, size) {
      var SIZE   = size || 8192;
      var MAX    = SIZE >>> 1;
      var slab   = null;
      var offset = SIZE;
      return function pool_alloc(size) {
          if (size < 1 || size > MAX)
              return alloc(size);
          if (offset + size > SIZE) {
              slab = alloc(SIZE);
              offset = 0;
          }
          var buf = slice.call(slab, offset, offset += size);
          if (offset & 7) // align to 32 bit
              offset = (offset | 7) + 1;
          return buf;
      };
  }

  var longbits = LongBits;



  /**
   * Constructs new long bits.
   * @classdesc Helper class for working with the low and high bits of a 64 bit value.
   * @memberof util
   * @constructor
   * @param {number} lo Low 32 bits, unsigned
   * @param {number} hi High 32 bits, unsigned
   */
  function LongBits(lo, hi) {

      // note that the casts below are theoretically unnecessary as of today, but older statically
      // generated converter code might still call the ctor with signed 32bits. kept for compat.

      /**
       * Low bits.
       * @type {number}
       */
      this.lo = lo >>> 0;

      /**
       * High bits.
       * @type {number}
       */
      this.hi = hi >>> 0;
  }

  /**
   * Zero bits.
   * @memberof util.LongBits
   * @type {util.LongBits}
   */
  var zero = LongBits.zero = new LongBits(0, 0);

  zero.toNumber = function() { return 0; };
  zero.zzEncode = zero.zzDecode = function() { return this; };
  zero.length = function() { return 1; };

  /**
   * Zero hash.
   * @memberof util.LongBits
   * @type {string}
   */
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

  /**
   * Constructs new long bits from the specified number.
   * @param {number} value Value
   * @returns {util.LongBits} Instance
   */
  LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
          return zero;
      var sign = value < 0;
      if (sign)
          value = -value;
      var lo = value >>> 0,
          hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
              lo = 0;
              if (++hi > 4294967295)
                  hi = 0;
          }
      }
      return new LongBits(lo, hi);
  };

  /**
   * Constructs new long bits from a number, long or string.
   * @param {Long|number|string} value Value
   * @returns {util.LongBits} Instance
   */
  LongBits.from = function from(value) {
      if (typeof value === "number")
          return LongBits.fromNumber(value);
      if (minimal.isString(value)) {
          /* istanbul ignore else */
          if (minimal.Long)
              value = minimal.Long.fromString(value);
          else
              return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };

  /**
   * Converts this long bits to a possibly unsafe JavaScript number.
   * @param {boolean} [unsigned=false] Whether unsigned or not
   * @returns {number} Possibly unsafe number
   */
  LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0,
              hi = ~this.hi     >>> 0;
          if (!lo)
              hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
  };

  /**
   * Converts this long bits to a long.
   * @param {boolean} [unsigned=false] Whether unsigned or not
   * @returns {Long} Long
   */
  LongBits.prototype.toLong = function toLong(unsigned) {
      return minimal.Long
          ? new minimal.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
          /* istanbul ignore next */
          : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };

  var charCodeAt = String.prototype.charCodeAt;

  /**
   * Constructs new long bits from the specified 8 characters long hash.
   * @param {string} hash Hash
   * @returns {util.LongBits} Bits
   */
  LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
          return zero;
      return new LongBits(
          ( charCodeAt.call(hash, 0)
          | charCodeAt.call(hash, 1) << 8
          | charCodeAt.call(hash, 2) << 16
          | charCodeAt.call(hash, 3) << 24) >>> 0
      ,
          ( charCodeAt.call(hash, 4)
          | charCodeAt.call(hash, 5) << 8
          | charCodeAt.call(hash, 6) << 16
          | charCodeAt.call(hash, 7) << 24) >>> 0
      );
  };

  /**
   * Converts this long bits to a 8 characters long hash.
   * @returns {string} Hash
   */
  LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
          this.lo        & 255,
          this.lo >>> 8  & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24      ,
          this.hi        & 255,
          this.hi >>> 8  & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
      );
  };

  /**
   * Zig-zag encodes this long bits.
   * @returns {util.LongBits} `this`
   */
  LongBits.prototype.zzEncode = function zzEncode() {
      var mask =   this.hi >> 31;
      this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
      return this;
  };

  /**
   * Zig-zag decodes this long bits.
   * @returns {util.LongBits} `this`
   */
  LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
      return this;
  };

  /**
   * Calculates the length of this longbits when encoded as a varint.
   * @returns {number} Length
   */
  LongBits.prototype.length = function length() {
      var part0 =  this.lo,
          part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
          part2 =  this.hi >>> 24;
      return part2 === 0
           ? part1 === 0
             ? part0 < 16384
               ? part0 < 128 ? 1 : 2
               : part0 < 2097152 ? 3 : 4
             : part1 < 16384
               ? part1 < 128 ? 5 : 6
               : part1 < 2097152 ? 7 : 8
           : part2 < 128 ? 9 : 10;
  };

  var minimal = createCommonjsModule(function (module, exports) {
  var util = exports;

  // used to return a Promise where callback is omitted
  util.asPromise = aspromise;

  // converts to / from base64 encoded strings
  util.base64 = base64_1;

  // base class of rpc.Service
  util.EventEmitter = eventemitter;

  // float handling accross browsers
  util.float = float_1;

  // requires modules optionally and hides the call from bundlers
  util.inquire = inquire_1;

  // converts to / from utf8 encoded strings
  util.utf8 = utf8_1;

  // provides a node-like buffer pool in the browser
  util.pool = pool_1;

  // utility to work with the low and high bits of a 64 bit value
  util.LongBits = longbits;

  /**
   * Whether running within node or not.
   * @memberof util
   * @type {boolean}
   */
  util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
                     && commonjsGlobal
                     && commonjsGlobal.process
                     && commonjsGlobal.process.versions
                     && commonjsGlobal.process.versions.node);

  /**
   * Global object reference.
   * @memberof util
   * @type {Object}
   */
  util.global = util.isNode && commonjsGlobal
             || typeof window !== "undefined" && window
             || typeof self   !== "undefined" && self
             || commonjsGlobal; // eslint-disable-line no-invalid-this

  /**
   * An immuable empty array.
   * @memberof util
   * @type {Array.<*>}
   * @const
   */
  util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

  /**
   * An immutable empty object.
   * @type {Object}
   * @const
   */
  util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

  /**
   * Tests if the specified value is an integer.
   * @function
   * @param {*} value Value to test
   * @returns {boolean} `true` if the value is an integer
   */
  util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };

  /**
   * Tests if the specified value is a string.
   * @param {*} value Value to test
   * @returns {boolean} `true` if the value is a string
   */
  util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
  };

  /**
   * Tests if the specified value is a non-null object.
   * @param {*} value Value to test
   * @returns {boolean} `true` if the value is a non-null object
   */
  util.isObject = function isObject(value) {
      return value && typeof value === "object";
  };

  /**
   * Checks if a property on a message is considered to be present.
   * This is an alias of {@link util.isSet}.
   * @function
   * @param {Object} obj Plain object or message instance
   * @param {string} prop Property name
   * @returns {boolean} `true` if considered to be present, otherwise `false`
   */
  util.isset =

  /**
   * Checks if a property on a message is considered to be present.
   * @param {Object} obj Plain object or message instance
   * @param {string} prop Property name
   * @returns {boolean} `true` if considered to be present, otherwise `false`
   */
  util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
  };

  /**
   * Any compatible Buffer instance.
   * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
   * @interface Buffer
   * @extends Uint8Array
   */

  /**
   * Node's Buffer class if available.
   * @type {Constructor<Buffer>}
   */
  util.Buffer = (function() {
      try {
          var Buffer = util.inquire("buffer").Buffer;
          // refuse to use non-node buffers if not explicitly assigned (perf reasons):
          return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
      } catch (e) {
          /* istanbul ignore next */
          return null;
      }
  })();

  // Internal alias of or polyfull for Buffer.from.
  util._Buffer_from = null;

  // Internal alias of or polyfill for Buffer.allocUnsafe.
  util._Buffer_allocUnsafe = null;

  /**
   * Creates a new buffer of whatever type supported by the environment.
   * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
   * @returns {Uint8Array|Buffer} Buffer
   */
  util.newBuffer = function newBuffer(sizeOrArray) {
      /* istanbul ignore next */
      return typeof sizeOrArray === "number"
          ? util.Buffer
              ? util._Buffer_allocUnsafe(sizeOrArray)
              : new util.Array(sizeOrArray)
          : util.Buffer
              ? util._Buffer_from(sizeOrArray)
              : typeof Uint8Array === "undefined"
                  ? sizeOrArray
                  : new Uint8Array(sizeOrArray);
  };

  /**
   * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
   * @type {Constructor<Uint8Array>}
   */
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

  /**
   * Any compatible Long instance.
   * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
   * @interface Long
   * @property {number} low Low bits
   * @property {number} high High bits
   * @property {boolean} unsigned Whether unsigned or not
   */

  /**
   * Long.js's Long class if available.
   * @type {Constructor<Long>}
   */
  util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
           || /* istanbul ignore next */ util.global.Long
           || util.inquire("long");

  /**
   * Regular expression used to verify 2 bit (`bool`) map keys.
   * @type {RegExp}
   * @const
   */
  util.key2Re = /^true|false|0|1$/;

  /**
   * Regular expression used to verify 32 bit (`int32` etc.) map keys.
   * @type {RegExp}
   * @const
   */
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

  /**
   * Regular expression used to verify 64 bit (`int64` etc.) map keys.
   * @type {RegExp}
   * @const
   */
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

  /**
   * Converts a number or long to an 8 characters long hash string.
   * @param {Long|number} value Value to convert
   * @returns {string} Hash
   */
  util.longToHash = function longToHash(value) {
      return value
          ? util.LongBits.from(value).toHash()
          : util.LongBits.zeroHash;
  };

  /**
   * Converts an 8 characters long hash string to a long or number.
   * @param {string} hash Hash
   * @param {boolean} [unsigned=false] Whether unsigned or not
   * @returns {Long|number} Original value
   */
  util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
  };

  /**
   * Merges the properties of the source object into the destination object.
   * @memberof util
   * @param {Object.<string,*>} dst Destination object
   * @param {Object.<string,*>} src Source object
   * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
   * @returns {Object.<string,*>} Destination object
   */
  function merge(dst, src, ifNotSet) { // used by converters
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === undefined || !ifNotSet)
              dst[keys[i]] = src[keys[i]];
      return dst;
  }

  util.merge = merge;

  /**
   * Converts the first character of a string to lower case.
   * @param {string} str String to convert
   * @returns {string} Converted string
   */
  util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
  };

  /**
   * Creates a custom error constructor.
   * @memberof util
   * @param {string} name Error name
   * @returns {Constructor<Error>} Custom error constructor
   */
  function newError(name) {

      function CustomError(message, properties) {

          if (!(this instanceof CustomError))
              return new CustomError(message, properties);

          // Error.call(this, message);
          // ^ just returns a new error instance because the ctor can be called as a function

          Object.defineProperty(this, "message", { get: function() { return message; } });

          /* istanbul ignore next */
          if (Error.captureStackTrace) // node
              Error.captureStackTrace(this, CustomError);
          else
              Object.defineProperty(this, "stack", { value: new Error().stack || "" });

          if (properties)
              merge(this, properties);
      }

      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

      Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

      CustomError.prototype.toString = function toString() {
          return this.name + ": " + this.message;
      };

      return CustomError;
  }

  util.newError = newError;

  /**
   * Constructs a new protocol error.
   * @classdesc Error subclass indicating a protocol specifc error.
   * @memberof util
   * @extends Error
   * @template T extends Message<T>
   * @constructor
   * @param {string} message Error message
   * @param {Object.<string,*>} [properties] Additional properties
   * @example
   * try {
   *     MyMessage.decode(someBuffer); // throws if required fields are missing
   * } catch (e) {
   *     if (e instanceof ProtocolError && e.instance)
   *         console.log("decoded so far: " + JSON.stringify(e.instance));
   * }
   */
  util.ProtocolError = newError("ProtocolError");

  /**
   * So far decoded message instance.
   * @name util.ProtocolError#instance
   * @type {Message<T>}
   */

  /**
   * A OneOf getter as returned by {@link util.oneOfGetter}.
   * @typedef OneOfGetter
   * @type {function}
   * @returns {string|undefined} Set field name, if any
   */

  /**
   * Builds a getter for a oneof's present field name.
   * @param {string[]} fieldNames Field names
   * @returns {OneOfGetter} Unbound getter
   */
  util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;

      /**
       * @returns {string|undefined} Set field name, if any
       * @this Object
       * @ignore
       */
      return function() { // eslint-disable-line consistent-return
          for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
              if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                  return keys[i];
      };
  };

  /**
   * A OneOf setter as returned by {@link util.oneOfSetter}.
   * @typedef OneOfSetter
   * @type {function}
   * @param {string|undefined} value Field name
   * @returns {undefined}
   */

  /**
   * Builds a setter for a oneof's present field name.
   * @param {string[]} fieldNames Field names
   * @returns {OneOfSetter} Unbound setter
   */
  util.oneOfSetter = function setOneOf(fieldNames) {

      /**
       * @param {string} name Field name
       * @returns {undefined}
       * @this Object
       * @ignore
       */
      return function(name) {
          for (var i = 0; i < fieldNames.length; ++i)
              if (fieldNames[i] !== name)
                  delete this[fieldNames[i]];
      };
  };

  /**
   * Default conversion options used for {@link Message#toJSON} implementations.
   *
   * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
   *
   * - Longs become strings
   * - Enums become string keys
   * - Bytes become base64 encoded strings
   * - (Sub-)Messages become plain objects
   * - Maps become plain objects with all string keys
   * - Repeated fields become arrays
   * - NaN and Infinity for float and double fields become strings
   *
   * @type {IConversionOptions}
   * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
   */
  util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
  };

  // Sets up buffer utility according to the environment (called in index-minimal)
  util._configure = function() {
      var Buffer = util.Buffer;
      /* istanbul ignore if */
      if (!Buffer) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
      }
      // because node 4.x buffers are incompatible & immutable
      // see: https://github.com/dcodeIO/protobuf.js/pull/665
      util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
          /* istanbul ignore next */
          function Buffer_from(value, encoding) {
              return new Buffer(value, encoding);
          };
      util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
          /* istanbul ignore next */
          function Buffer_allocUnsafe(size) {
              return new Buffer(size);
          };
  };
  });

  var writer = Writer;



  var BufferWriter; // cyclic

  var LongBits$1  = minimal.LongBits,
      base64    = minimal.base64,
      utf8      = minimal.utf8;

  /**
   * Constructs a new writer operation instance.
   * @classdesc Scheduled writer operation.
   * @constructor
   * @param {function(*, Uint8Array, number)} fn Function to call
   * @param {number} len Value byte length
   * @param {*} val Value to write
   * @ignore
   */
  function Op(fn, len, val) {

      /**
       * Function to call.
       * @type {function(Uint8Array, number, *)}
       */
      this.fn = fn;

      /**
       * Value byte length.
       * @type {number}
       */
      this.len = len;

      /**
       * Next operation.
       * @type {Writer.Op|undefined}
       */
      this.next = undefined;

      /**
       * Value to write.
       * @type {*}
       */
      this.val = val; // type varies
  }

  /* istanbul ignore next */
  function noop() {} // eslint-disable-line no-empty-function

  /**
   * Constructs a new writer state instance.
   * @classdesc Copied writer state.
   * @memberof Writer
   * @constructor
   * @param {Writer} writer Writer to copy state from
   * @ignore
   */
  function State(writer) {

      /**
       * Current head.
       * @type {Writer.Op}
       */
      this.head = writer.head;

      /**
       * Current tail.
       * @type {Writer.Op}
       */
      this.tail = writer.tail;

      /**
       * Current buffer length.
       * @type {number}
       */
      this.len = writer.len;

      /**
       * Next state.
       * @type {State|null}
       */
      this.next = writer.states;
  }

  /**
   * Constructs a new writer instance.
   * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
   * @constructor
   */
  function Writer() {

      /**
       * Current length.
       * @type {number}
       */
      this.len = 0;

      /**
       * Operations head.
       * @type {Object}
       */
      this.head = new Op(noop, 0, 0);

      /**
       * Operations tail
       * @type {Object}
       */
      this.tail = this.head;

      /**
       * Linked forked states.
       * @type {Object|null}
       */
      this.states = null;

      // When a value is written, the writer calculates its byte length and puts it into a linked
      // list of operations to perform when finish() is called. This both allows us to allocate
      // buffers of the exact required size and reduces the amount of work we have to do compared
      // to first calculating over objects and then encoding over objects. In our case, the encoding
      // part is just a linked list walk calling operations with already prepared values.
  }

  var create = function create() {
      return minimal.Buffer
          ? function create_buffer_setup() {
              return (Writer.create = function create_buffer() {
                  return new BufferWriter();
              })();
          }
          /* istanbul ignore next */
          : function create_array() {
              return new Writer();
          };
  };

  /**
   * Creates a new writer.
   * @function
   * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
   */
  Writer.create = create();

  /**
   * Allocates a buffer of the specified size.
   * @param {number} size Buffer size
   * @returns {Uint8Array} Buffer
   */
  Writer.alloc = function alloc(size) {
      return new minimal.Array(size);
  };

  // Use Uint8Array buffer pool in the browser, just like node does with buffers
  /* istanbul ignore else */
  if (minimal.Array !== Array)
      Writer.alloc = minimal.pool(Writer.alloc, minimal.Array.prototype.subarray);

  /**
   * Pushes a new operation to the queue.
   * @param {function(Uint8Array, number, *)} fn Function to call
   * @param {number} len Value byte length
   * @param {number} val Value to write
   * @returns {Writer} `this`
   * @private
   */
  Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
  };

  function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
  }

  function writeVarint32(val, buf, pos) {
      while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
      }
      buf[pos] = val;
  }

  /**
   * Constructs a new varint writer operation instance.
   * @classdesc Scheduled varint writer operation.
   * @extends Op
   * @constructor
   * @param {number} len Value byte length
   * @param {number} val Value to write
   * @ignore
   */
  function VarintOp(len, val) {
      this.len = len;
      this.next = undefined;
      this.val = val;
  }

  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;

  /**
   * Writes an unsigned 32 bit value as a varint.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.uint32 = function write_uint32(value) {
      // here, the call to this.push has been inlined and a varint specific Op subclass is used.
      // uint32 is by far the most frequently used operation and benefits significantly from this.
      this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0)
                  < 128       ? 1
          : value < 16384     ? 2
          : value < 2097152   ? 3
          : value < 268435456 ? 4
          :                     5,
      value)).len;
      return this;
  };

  /**
   * Writes a signed 32 bit value as a varint.
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.int32 = function write_int32(value) {
      return value < 0
          ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) // 10 bytes per spec
          : this.uint32(value);
  };

  /**
   * Writes a 32 bit value as a varint, zig-zag encoded.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };

  function writeVarint64(val, buf, pos) {
      while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
      }
      while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
  }

  /**
   * Writes an unsigned 64 bit value as a varint.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits$1.from(value);
      return this._push(writeVarint64, bits.length(), bits);
  };

  /**
   * Writes a signed 64 bit value as a varint.
   * @function
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.int64 = Writer.prototype.uint64;

  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits$1.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
  };

  /**
   * Writes a boolish value as a varint.
   * @param {boolean} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
  };

  function writeFixed32(val, buf, pos) {
      buf[pos    ] =  val         & 255;
      buf[pos + 1] =  val >>> 8   & 255;
      buf[pos + 2] =  val >>> 16  & 255;
      buf[pos + 3] =  val >>> 24;
  }

  /**
   * Writes an unsigned 32 bit value as fixed 32 bits.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
  };

  /**
   * Writes a signed 32 bit value as fixed 32 bits.
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;

  /**
   * Writes an unsigned 64 bit value as fixed 64 bits.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits$1.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };

  /**
   * Writes a signed 64 bit value as fixed 64 bits.
   * @function
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;

  /**
   * Writes a float (32 bit).
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.float = function write_float(value) {
      return this._push(minimal.float.writeFloatLE, 4, value);
  };

  /**
   * Writes a double (64 bit float).
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.double = function write_double(value) {
      return this._push(minimal.float.writeDoubleLE, 8, value);
  };

  var writeBytes = minimal.Array.prototype.set
      ? function writeBytes_set(val, buf, pos) {
          buf.set(val, pos); // also works for plain array values
      }
      /* istanbul ignore next */
      : function writeBytes_for(val, buf, pos) {
          for (var i = 0; i < val.length; ++i)
              buf[pos + i] = val[i];
      };

  /**
   * Writes a sequence of bytes.
   * @param {Uint8Array|string} value Buffer or base64 encoded string to write
   * @returns {Writer} `this`
   */
  Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
          return this._push(writeByte, 1, 0);
      if (minimal.isString(value)) {
          var buf = Writer.alloc(len = base64.length(value));
          base64.decode(value, buf, 0);
          value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
  };

  /**
   * Writes a string.
   * @param {string} value Value to write
   * @returns {Writer} `this`
   */
  Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len
          ? this.uint32(len)._push(utf8.write, len, value)
          : this._push(writeByte, 1, 0);
  };

  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   * @returns {Writer} `this`
   */
  Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
  };

  /**
   * Resets this instance to the last state.
   * @returns {Writer} `this`
   */
  Writer.prototype.reset = function reset() {
      if (this.states) {
          this.head   = this.states.head;
          this.tail   = this.states.tail;
          this.len    = this.states.len;
          this.states = this.states.next;
      } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len  = 0;
      }
      return this;
  };

  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   * @returns {Writer} `this`
   */
  Writer.prototype.ldelim = function ldelim() {
      var head = this.head,
          tail = this.tail,
          len  = this.len;
      this.reset().uint32(len);
      if (len) {
          this.tail.next = head.next; // skip noop
          this.tail = tail;
          this.len += len;
      }
      return this;
  };

  /**
   * Finishes the write operation.
   * @returns {Uint8Array} Finished buffer
   */
  Writer.prototype.finish = function finish() {
      var head = this.head.next, // skip noop
          buf  = this.constructor.alloc(this.len),
          pos  = 0;
      while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
      }
      // this.head = this.tail = null;
      return buf;
  };

  Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
  };

  var writer_buffer = BufferWriter$1;

  // extends Writer

  (BufferWriter$1.prototype = Object.create(writer.prototype)).constructor = BufferWriter$1;



  /**
   * Constructs a new buffer writer instance.
   * @classdesc Wire format writer using node buffers.
   * @extends Writer
   * @constructor
   */
  function BufferWriter$1() {
      writer.call(this);
  }

  BufferWriter$1._configure = function () {
      /**
       * Allocates a buffer of the specified size.
       * @function
       * @param {number} size Buffer size
       * @returns {Buffer} Buffer
       */
      BufferWriter$1.alloc = minimal._Buffer_allocUnsafe;

      BufferWriter$1.writeBytesBuffer = minimal.Buffer && minimal.Buffer.prototype instanceof Uint8Array && minimal.Buffer.prototype.set.name === "set"
          ? function writeBytesBuffer_set(val, buf, pos) {
            buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
            // also works for plain array values
          }
          /* istanbul ignore next */
          : function writeBytesBuffer_copy(val, buf, pos) {
            if (val.copy) // Buffer values
              val.copy(buf, pos, 0, val.length);
            else for (var i = 0; i < val.length;) // plain array values
              buf[pos++] = val[i++];
          };
  };


  /**
   * @override
   */
  BufferWriter$1.prototype.bytes = function write_bytes_buffer(value) {
      if (minimal.isString(value))
          value = minimal._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
          this._push(BufferWriter$1.writeBytesBuffer, len, value);
      return this;
  };

  function writeStringBuffer(val, buf, pos) {
      if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
          minimal.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
          buf.utf8Write(val, pos);
      else
          buf.write(val, pos);
  }

  /**
   * @override
   */
  BufferWriter$1.prototype.string = function write_string_buffer(value) {
      var len = minimal.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
          this._push(writeStringBuffer, len, value);
      return this;
  };


  /**
   * Finishes the write operation.
   * @name BufferWriter#finish
   * @function
   * @returns {Buffer} Finished buffer
   */

  BufferWriter$1._configure();

  var reader = Reader;



  var BufferReader; // cyclic

  var LongBits$2  = minimal.LongBits,
      utf8$1      = minimal.utf8;

  /* istanbul ignore next */
  function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }

  /**
   * Constructs a new reader instance using the specified buffer.
   * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
   * @constructor
   * @param {Uint8Array} buffer Buffer to read from
   */
  function Reader(buffer) {

      /**
       * Read buffer.
       * @type {Uint8Array}
       */
      this.buf = buffer;

      /**
       * Read buffer position.
       * @type {number}
       */
      this.pos = 0;

      /**
       * Read buffer length.
       * @type {number}
       */
      this.len = buffer.length;
  }

  var create_array = typeof Uint8Array !== "undefined"
      ? function create_typed_array(buffer) {
          if (buffer instanceof Uint8Array || Array.isArray(buffer))
              return new Reader(buffer);
          throw Error("illegal buffer");
      }
      /* istanbul ignore next */
      : function create_array(buffer) {
          if (Array.isArray(buffer))
              return new Reader(buffer);
          throw Error("illegal buffer");
      };

  var create$1 = function create() {
      return minimal.Buffer
          ? function create_buffer_setup(buffer) {
              return (Reader.create = function create_buffer(buffer) {
                  return minimal.Buffer.isBuffer(buffer)
                      ? new BufferReader(buffer)
                      /* istanbul ignore next */
                      : create_array(buffer);
              })(buffer);
          }
          /* istanbul ignore next */
          : create_array;
  };

  /**
   * Creates a new reader using the specified buffer.
   * @function
   * @param {Uint8Array|Buffer} buffer Buffer to read from
   * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
   * @throws {Error} If `buffer` is not a valid buffer
   */
  Reader.create = create$1();

  Reader.prototype._slice = minimal.Array.prototype.subarray || /* istanbul ignore next */ minimal.Array.prototype.slice;

  /**
   * Reads a varint as an unsigned 32 bit value.
   * @function
   * @returns {number} Value read
   */
  Reader.prototype.uint32 = (function read_uint32_setup() {
      var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
      return function read_uint32() {
          value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

          /* istanbul ignore if */
          if ((this.pos += 5) > this.len) {
              this.pos = this.len;
              throw indexOutOfRange(this, 10);
          }
          return value;
      };
  })();

  /**
   * Reads a varint as a signed 32 bit value.
   * @returns {number} Value read
   */
  Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
  };

  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value.
   * @returns {number} Value read
   */
  Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
  };

  /* eslint-disable no-invalid-this */

  function readLongVarint() {
      // tends to deopt with local vars for octet etc.
      var bits = new LongBits$2(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) { // fast route (lo)
          for (; i < 4; ++i) {
              // 1st..4th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
          // 5th
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
          if (this.buf[this.pos++] < 128)
              return bits;
          i = 0;
      } else {
          for (; i < 3; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
              // 1st..3th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
          // 4th
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
      }
      if (this.len - this.pos > 4) { // fast route (hi)
          for (; i < 5; ++i) {
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
      } else {
          for (; i < 5; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
      }
      /* istanbul ignore next */
      throw Error("invalid varint encoding");
  }

  /* eslint-enable no-invalid-this */

  /**
   * Reads a varint as a signed 64 bit value.
   * @name Reader#int64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a varint as an unsigned 64 bit value.
   * @name Reader#uint64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value.
   * @name Reader#sint64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a varint as a boolean.
   * @returns {boolean} Value read
   */
  Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
  };

  function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
      return (buf[end - 4]
            | buf[end - 3] << 8
            | buf[end - 2] << 16
            | buf[end - 1] << 24) >>> 0;
  }

  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer.
   * @returns {number} Value read
   */
  Reader.prototype.fixed32 = function read_fixed32() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      return readFixed32_end(this.buf, this.pos += 4);
  };

  /**
   * Reads fixed 32 bits as a signed 32 bit integer.
   * @returns {number} Value read
   */
  Reader.prototype.sfixed32 = function read_sfixed32() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      return readFixed32_end(this.buf, this.pos += 4) | 0;
  };

  /* eslint-disable no-invalid-this */

  function readFixed64(/* this: Reader */) {

      /* istanbul ignore if */
      if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);

      return new LongBits$2(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }

  /* eslint-enable no-invalid-this */

  /**
   * Reads fixed 64 bits.
   * @name Reader#fixed64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads zig-zag encoded fixed 64 bits.
   * @name Reader#sfixed64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a float (32 bit) as a number.
   * @function
   * @returns {number} Value read
   */
  Reader.prototype.float = function read_float() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      var value = minimal.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
  };

  /**
   * Reads a double (64 bit float) as a number.
   * @function
   * @returns {number} Value read
   */
  Reader.prototype.double = function read_double() {

      /* istanbul ignore if */
      if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);

      var value = minimal.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
  };

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @returns {Uint8Array} Value read
   */
  Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(),
          start  = this.pos,
          end    = this.pos + length;

      /* istanbul ignore if */
      if (end > this.len)
          throw indexOutOfRange(this, length);

      this.pos += length;
      if (Array.isArray(this.buf)) // plain array
          return this.buf.slice(start, end);
      return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
          ? new this.buf.constructor(0)
          : this._slice.call(this.buf, start, end);
  };

  /**
   * Reads a string preceeded by its byte length as a varint.
   * @returns {string} Value read
   */
  Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8$1.read(bytes, 0, bytes.length);
  };

  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint.
   * @param {number} [length] Length if known, otherwise a varint is assumed
   * @returns {Reader} `this`
   */
  Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
          /* istanbul ignore if */
          if (this.pos + length > this.len)
              throw indexOutOfRange(this, length);
          this.pos += length;
      } else {
          do {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
      }
      return this;
  };

  /**
   * Skips the next element of the specified wire type.
   * @param {number} wireType Wire type received
   * @returns {Reader} `this`
   */
  Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
          case 0:
              this.skip();
              break;
          case 1:
              this.skip(8);
              break;
          case 2:
              this.skip(this.uint32());
              break;
          case 3:
              while ((wireType = this.uint32() & 7) !== 4) {
                  this.skipType(wireType);
              }
              break;
          case 5:
              this.skip(4);
              break;

          /* istanbul ignore next */
          default:
              throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
  };

  Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create$1();
      BufferReader._configure();

      var fn = minimal.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
      minimal.merge(Reader.prototype, {

          int64: function read_int64() {
              return readLongVarint.call(this)[fn](false);
          },

          uint64: function read_uint64() {
              return readLongVarint.call(this)[fn](true);
          },

          sint64: function read_sint64() {
              return readLongVarint.call(this).zzDecode()[fn](false);
          },

          fixed64: function read_fixed64() {
              return readFixed64.call(this)[fn](true);
          },

          sfixed64: function read_sfixed64() {
              return readFixed64.call(this)[fn](false);
          }

      });
  };

  var reader_buffer = BufferReader$1;

  // extends Reader

  (BufferReader$1.prototype = Object.create(reader.prototype)).constructor = BufferReader$1;



  /**
   * Constructs a new buffer reader instance.
   * @classdesc Wire format reader using node buffers.
   * @extends Reader
   * @constructor
   * @param {Buffer} buffer Buffer to read from
   */
  function BufferReader$1(buffer) {
      reader.call(this, buffer);

      /**
       * Read buffer.
       * @name BufferReader#buf
       * @type {Buffer}
       */
  }

  BufferReader$1._configure = function () {
      /* istanbul ignore else */
      if (minimal.Buffer)
          BufferReader$1.prototype._slice = minimal.Buffer.prototype.slice;
  };


  /**
   * @override
   */
  BufferReader$1.prototype.string = function read_string_buffer() {
      var len = this.uint32(); // modifies pos
      return this.buf.utf8Slice
          ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
          : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @name BufferReader#bytes
   * @function
   * @returns {Buffer} Value read
   */

  BufferReader$1._configure();

  var service = Service;



  // Extends EventEmitter
  (Service.prototype = Object.create(minimal.EventEmitter.prototype)).constructor = Service;

  /**
   * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
   *
   * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
   * @typedef rpc.ServiceMethodCallback
   * @template TRes extends Message<TRes>
   * @type {function}
   * @param {Error|null} error Error, if any
   * @param {TRes} [response] Response message
   * @returns {undefined}
   */

  /**
   * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
   * @typedef rpc.ServiceMethod
   * @template TReq extends Message<TReq>
   * @template TRes extends Message<TRes>
   * @type {function}
   * @param {TReq|Properties<TReq>} request Request message or plain object
   * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
   * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
   */

  /**
   * Constructs a new RPC service instance.
   * @classdesc An RPC service as returned by {@link Service#create}.
   * @exports rpc.Service
   * @extends util.EventEmitter
   * @constructor
   * @param {RPCImpl} rpcImpl RPC implementation
   * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
   * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
   */
  function Service(rpcImpl, requestDelimited, responseDelimited) {

      if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");

      minimal.EventEmitter.call(this);

      /**
       * RPC implementation. Becomes `null` once the service is ended.
       * @type {RPCImpl|null}
       */
      this.rpcImpl = rpcImpl;

      /**
       * Whether requests are length-delimited.
       * @type {boolean}
       */
      this.requestDelimited = Boolean(requestDelimited);

      /**
       * Whether responses are length-delimited.
       * @type {boolean}
       */
      this.responseDelimited = Boolean(responseDelimited);
  }

  /**
   * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
   * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
   * @param {Constructor<TReq>} requestCtor Request constructor
   * @param {Constructor<TRes>} responseCtor Response constructor
   * @param {TReq|Properties<TReq>} request Request message or plain object
   * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
   * @returns {undefined}
   * @template TReq extends Message<TReq>
   * @template TRes extends Message<TRes>
   */
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

      if (!request)
          throw TypeError("request must be specified");

      var self = this;
      if (!callback)
          return minimal.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

      if (!self.rpcImpl) {
          setTimeout(function() { callback(Error("already ended")); }, 0);
          return undefined;
      }

      try {
          return self.rpcImpl(
              method,
              requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
              function rpcCallback(err, response) {

                  if (err) {
                      self.emit("error", err, method);
                      return callback(err);
                  }

                  if (response === null) {
                      self.end(/* endedByRPC */ true);
                      return undefined;
                  }

                  if (!(response instanceof responseCtor)) {
                      try {
                          response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                      } catch (err) {
                          self.emit("error", err, method);
                          return callback(err);
                      }
                  }

                  self.emit("data", response, method);
                  return callback(null, response);
              }
          );
      } catch (err) {
          self.emit("error", err, method);
          setTimeout(function() { callback(err); }, 0);
          return undefined;
      }
  };

  /**
   * Ends this service and emits the `end` event.
   * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
   * @returns {rpc.Service} `this`
   */
  Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
          if (!endedByRPC) // signal end to rpcImpl
              this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
      }
      return this;
  };

  var rpc_1 = createCommonjsModule(function (module, exports) {

  /**
   * Streaming RPC helpers.
   * @namespace
   */
  var rpc = exports;

  /**
   * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
   * @typedef RPCImpl
   * @type {function}
   * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
   * @param {Uint8Array} requestData Request data
   * @param {RPCImplCallback} callback Callback function
   * @returns {undefined}
   * @example
   * function rpcImpl(method, requestData, callback) {
   *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
   *         throw Error("no such method");
   *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
   *         callback(err, responseData);
   *     });
   * }
   */

  /**
   * Node-style callback as used by {@link RPCImpl}.
   * @typedef RPCImplCallback
   * @type {function}
   * @param {Error|null} error Error, if any, otherwise `null`
   * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
   * @returns {undefined}
   */

  rpc.Service = service;
  });

  var roots = {};

  var indexMinimal = createCommonjsModule(function (module, exports) {
  var protobuf = exports;

  /**
   * Build type, one of `"full"`, `"light"` or `"minimal"`.
   * @name build
   * @type {string}
   * @const
   */
  protobuf.build = "minimal";

  // Serialization
  protobuf.Writer       = writer;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader       = reader;
  protobuf.BufferReader = reader_buffer;

  // Utility
  protobuf.util         = minimal;
  protobuf.rpc          = rpc_1;
  protobuf.roots        = roots;
  protobuf.configure    = configure;

  /* istanbul ignore next */
  /**
   * Reconfigures the library according to the environment.
   * @returns {undefined}
   */
  function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
  }

  // Set up buffer utility according to the environment
  configure();
  });

  var minimal$1 = indexMinimal;

  // Common aliases
  var $Reader = minimal$1.Reader, $Writer = minimal$1.Writer, $util = minimal$1.util;

  // Exported root namespace
  var $root = minimal$1.roots["default"] || (minimal$1.roots["default"] = {});

  $root.casper = (function() {

      /**
       * Namespace casper.
       * @exports casper
       * @namespace
       */
      var casper = {};

      casper.HasBlockRequestProto = (function() {

          /**
           * Properties of a HasBlockRequestProto.
           * @memberof casper
           * @interface IHasBlockRequestProto
           * @property {Uint8Array|null} [hash] HasBlockRequestProto hash
           */

          /**
           * Constructs a new HasBlockRequestProto.
           * @memberof casper
           * @classdesc Represents a HasBlockRequestProto.
           * @implements IHasBlockRequestProto
           * @constructor
           * @param {casper.IHasBlockRequestProto=} [properties] Properties to set
           */
          function HasBlockRequestProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * HasBlockRequestProto hash.
           * @member {Uint8Array} hash
           * @memberof casper.HasBlockRequestProto
           * @instance
           */
          HasBlockRequestProto.prototype.hash = $util.newBuffer([]);

          /**
           * Creates a new HasBlockRequestProto instance using the specified properties.
           * @function create
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {casper.IHasBlockRequestProto=} [properties] Properties to set
           * @returns {casper.HasBlockRequestProto} HasBlockRequestProto instance
           */
          HasBlockRequestProto.create = function create(properties) {
              return new HasBlockRequestProto(properties);
          };

          /**
           * Encodes the specified HasBlockRequestProto message. Does not implicitly {@link casper.HasBlockRequestProto.verify|verify} messages.
           * @function encode
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {casper.IHasBlockRequestProto} message HasBlockRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HasBlockRequestProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
              return writer;
          };

          /**
           * Encodes the specified HasBlockRequestProto message, length delimited. Does not implicitly {@link casper.HasBlockRequestProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {casper.IHasBlockRequestProto} message HasBlockRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HasBlockRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a HasBlockRequestProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.HasBlockRequestProto} HasBlockRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HasBlockRequestProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.HasBlockRequestProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.hash = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a HasBlockRequestProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.HasBlockRequestProto} HasBlockRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HasBlockRequestProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a HasBlockRequestProto message.
           * @function verify
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          HasBlockRequestProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                      return "hash: buffer expected";
              return null;
          };

          /**
           * Creates a HasBlockRequestProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.HasBlockRequestProto} HasBlockRequestProto
           */
          HasBlockRequestProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.HasBlockRequestProto)
                  return object;
              var message = new $root.casper.HasBlockRequestProto();
              if (object.hash != null)
                  if (typeof object.hash === "string")
                      $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                  else if (object.hash.length)
                      message.hash = object.hash;
              return message;
          };

          /**
           * Creates a plain object from a HasBlockRequestProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.HasBlockRequestProto
           * @static
           * @param {casper.HasBlockRequestProto} message HasBlockRequestProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          HasBlockRequestProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.hash = "";
                  else {
                      object.hash = [];
                      if (options.bytes !== Array)
                          object.hash = $util.newBuffer(object.hash);
                  }
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
              return object;
          };

          /**
           * Converts this HasBlockRequestProto to JSON.
           * @function toJSON
           * @memberof casper.HasBlockRequestProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          HasBlockRequestProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return HasBlockRequestProto;
      })();

      casper.HasBlockProto = (function() {

          /**
           * Properties of a HasBlockProto.
           * @memberof casper
           * @interface IHasBlockProto
           * @property {Uint8Array|null} [hash] HasBlockProto hash
           */

          /**
           * Constructs a new HasBlockProto.
           * @memberof casper
           * @classdesc Represents a HasBlockProto.
           * @implements IHasBlockProto
           * @constructor
           * @param {casper.IHasBlockProto=} [properties] Properties to set
           */
          function HasBlockProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * HasBlockProto hash.
           * @member {Uint8Array} hash
           * @memberof casper.HasBlockProto
           * @instance
           */
          HasBlockProto.prototype.hash = $util.newBuffer([]);

          /**
           * Creates a new HasBlockProto instance using the specified properties.
           * @function create
           * @memberof casper.HasBlockProto
           * @static
           * @param {casper.IHasBlockProto=} [properties] Properties to set
           * @returns {casper.HasBlockProto} HasBlockProto instance
           */
          HasBlockProto.create = function create(properties) {
              return new HasBlockProto(properties);
          };

          /**
           * Encodes the specified HasBlockProto message. Does not implicitly {@link casper.HasBlockProto.verify|verify} messages.
           * @function encode
           * @memberof casper.HasBlockProto
           * @static
           * @param {casper.IHasBlockProto} message HasBlockProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HasBlockProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
              return writer;
          };

          /**
           * Encodes the specified HasBlockProto message, length delimited. Does not implicitly {@link casper.HasBlockProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.HasBlockProto
           * @static
           * @param {casper.IHasBlockProto} message HasBlockProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HasBlockProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a HasBlockProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.HasBlockProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.HasBlockProto} HasBlockProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HasBlockProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.HasBlockProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.hash = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a HasBlockProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.HasBlockProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.HasBlockProto} HasBlockProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HasBlockProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a HasBlockProto message.
           * @function verify
           * @memberof casper.HasBlockProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          HasBlockProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                      return "hash: buffer expected";
              return null;
          };

          /**
           * Creates a HasBlockProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.HasBlockProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.HasBlockProto} HasBlockProto
           */
          HasBlockProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.HasBlockProto)
                  return object;
              var message = new $root.casper.HasBlockProto();
              if (object.hash != null)
                  if (typeof object.hash === "string")
                      $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                  else if (object.hash.length)
                      message.hash = object.hash;
              return message;
          };

          /**
           * Creates a plain object from a HasBlockProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.HasBlockProto
           * @static
           * @param {casper.HasBlockProto} message HasBlockProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          HasBlockProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.hash = "";
                  else {
                      object.hash = [];
                      if (options.bytes !== Array)
                          object.hash = $util.newBuffer(object.hash);
                  }
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
              return object;
          };

          /**
           * Converts this HasBlockProto to JSON.
           * @function toJSON
           * @memberof casper.HasBlockProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          HasBlockProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return HasBlockProto;
      })();

      casper.BlockRequestProto = (function() {

          /**
           * Properties of a BlockRequestProto.
           * @memberof casper
           * @interface IBlockRequestProto
           * @property {Uint8Array|null} [hash] BlockRequestProto hash
           */

          /**
           * Constructs a new BlockRequestProto.
           * @memberof casper
           * @classdesc Represents a BlockRequestProto.
           * @implements IBlockRequestProto
           * @constructor
           * @param {casper.IBlockRequestProto=} [properties] Properties to set
           */
          function BlockRequestProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockRequestProto hash.
           * @member {Uint8Array} hash
           * @memberof casper.BlockRequestProto
           * @instance
           */
          BlockRequestProto.prototype.hash = $util.newBuffer([]);

          /**
           * Creates a new BlockRequestProto instance using the specified properties.
           * @function create
           * @memberof casper.BlockRequestProto
           * @static
           * @param {casper.IBlockRequestProto=} [properties] Properties to set
           * @returns {casper.BlockRequestProto} BlockRequestProto instance
           */
          BlockRequestProto.create = function create(properties) {
              return new BlockRequestProto(properties);
          };

          /**
           * Encodes the specified BlockRequestProto message. Does not implicitly {@link casper.BlockRequestProto.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockRequestProto
           * @static
           * @param {casper.IBlockRequestProto} message BlockRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockRequestProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
              return writer;
          };

          /**
           * Encodes the specified BlockRequestProto message, length delimited. Does not implicitly {@link casper.BlockRequestProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockRequestProto
           * @static
           * @param {casper.IBlockRequestProto} message BlockRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockRequestProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockRequestProto} BlockRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockRequestProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockRequestProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.hash = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockRequestProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockRequestProto} BlockRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockRequestProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockRequestProto message.
           * @function verify
           * @memberof casper.BlockRequestProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockRequestProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                      return "hash: buffer expected";
              return null;
          };

          /**
           * Creates a BlockRequestProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockRequestProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockRequestProto} BlockRequestProto
           */
          BlockRequestProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockRequestProto)
                  return object;
              var message = new $root.casper.BlockRequestProto();
              if (object.hash != null)
                  if (typeof object.hash === "string")
                      $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                  else if (object.hash.length)
                      message.hash = object.hash;
              return message;
          };

          /**
           * Creates a plain object from a BlockRequestProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockRequestProto
           * @static
           * @param {casper.BlockRequestProto} message BlockRequestProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockRequestProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.hash = "";
                  else {
                      object.hash = [];
                      if (options.bytes !== Array)
                          object.hash = $util.newBuffer(object.hash);
                  }
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
              return object;
          };

          /**
           * Converts this BlockRequestProto to JSON.
           * @function toJSON
           * @memberof casper.BlockRequestProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockRequestProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockRequestProto;
      })();

      casper.ForkChoiceTipRequestProto = (function() {

          /**
           * Properties of a ForkChoiceTipRequestProto.
           * @memberof casper
           * @interface IForkChoiceTipRequestProto
           */

          /**
           * Constructs a new ForkChoiceTipRequestProto.
           * @memberof casper
           * @classdesc Represents a ForkChoiceTipRequestProto.
           * @implements IForkChoiceTipRequestProto
           * @constructor
           * @param {casper.IForkChoiceTipRequestProto=} [properties] Properties to set
           */
          function ForkChoiceTipRequestProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new ForkChoiceTipRequestProto instance using the specified properties.
           * @function create
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {casper.IForkChoiceTipRequestProto=} [properties] Properties to set
           * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto instance
           */
          ForkChoiceTipRequestProto.create = function create(properties) {
              return new ForkChoiceTipRequestProto(properties);
          };

          /**
           * Encodes the specified ForkChoiceTipRequestProto message. Does not implicitly {@link casper.ForkChoiceTipRequestProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {casper.IForkChoiceTipRequestProto} message ForkChoiceTipRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ForkChoiceTipRequestProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified ForkChoiceTipRequestProto message, length delimited. Does not implicitly {@link casper.ForkChoiceTipRequestProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {casper.IForkChoiceTipRequestProto} message ForkChoiceTipRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ForkChoiceTipRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ForkChoiceTipRequestProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ForkChoiceTipRequestProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ForkChoiceTipRequestProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ForkChoiceTipRequestProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ForkChoiceTipRequestProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ForkChoiceTipRequestProto message.
           * @function verify
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ForkChoiceTipRequestProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a ForkChoiceTipRequestProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ForkChoiceTipRequestProto} ForkChoiceTipRequestProto
           */
          ForkChoiceTipRequestProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ForkChoiceTipRequestProto)
                  return object;
              return new $root.casper.ForkChoiceTipRequestProto();
          };

          /**
           * Creates a plain object from a ForkChoiceTipRequestProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ForkChoiceTipRequestProto
           * @static
           * @param {casper.ForkChoiceTipRequestProto} message ForkChoiceTipRequestProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ForkChoiceTipRequestProto.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this ForkChoiceTipRequestProto to JSON.
           * @function toJSON
           * @memberof casper.ForkChoiceTipRequestProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ForkChoiceTipRequestProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ForkChoiceTipRequestProto;
      })();

      casper.ApprovedBlockCandidateProto = (function() {

          /**
           * Properties of an ApprovedBlockCandidateProto.
           * @memberof casper
           * @interface IApprovedBlockCandidateProto
           * @property {casper.IBlockMessageProto|null} [block] ApprovedBlockCandidateProto block
           * @property {number|null} [requiredSigs] ApprovedBlockCandidateProto requiredSigs
           */

          /**
           * Constructs a new ApprovedBlockCandidateProto.
           * @memberof casper
           * @classdesc Represents an ApprovedBlockCandidateProto.
           * @implements IApprovedBlockCandidateProto
           * @constructor
           * @param {casper.IApprovedBlockCandidateProto=} [properties] Properties to set
           */
          function ApprovedBlockCandidateProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ApprovedBlockCandidateProto block.
           * @member {casper.IBlockMessageProto|null|undefined} block
           * @memberof casper.ApprovedBlockCandidateProto
           * @instance
           */
          ApprovedBlockCandidateProto.prototype.block = null;

          /**
           * ApprovedBlockCandidateProto requiredSigs.
           * @member {number} requiredSigs
           * @memberof casper.ApprovedBlockCandidateProto
           * @instance
           */
          ApprovedBlockCandidateProto.prototype.requiredSigs = 0;

          /**
           * Creates a new ApprovedBlockCandidateProto instance using the specified properties.
           * @function create
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {casper.IApprovedBlockCandidateProto=} [properties] Properties to set
           * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto instance
           */
          ApprovedBlockCandidateProto.create = function create(properties) {
              return new ApprovedBlockCandidateProto(properties);
          };

          /**
           * Encodes the specified ApprovedBlockCandidateProto message. Does not implicitly {@link casper.ApprovedBlockCandidateProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {casper.IApprovedBlockCandidateProto} message ApprovedBlockCandidateProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ApprovedBlockCandidateProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.block != null && message.hasOwnProperty("block"))
                  $root.casper.BlockMessageProto.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.requiredSigs != null && message.hasOwnProperty("requiredSigs"))
                  writer.uint32(/* id 2, wireType 0 =*/16).int32(message.requiredSigs);
              return writer;
          };

          /**
           * Encodes the specified ApprovedBlockCandidateProto message, length delimited. Does not implicitly {@link casper.ApprovedBlockCandidateProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {casper.IApprovedBlockCandidateProto} message ApprovedBlockCandidateProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ApprovedBlockCandidateProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an ApprovedBlockCandidateProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ApprovedBlockCandidateProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ApprovedBlockCandidateProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.block = $root.casper.BlockMessageProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.requiredSigs = reader.int32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an ApprovedBlockCandidateProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ApprovedBlockCandidateProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an ApprovedBlockCandidateProto message.
           * @function verify
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ApprovedBlockCandidateProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.block != null && message.hasOwnProperty("block")) {
                  var error = $root.casper.BlockMessageProto.verify(message.block);
                  if (error)
                      return "block." + error;
              }
              if (message.requiredSigs != null && message.hasOwnProperty("requiredSigs"))
                  if (!$util.isInteger(message.requiredSigs))
                      return "requiredSigs: integer expected";
              return null;
          };

          /**
           * Creates an ApprovedBlockCandidateProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ApprovedBlockCandidateProto} ApprovedBlockCandidateProto
           */
          ApprovedBlockCandidateProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ApprovedBlockCandidateProto)
                  return object;
              var message = new $root.casper.ApprovedBlockCandidateProto();
              if (object.block != null) {
                  if (typeof object.block !== "object")
                      throw TypeError(".casper.ApprovedBlockCandidateProto.block: object expected");
                  message.block = $root.casper.BlockMessageProto.fromObject(object.block);
              }
              if (object.requiredSigs != null)
                  message.requiredSigs = object.requiredSigs | 0;
              return message;
          };

          /**
           * Creates a plain object from an ApprovedBlockCandidateProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ApprovedBlockCandidateProto
           * @static
           * @param {casper.ApprovedBlockCandidateProto} message ApprovedBlockCandidateProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ApprovedBlockCandidateProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.block = null;
                  object.requiredSigs = 0;
              }
              if (message.block != null && message.hasOwnProperty("block"))
                  object.block = $root.casper.BlockMessageProto.toObject(message.block, options);
              if (message.requiredSigs != null && message.hasOwnProperty("requiredSigs"))
                  object.requiredSigs = message.requiredSigs;
              return object;
          };

          /**
           * Converts this ApprovedBlockCandidateProto to JSON.
           * @function toJSON
           * @memberof casper.ApprovedBlockCandidateProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ApprovedBlockCandidateProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ApprovedBlockCandidateProto;
      })();

      casper.UnapprovedBlockProto = (function() {

          /**
           * Properties of an UnapprovedBlockProto.
           * @memberof casper
           * @interface IUnapprovedBlockProto
           * @property {casper.IApprovedBlockCandidateProto|null} [candidate] UnapprovedBlockProto candidate
           * @property {number|Long|null} [timestamp] UnapprovedBlockProto timestamp
           * @property {number|Long|null} [duration] UnapprovedBlockProto duration
           */

          /**
           * Constructs a new UnapprovedBlockProto.
           * @memberof casper
           * @classdesc Represents an UnapprovedBlockProto.
           * @implements IUnapprovedBlockProto
           * @constructor
           * @param {casper.IUnapprovedBlockProto=} [properties] Properties to set
           */
          function UnapprovedBlockProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * UnapprovedBlockProto candidate.
           * @member {casper.IApprovedBlockCandidateProto|null|undefined} candidate
           * @memberof casper.UnapprovedBlockProto
           * @instance
           */
          UnapprovedBlockProto.prototype.candidate = null;

          /**
           * UnapprovedBlockProto timestamp.
           * @member {number|Long} timestamp
           * @memberof casper.UnapprovedBlockProto
           * @instance
           */
          UnapprovedBlockProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * UnapprovedBlockProto duration.
           * @member {number|Long} duration
           * @memberof casper.UnapprovedBlockProto
           * @instance
           */
          UnapprovedBlockProto.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Creates a new UnapprovedBlockProto instance using the specified properties.
           * @function create
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {casper.IUnapprovedBlockProto=} [properties] Properties to set
           * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto instance
           */
          UnapprovedBlockProto.create = function create(properties) {
              return new UnapprovedBlockProto(properties);
          };

          /**
           * Encodes the specified UnapprovedBlockProto message. Does not implicitly {@link casper.UnapprovedBlockProto.verify|verify} messages.
           * @function encode
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {casper.IUnapprovedBlockProto} message UnapprovedBlockProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          UnapprovedBlockProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.candidate != null && message.hasOwnProperty("candidate"))
                  $root.casper.ApprovedBlockCandidateProto.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
              if (message.duration != null && message.hasOwnProperty("duration"))
                  writer.uint32(/* id 3, wireType 0 =*/24).int64(message.duration);
              return writer;
          };

          /**
           * Encodes the specified UnapprovedBlockProto message, length delimited. Does not implicitly {@link casper.UnapprovedBlockProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {casper.IUnapprovedBlockProto} message UnapprovedBlockProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          UnapprovedBlockProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an UnapprovedBlockProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          UnapprovedBlockProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.UnapprovedBlockProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.candidate = $root.casper.ApprovedBlockCandidateProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.timestamp = reader.int64();
                      break;
                  case 3:
                      message.duration = reader.int64();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an UnapprovedBlockProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          UnapprovedBlockProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an UnapprovedBlockProto message.
           * @function verify
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          UnapprovedBlockProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.candidate != null && message.hasOwnProperty("candidate")) {
                  var error = $root.casper.ApprovedBlockCandidateProto.verify(message.candidate);
                  if (error)
                      return "candidate." + error;
              }
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                      return "timestamp: integer|Long expected";
              if (message.duration != null && message.hasOwnProperty("duration"))
                  if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
                      return "duration: integer|Long expected";
              return null;
          };

          /**
           * Creates an UnapprovedBlockProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.UnapprovedBlockProto} UnapprovedBlockProto
           */
          UnapprovedBlockProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.UnapprovedBlockProto)
                  return object;
              var message = new $root.casper.UnapprovedBlockProto();
              if (object.candidate != null) {
                  if (typeof object.candidate !== "object")
                      throw TypeError(".casper.UnapprovedBlockProto.candidate: object expected");
                  message.candidate = $root.casper.ApprovedBlockCandidateProto.fromObject(object.candidate);
              }
              if (object.timestamp != null)
                  if ($util.Long)
                      (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                  else if (typeof object.timestamp === "string")
                      message.timestamp = parseInt(object.timestamp, 10);
                  else if (typeof object.timestamp === "number")
                      message.timestamp = object.timestamp;
                  else if (typeof object.timestamp === "object")
                      message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
              if (object.duration != null)
                  if ($util.Long)
                      (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
                  else if (typeof object.duration === "string")
                      message.duration = parseInt(object.duration, 10);
                  else if (typeof object.duration === "number")
                      message.duration = object.duration;
                  else if (typeof object.duration === "object")
                      message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
              return message;
          };

          /**
           * Creates a plain object from an UnapprovedBlockProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.UnapprovedBlockProto
           * @static
           * @param {casper.UnapprovedBlockProto} message UnapprovedBlockProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          UnapprovedBlockProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.candidate = null;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.timestamp = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.duration = options.longs === String ? "0" : 0;
              }
              if (message.candidate != null && message.hasOwnProperty("candidate"))
                  object.candidate = $root.casper.ApprovedBlockCandidateProto.toObject(message.candidate, options);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (typeof message.timestamp === "number")
                      object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                  else
                      object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
              if (message.duration != null && message.hasOwnProperty("duration"))
                  if (typeof message.duration === "number")
                      object.duration = options.longs === String ? String(message.duration) : message.duration;
                  else
                      object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
              return object;
          };

          /**
           * Converts this UnapprovedBlockProto to JSON.
           * @function toJSON
           * @memberof casper.UnapprovedBlockProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          UnapprovedBlockProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return UnapprovedBlockProto;
      })();

      casper.Signature = (function() {

          /**
           * Properties of a Signature.
           * @memberof casper
           * @interface ISignature
           * @property {Uint8Array|null} [publicKey] Signature publicKey
           * @property {string|null} [algorithm] Signature algorithm
           * @property {Uint8Array|null} [sig] Signature sig
           */

          /**
           * Constructs a new Signature.
           * @memberof casper
           * @classdesc Represents a Signature.
           * @implements ISignature
           * @constructor
           * @param {casper.ISignature=} [properties] Properties to set
           */
          function Signature(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Signature publicKey.
           * @member {Uint8Array} publicKey
           * @memberof casper.Signature
           * @instance
           */
          Signature.prototype.publicKey = $util.newBuffer([]);

          /**
           * Signature algorithm.
           * @member {string} algorithm
           * @memberof casper.Signature
           * @instance
           */
          Signature.prototype.algorithm = "";

          /**
           * Signature sig.
           * @member {Uint8Array} sig
           * @memberof casper.Signature
           * @instance
           */
          Signature.prototype.sig = $util.newBuffer([]);

          /**
           * Creates a new Signature instance using the specified properties.
           * @function create
           * @memberof casper.Signature
           * @static
           * @param {casper.ISignature=} [properties] Properties to set
           * @returns {casper.Signature} Signature instance
           */
          Signature.create = function create(properties) {
              return new Signature(properties);
          };

          /**
           * Encodes the specified Signature message. Does not implicitly {@link casper.Signature.verify|verify} messages.
           * @function encode
           * @memberof casper.Signature
           * @static
           * @param {casper.ISignature} message Signature message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Signature.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
              if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.algorithm);
              if (message.sig != null && message.hasOwnProperty("sig"))
                  writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sig);
              return writer;
          };

          /**
           * Encodes the specified Signature message, length delimited. Does not implicitly {@link casper.Signature.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.Signature
           * @static
           * @param {casper.ISignature} message Signature message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Signature.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Signature message from the specified reader or buffer.
           * @function decode
           * @memberof casper.Signature
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.Signature} Signature
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Signature.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.Signature();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.publicKey = reader.bytes();
                      break;
                  case 2:
                      message.algorithm = reader.string();
                      break;
                  case 3:
                      message.sig = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Signature message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.Signature
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.Signature} Signature
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Signature.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Signature message.
           * @function verify
           * @memberof casper.Signature
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Signature.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                  if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                      return "publicKey: buffer expected";
              if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                  if (!$util.isString(message.algorithm))
                      return "algorithm: string expected";
              if (message.sig != null && message.hasOwnProperty("sig"))
                  if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                      return "sig: buffer expected";
              return null;
          };

          /**
           * Creates a Signature message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.Signature
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.Signature} Signature
           */
          Signature.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.Signature)
                  return object;
              var message = new $root.casper.Signature();
              if (object.publicKey != null)
                  if (typeof object.publicKey === "string")
                      $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                  else if (object.publicKey.length)
                      message.publicKey = object.publicKey;
              if (object.algorithm != null)
                  message.algorithm = String(object.algorithm);
              if (object.sig != null)
                  if (typeof object.sig === "string")
                      $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
                  else if (object.sig.length)
                      message.sig = object.sig;
              return message;
          };

          /**
           * Creates a plain object from a Signature message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.Signature
           * @static
           * @param {casper.Signature} message Signature
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Signature.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.publicKey = "";
                  else {
                      object.publicKey = [];
                      if (options.bytes !== Array)
                          object.publicKey = $util.newBuffer(object.publicKey);
                  }
                  object.algorithm = "";
                  if (options.bytes === String)
                      object.sig = "";
                  else {
                      object.sig = [];
                      if (options.bytes !== Array)
                          object.sig = $util.newBuffer(object.sig);
                  }
              }
              if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                  object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
              if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                  object.algorithm = message.algorithm;
              if (message.sig != null && message.hasOwnProperty("sig"))
                  object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
              return object;
          };

          /**
           * Converts this Signature to JSON.
           * @function toJSON
           * @memberof casper.Signature
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Signature.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Signature;
      })();

      casper.BlockApprovalProto = (function() {

          /**
           * Properties of a BlockApprovalProto.
           * @memberof casper
           * @interface IBlockApprovalProto
           * @property {casper.IApprovedBlockCandidateProto|null} [candidate] BlockApprovalProto candidate
           * @property {casper.ISignature|null} [sig] BlockApprovalProto sig
           */

          /**
           * Constructs a new BlockApprovalProto.
           * @memberof casper
           * @classdesc Represents a BlockApprovalProto.
           * @implements IBlockApprovalProto
           * @constructor
           * @param {casper.IBlockApprovalProto=} [properties] Properties to set
           */
          function BlockApprovalProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockApprovalProto candidate.
           * @member {casper.IApprovedBlockCandidateProto|null|undefined} candidate
           * @memberof casper.BlockApprovalProto
           * @instance
           */
          BlockApprovalProto.prototype.candidate = null;

          /**
           * BlockApprovalProto sig.
           * @member {casper.ISignature|null|undefined} sig
           * @memberof casper.BlockApprovalProto
           * @instance
           */
          BlockApprovalProto.prototype.sig = null;

          /**
           * Creates a new BlockApprovalProto instance using the specified properties.
           * @function create
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {casper.IBlockApprovalProto=} [properties] Properties to set
           * @returns {casper.BlockApprovalProto} BlockApprovalProto instance
           */
          BlockApprovalProto.create = function create(properties) {
              return new BlockApprovalProto(properties);
          };

          /**
           * Encodes the specified BlockApprovalProto message. Does not implicitly {@link casper.BlockApprovalProto.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {casper.IBlockApprovalProto} message BlockApprovalProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockApprovalProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.candidate != null && message.hasOwnProperty("candidate"))
                  $root.casper.ApprovedBlockCandidateProto.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.sig != null && message.hasOwnProperty("sig"))
                  $root.casper.Signature.encode(message.sig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified BlockApprovalProto message, length delimited. Does not implicitly {@link casper.BlockApprovalProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {casper.IBlockApprovalProto} message BlockApprovalProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockApprovalProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockApprovalProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockApprovalProto} BlockApprovalProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockApprovalProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockApprovalProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.candidate = $root.casper.ApprovedBlockCandidateProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.sig = $root.casper.Signature.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockApprovalProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockApprovalProto} BlockApprovalProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockApprovalProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockApprovalProto message.
           * @function verify
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockApprovalProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.candidate != null && message.hasOwnProperty("candidate")) {
                  var error = $root.casper.ApprovedBlockCandidateProto.verify(message.candidate);
                  if (error)
                      return "candidate." + error;
              }
              if (message.sig != null && message.hasOwnProperty("sig")) {
                  var error = $root.casper.Signature.verify(message.sig);
                  if (error)
                      return "sig." + error;
              }
              return null;
          };

          /**
           * Creates a BlockApprovalProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockApprovalProto} BlockApprovalProto
           */
          BlockApprovalProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockApprovalProto)
                  return object;
              var message = new $root.casper.BlockApprovalProto();
              if (object.candidate != null) {
                  if (typeof object.candidate !== "object")
                      throw TypeError(".casper.BlockApprovalProto.candidate: object expected");
                  message.candidate = $root.casper.ApprovedBlockCandidateProto.fromObject(object.candidate);
              }
              if (object.sig != null) {
                  if (typeof object.sig !== "object")
                      throw TypeError(".casper.BlockApprovalProto.sig: object expected");
                  message.sig = $root.casper.Signature.fromObject(object.sig);
              }
              return message;
          };

          /**
           * Creates a plain object from a BlockApprovalProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockApprovalProto
           * @static
           * @param {casper.BlockApprovalProto} message BlockApprovalProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockApprovalProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.candidate = null;
                  object.sig = null;
              }
              if (message.candidate != null && message.hasOwnProperty("candidate"))
                  object.candidate = $root.casper.ApprovedBlockCandidateProto.toObject(message.candidate, options);
              if (message.sig != null && message.hasOwnProperty("sig"))
                  object.sig = $root.casper.Signature.toObject(message.sig, options);
              return object;
          };

          /**
           * Converts this BlockApprovalProto to JSON.
           * @function toJSON
           * @memberof casper.BlockApprovalProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockApprovalProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockApprovalProto;
      })();

      casper.ApprovedBlockProto = (function() {

          /**
           * Properties of an ApprovedBlockProto.
           * @memberof casper
           * @interface IApprovedBlockProto
           * @property {casper.IApprovedBlockCandidateProto|null} [candidate] ApprovedBlockProto candidate
           * @property {Array.<casper.ISignature>|null} [sigs] ApprovedBlockProto sigs
           */

          /**
           * Constructs a new ApprovedBlockProto.
           * @memberof casper
           * @classdesc Represents an ApprovedBlockProto.
           * @implements IApprovedBlockProto
           * @constructor
           * @param {casper.IApprovedBlockProto=} [properties] Properties to set
           */
          function ApprovedBlockProto(properties) {
              this.sigs = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ApprovedBlockProto candidate.
           * @member {casper.IApprovedBlockCandidateProto|null|undefined} candidate
           * @memberof casper.ApprovedBlockProto
           * @instance
           */
          ApprovedBlockProto.prototype.candidate = null;

          /**
           * ApprovedBlockProto sigs.
           * @member {Array.<casper.ISignature>} sigs
           * @memberof casper.ApprovedBlockProto
           * @instance
           */
          ApprovedBlockProto.prototype.sigs = $util.emptyArray;

          /**
           * Creates a new ApprovedBlockProto instance using the specified properties.
           * @function create
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {casper.IApprovedBlockProto=} [properties] Properties to set
           * @returns {casper.ApprovedBlockProto} ApprovedBlockProto instance
           */
          ApprovedBlockProto.create = function create(properties) {
              return new ApprovedBlockProto(properties);
          };

          /**
           * Encodes the specified ApprovedBlockProto message. Does not implicitly {@link casper.ApprovedBlockProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {casper.IApprovedBlockProto} message ApprovedBlockProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ApprovedBlockProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.candidate != null && message.hasOwnProperty("candidate"))
                  $root.casper.ApprovedBlockCandidateProto.encode(message.candidate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.sigs != null && message.sigs.length)
                  for (var i = 0; i < message.sigs.length; ++i)
                      $root.casper.Signature.encode(message.sigs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ApprovedBlockProto message, length delimited. Does not implicitly {@link casper.ApprovedBlockProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {casper.IApprovedBlockProto} message ApprovedBlockProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ApprovedBlockProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an ApprovedBlockProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ApprovedBlockProto} ApprovedBlockProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ApprovedBlockProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ApprovedBlockProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.candidate = $root.casper.ApprovedBlockCandidateProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.sigs && message.sigs.length))
                          message.sigs = [];
                      message.sigs.push($root.casper.Signature.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an ApprovedBlockProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ApprovedBlockProto} ApprovedBlockProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ApprovedBlockProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an ApprovedBlockProto message.
           * @function verify
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ApprovedBlockProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.candidate != null && message.hasOwnProperty("candidate")) {
                  var error = $root.casper.ApprovedBlockCandidateProto.verify(message.candidate);
                  if (error)
                      return "candidate." + error;
              }
              if (message.sigs != null && message.hasOwnProperty("sigs")) {
                  if (!Array.isArray(message.sigs))
                      return "sigs: array expected";
                  for (var i = 0; i < message.sigs.length; ++i) {
                      var error = $root.casper.Signature.verify(message.sigs[i]);
                      if (error)
                          return "sigs." + error;
                  }
              }
              return null;
          };

          /**
           * Creates an ApprovedBlockProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ApprovedBlockProto} ApprovedBlockProto
           */
          ApprovedBlockProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ApprovedBlockProto)
                  return object;
              var message = new $root.casper.ApprovedBlockProto();
              if (object.candidate != null) {
                  if (typeof object.candidate !== "object")
                      throw TypeError(".casper.ApprovedBlockProto.candidate: object expected");
                  message.candidate = $root.casper.ApprovedBlockCandidateProto.fromObject(object.candidate);
              }
              if (object.sigs) {
                  if (!Array.isArray(object.sigs))
                      throw TypeError(".casper.ApprovedBlockProto.sigs: array expected");
                  message.sigs = [];
                  for (var i = 0; i < object.sigs.length; ++i) {
                      if (typeof object.sigs[i] !== "object")
                          throw TypeError(".casper.ApprovedBlockProto.sigs: object expected");
                      message.sigs[i] = $root.casper.Signature.fromObject(object.sigs[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from an ApprovedBlockProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ApprovedBlockProto
           * @static
           * @param {casper.ApprovedBlockProto} message ApprovedBlockProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ApprovedBlockProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.sigs = [];
              if (options.defaults)
                  object.candidate = null;
              if (message.candidate != null && message.hasOwnProperty("candidate"))
                  object.candidate = $root.casper.ApprovedBlockCandidateProto.toObject(message.candidate, options);
              if (message.sigs && message.sigs.length) {
                  object.sigs = [];
                  for (var j = 0; j < message.sigs.length; ++j)
                      object.sigs[j] = $root.casper.Signature.toObject(message.sigs[j], options);
              }
              return object;
          };

          /**
           * Converts this ApprovedBlockProto to JSON.
           * @function toJSON
           * @memberof casper.ApprovedBlockProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ApprovedBlockProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ApprovedBlockProto;
      })();

      casper.ApprovedBlockRequestProto = (function() {

          /**
           * Properties of an ApprovedBlockRequestProto.
           * @memberof casper
           * @interface IApprovedBlockRequestProto
           * @property {string|null} [identifier] ApprovedBlockRequestProto identifier
           */

          /**
           * Constructs a new ApprovedBlockRequestProto.
           * @memberof casper
           * @classdesc Represents an ApprovedBlockRequestProto.
           * @implements IApprovedBlockRequestProto
           * @constructor
           * @param {casper.IApprovedBlockRequestProto=} [properties] Properties to set
           */
          function ApprovedBlockRequestProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ApprovedBlockRequestProto identifier.
           * @member {string} identifier
           * @memberof casper.ApprovedBlockRequestProto
           * @instance
           */
          ApprovedBlockRequestProto.prototype.identifier = "";

          /**
           * Creates a new ApprovedBlockRequestProto instance using the specified properties.
           * @function create
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {casper.IApprovedBlockRequestProto=} [properties] Properties to set
           * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto instance
           */
          ApprovedBlockRequestProto.create = function create(properties) {
              return new ApprovedBlockRequestProto(properties);
          };

          /**
           * Encodes the specified ApprovedBlockRequestProto message. Does not implicitly {@link casper.ApprovedBlockRequestProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {casper.IApprovedBlockRequestProto} message ApprovedBlockRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ApprovedBlockRequestProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.identifier != null && message.hasOwnProperty("identifier"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
              return writer;
          };

          /**
           * Encodes the specified ApprovedBlockRequestProto message, length delimited. Does not implicitly {@link casper.ApprovedBlockRequestProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {casper.IApprovedBlockRequestProto} message ApprovedBlockRequestProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ApprovedBlockRequestProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an ApprovedBlockRequestProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ApprovedBlockRequestProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ApprovedBlockRequestProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.identifier = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an ApprovedBlockRequestProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ApprovedBlockRequestProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an ApprovedBlockRequestProto message.
           * @function verify
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ApprovedBlockRequestProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.identifier != null && message.hasOwnProperty("identifier"))
                  if (!$util.isString(message.identifier))
                      return "identifier: string expected";
              return null;
          };

          /**
           * Creates an ApprovedBlockRequestProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ApprovedBlockRequestProto} ApprovedBlockRequestProto
           */
          ApprovedBlockRequestProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ApprovedBlockRequestProto)
                  return object;
              var message = new $root.casper.ApprovedBlockRequestProto();
              if (object.identifier != null)
                  message.identifier = String(object.identifier);
              return message;
          };

          /**
           * Creates a plain object from an ApprovedBlockRequestProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ApprovedBlockRequestProto
           * @static
           * @param {casper.ApprovedBlockRequestProto} message ApprovedBlockRequestProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ApprovedBlockRequestProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.identifier = "";
              if (message.identifier != null && message.hasOwnProperty("identifier"))
                  object.identifier = message.identifier;
              return object;
          };

          /**
           * Converts this ApprovedBlockRequestProto to JSON.
           * @function toJSON
           * @memberof casper.ApprovedBlockRequestProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ApprovedBlockRequestProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ApprovedBlockRequestProto;
      })();

      casper.NoApprovedBlockAvailableProto = (function() {

          /**
           * Properties of a NoApprovedBlockAvailableProto.
           * @memberof casper
           * @interface INoApprovedBlockAvailableProto
           * @property {string|null} [identifier] NoApprovedBlockAvailableProto identifier
           * @property {string|null} [nodeIdentifer] NoApprovedBlockAvailableProto nodeIdentifer
           */

          /**
           * Constructs a new NoApprovedBlockAvailableProto.
           * @memberof casper
           * @classdesc Represents a NoApprovedBlockAvailableProto.
           * @implements INoApprovedBlockAvailableProto
           * @constructor
           * @param {casper.INoApprovedBlockAvailableProto=} [properties] Properties to set
           */
          function NoApprovedBlockAvailableProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * NoApprovedBlockAvailableProto identifier.
           * @member {string} identifier
           * @memberof casper.NoApprovedBlockAvailableProto
           * @instance
           */
          NoApprovedBlockAvailableProto.prototype.identifier = "";

          /**
           * NoApprovedBlockAvailableProto nodeIdentifer.
           * @member {string} nodeIdentifer
           * @memberof casper.NoApprovedBlockAvailableProto
           * @instance
           */
          NoApprovedBlockAvailableProto.prototype.nodeIdentifer = "";

          /**
           * Creates a new NoApprovedBlockAvailableProto instance using the specified properties.
           * @function create
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {casper.INoApprovedBlockAvailableProto=} [properties] Properties to set
           * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto instance
           */
          NoApprovedBlockAvailableProto.create = function create(properties) {
              return new NoApprovedBlockAvailableProto(properties);
          };

          /**
           * Encodes the specified NoApprovedBlockAvailableProto message. Does not implicitly {@link casper.NoApprovedBlockAvailableProto.verify|verify} messages.
           * @function encode
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {casper.INoApprovedBlockAvailableProto} message NoApprovedBlockAvailableProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          NoApprovedBlockAvailableProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.identifier != null && message.hasOwnProperty("identifier"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.identifier);
              if (message.nodeIdentifer != null && message.hasOwnProperty("nodeIdentifer"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.nodeIdentifer);
              return writer;
          };

          /**
           * Encodes the specified NoApprovedBlockAvailableProto message, length delimited. Does not implicitly {@link casper.NoApprovedBlockAvailableProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {casper.INoApprovedBlockAvailableProto} message NoApprovedBlockAvailableProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          NoApprovedBlockAvailableProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a NoApprovedBlockAvailableProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          NoApprovedBlockAvailableProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.NoApprovedBlockAvailableProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.identifier = reader.string();
                      break;
                  case 2:
                      message.nodeIdentifer = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a NoApprovedBlockAvailableProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          NoApprovedBlockAvailableProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a NoApprovedBlockAvailableProto message.
           * @function verify
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          NoApprovedBlockAvailableProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.identifier != null && message.hasOwnProperty("identifier"))
                  if (!$util.isString(message.identifier))
                      return "identifier: string expected";
              if (message.nodeIdentifer != null && message.hasOwnProperty("nodeIdentifer"))
                  if (!$util.isString(message.nodeIdentifer))
                      return "nodeIdentifer: string expected";
              return null;
          };

          /**
           * Creates a NoApprovedBlockAvailableProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.NoApprovedBlockAvailableProto} NoApprovedBlockAvailableProto
           */
          NoApprovedBlockAvailableProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.NoApprovedBlockAvailableProto)
                  return object;
              var message = new $root.casper.NoApprovedBlockAvailableProto();
              if (object.identifier != null)
                  message.identifier = String(object.identifier);
              if (object.nodeIdentifer != null)
                  message.nodeIdentifer = String(object.nodeIdentifer);
              return message;
          };

          /**
           * Creates a plain object from a NoApprovedBlockAvailableProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.NoApprovedBlockAvailableProto
           * @static
           * @param {casper.NoApprovedBlockAvailableProto} message NoApprovedBlockAvailableProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          NoApprovedBlockAvailableProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.identifier = "";
                  object.nodeIdentifer = "";
              }
              if (message.identifier != null && message.hasOwnProperty("identifier"))
                  object.identifier = message.identifier;
              if (message.nodeIdentifer != null && message.hasOwnProperty("nodeIdentifer"))
                  object.nodeIdentifer = message.nodeIdentifer;
              return object;
          };

          /**
           * Converts this NoApprovedBlockAvailableProto to JSON.
           * @function toJSON
           * @memberof casper.NoApprovedBlockAvailableProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          NoApprovedBlockAvailableProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return NoApprovedBlockAvailableProto;
      })();

      casper.BlockMessageProto = (function() {

          /**
           * Properties of a BlockMessageProto.
           * @memberof casper
           * @interface IBlockMessageProto
           * @property {Uint8Array|null} [blockHash] BlockMessageProto blockHash
           * @property {casper.IHeaderProto|null} [header] BlockMessageProto header
           * @property {casper.IBodyProto|null} [body] BlockMessageProto body
           * @property {Array.<casper.IJustificationProto>|null} [justifications] BlockMessageProto justifications
           * @property {Uint8Array|null} [sender] BlockMessageProto sender
           * @property {number|null} [seqNum] BlockMessageProto seqNum
           * @property {Uint8Array|null} [sig] BlockMessageProto sig
           * @property {string|null} [sigAlgorithm] BlockMessageProto sigAlgorithm
           * @property {string|null} [shardId] BlockMessageProto shardId
           * @property {Uint8Array|null} [extraBytes] BlockMessageProto extraBytes
           */

          /**
           * Constructs a new BlockMessageProto.
           * @memberof casper
           * @classdesc Represents a BlockMessageProto.
           * @implements IBlockMessageProto
           * @constructor
           * @param {casper.IBlockMessageProto=} [properties] Properties to set
           */
          function BlockMessageProto(properties) {
              this.justifications = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockMessageProto blockHash.
           * @member {Uint8Array} blockHash
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.blockHash = $util.newBuffer([]);

          /**
           * BlockMessageProto header.
           * @member {casper.IHeaderProto|null|undefined} header
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.header = null;

          /**
           * BlockMessageProto body.
           * @member {casper.IBodyProto|null|undefined} body
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.body = null;

          /**
           * BlockMessageProto justifications.
           * @member {Array.<casper.IJustificationProto>} justifications
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.justifications = $util.emptyArray;

          /**
           * BlockMessageProto sender.
           * @member {Uint8Array} sender
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.sender = $util.newBuffer([]);

          /**
           * BlockMessageProto seqNum.
           * @member {number} seqNum
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.seqNum = 0;

          /**
           * BlockMessageProto sig.
           * @member {Uint8Array} sig
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.sig = $util.newBuffer([]);

          /**
           * BlockMessageProto sigAlgorithm.
           * @member {string} sigAlgorithm
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.sigAlgorithm = "";

          /**
           * BlockMessageProto shardId.
           * @member {string} shardId
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.shardId = "";

          /**
           * BlockMessageProto extraBytes.
           * @member {Uint8Array} extraBytes
           * @memberof casper.BlockMessageProto
           * @instance
           */
          BlockMessageProto.prototype.extraBytes = $util.newBuffer([]);

          /**
           * Creates a new BlockMessageProto instance using the specified properties.
           * @function create
           * @memberof casper.BlockMessageProto
           * @static
           * @param {casper.IBlockMessageProto=} [properties] Properties to set
           * @returns {casper.BlockMessageProto} BlockMessageProto instance
           */
          BlockMessageProto.create = function create(properties) {
              return new BlockMessageProto(properties);
          };

          /**
           * Encodes the specified BlockMessageProto message. Does not implicitly {@link casper.BlockMessageProto.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockMessageProto
           * @static
           * @param {casper.IBlockMessageProto} message BlockMessageProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockMessageProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockHash);
              if (message.header != null && message.hasOwnProperty("header"))
                  $root.casper.HeaderProto.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.body != null && message.hasOwnProperty("body"))
                  $root.casper.BodyProto.encode(message.body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              if (message.justifications != null && message.justifications.length)
                  for (var i = 0; i < message.justifications.length; ++i)
                      $root.casper.JustificationProto.encode(message.justifications[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
              if (message.sender != null && message.hasOwnProperty("sender"))
                  writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.sender);
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  writer.uint32(/* id 6, wireType 0 =*/48).int32(message.seqNum);
              if (message.sig != null && message.hasOwnProperty("sig"))
                  writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.sig);
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  writer.uint32(/* id 8, wireType 2 =*/66).string(message.sigAlgorithm);
              if (message.shardId != null && message.hasOwnProperty("shardId"))
                  writer.uint32(/* id 9, wireType 2 =*/74).string(message.shardId);
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.extraBytes);
              return writer;
          };

          /**
           * Encodes the specified BlockMessageProto message, length delimited. Does not implicitly {@link casper.BlockMessageProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockMessageProto
           * @static
           * @param {casper.IBlockMessageProto} message BlockMessageProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockMessageProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockMessageProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockMessageProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockMessageProto} BlockMessageProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockMessageProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockMessageProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.blockHash = reader.bytes();
                      break;
                  case 2:
                      message.header = $root.casper.HeaderProto.decode(reader, reader.uint32());
                      break;
                  case 3:
                      message.body = $root.casper.BodyProto.decode(reader, reader.uint32());
                      break;
                  case 4:
                      if (!(message.justifications && message.justifications.length))
                          message.justifications = [];
                      message.justifications.push($root.casper.JustificationProto.decode(reader, reader.uint32()));
                      break;
                  case 5:
                      message.sender = reader.bytes();
                      break;
                  case 6:
                      message.seqNum = reader.int32();
                      break;
                  case 7:
                      message.sig = reader.bytes();
                      break;
                  case 8:
                      message.sigAlgorithm = reader.string();
                      break;
                  case 9:
                      message.shardId = reader.string();
                      break;
                  case 10:
                      message.extraBytes = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockMessageProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockMessageProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockMessageProto} BlockMessageProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockMessageProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockMessageProto message.
           * @function verify
           * @memberof casper.BlockMessageProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockMessageProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                      return "blockHash: buffer expected";
              if (message.header != null && message.hasOwnProperty("header")) {
                  var error = $root.casper.HeaderProto.verify(message.header);
                  if (error)
                      return "header." + error;
              }
              if (message.body != null && message.hasOwnProperty("body")) {
                  var error = $root.casper.BodyProto.verify(message.body);
                  if (error)
                      return "body." + error;
              }
              if (message.justifications != null && message.hasOwnProperty("justifications")) {
                  if (!Array.isArray(message.justifications))
                      return "justifications: array expected";
                  for (var i = 0; i < message.justifications.length; ++i) {
                      var error = $root.casper.JustificationProto.verify(message.justifications[i]);
                      if (error)
                          return "justifications." + error;
                  }
              }
              if (message.sender != null && message.hasOwnProperty("sender"))
                  if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                      return "sender: buffer expected";
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  if (!$util.isInteger(message.seqNum))
                      return "seqNum: integer expected";
              if (message.sig != null && message.hasOwnProperty("sig"))
                  if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                      return "sig: buffer expected";
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  if (!$util.isString(message.sigAlgorithm))
                      return "sigAlgorithm: string expected";
              if (message.shardId != null && message.hasOwnProperty("shardId"))
                  if (!$util.isString(message.shardId))
                      return "shardId: string expected";
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                      return "extraBytes: buffer expected";
              return null;
          };

          /**
           * Creates a BlockMessageProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockMessageProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockMessageProto} BlockMessageProto
           */
          BlockMessageProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockMessageProto)
                  return object;
              var message = new $root.casper.BlockMessageProto();
              if (object.blockHash != null)
                  if (typeof object.blockHash === "string")
                      $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                  else if (object.blockHash.length)
                      message.blockHash = object.blockHash;
              if (object.header != null) {
                  if (typeof object.header !== "object")
                      throw TypeError(".casper.BlockMessageProto.header: object expected");
                  message.header = $root.casper.HeaderProto.fromObject(object.header);
              }
              if (object.body != null) {
                  if (typeof object.body !== "object")
                      throw TypeError(".casper.BlockMessageProto.body: object expected");
                  message.body = $root.casper.BodyProto.fromObject(object.body);
              }
              if (object.justifications) {
                  if (!Array.isArray(object.justifications))
                      throw TypeError(".casper.BlockMessageProto.justifications: array expected");
                  message.justifications = [];
                  for (var i = 0; i < object.justifications.length; ++i) {
                      if (typeof object.justifications[i] !== "object")
                          throw TypeError(".casper.BlockMessageProto.justifications: object expected");
                      message.justifications[i] = $root.casper.JustificationProto.fromObject(object.justifications[i]);
                  }
              }
              if (object.sender != null)
                  if (typeof object.sender === "string")
                      $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                  else if (object.sender.length)
                      message.sender = object.sender;
              if (object.seqNum != null)
                  message.seqNum = object.seqNum | 0;
              if (object.sig != null)
                  if (typeof object.sig === "string")
                      $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
                  else if (object.sig.length)
                      message.sig = object.sig;
              if (object.sigAlgorithm != null)
                  message.sigAlgorithm = String(object.sigAlgorithm);
              if (object.shardId != null)
                  message.shardId = String(object.shardId);
              if (object.extraBytes != null)
                  if (typeof object.extraBytes === "string")
                      $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                  else if (object.extraBytes.length)
                      message.extraBytes = object.extraBytes;
              return message;
          };

          /**
           * Creates a plain object from a BlockMessageProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockMessageProto
           * @static
           * @param {casper.BlockMessageProto} message BlockMessageProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockMessageProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.justifications = [];
              if (options.defaults) {
                  if (options.bytes === String)
                      object.blockHash = "";
                  else {
                      object.blockHash = [];
                      if (options.bytes !== Array)
                          object.blockHash = $util.newBuffer(object.blockHash);
                  }
                  object.header = null;
                  object.body = null;
                  if (options.bytes === String)
                      object.sender = "";
                  else {
                      object.sender = [];
                      if (options.bytes !== Array)
                          object.sender = $util.newBuffer(object.sender);
                  }
                  object.seqNum = 0;
                  if (options.bytes === String)
                      object.sig = "";
                  else {
                      object.sig = [];
                      if (options.bytes !== Array)
                          object.sig = $util.newBuffer(object.sig);
                  }
                  object.sigAlgorithm = "";
                  object.shardId = "";
                  if (options.bytes === String)
                      object.extraBytes = "";
                  else {
                      object.extraBytes = [];
                      if (options.bytes !== Array)
                          object.extraBytes = $util.newBuffer(object.extraBytes);
                  }
              }
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
              if (message.header != null && message.hasOwnProperty("header"))
                  object.header = $root.casper.HeaderProto.toObject(message.header, options);
              if (message.body != null && message.hasOwnProperty("body"))
                  object.body = $root.casper.BodyProto.toObject(message.body, options);
              if (message.justifications && message.justifications.length) {
                  object.justifications = [];
                  for (var j = 0; j < message.justifications.length; ++j)
                      object.justifications[j] = $root.casper.JustificationProto.toObject(message.justifications[j], options);
              }
              if (message.sender != null && message.hasOwnProperty("sender"))
                  object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  object.seqNum = message.seqNum;
              if (message.sig != null && message.hasOwnProperty("sig"))
                  object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  object.sigAlgorithm = message.sigAlgorithm;
              if (message.shardId != null && message.hasOwnProperty("shardId"))
                  object.shardId = message.shardId;
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
              return object;
          };

          /**
           * Converts this BlockMessageProto to JSON.
           * @function toJSON
           * @memberof casper.BlockMessageProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockMessageProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockMessageProto;
      })();

      casper.BlockHashMessageProto = (function() {

          /**
           * Properties of a BlockHashMessageProto.
           * @memberof casper
           * @interface IBlockHashMessageProto
           * @property {Uint8Array|null} [hash] BlockHashMessageProto hash
           * @property {Uint8Array|null} [blockCreator] BlockHashMessageProto blockCreator
           */

          /**
           * Constructs a new BlockHashMessageProto.
           * @memberof casper
           * @classdesc Represents a BlockHashMessageProto.
           * @implements IBlockHashMessageProto
           * @constructor
           * @param {casper.IBlockHashMessageProto=} [properties] Properties to set
           */
          function BlockHashMessageProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockHashMessageProto hash.
           * @member {Uint8Array} hash
           * @memberof casper.BlockHashMessageProto
           * @instance
           */
          BlockHashMessageProto.prototype.hash = $util.newBuffer([]);

          /**
           * BlockHashMessageProto blockCreator.
           * @member {Uint8Array} blockCreator
           * @memberof casper.BlockHashMessageProto
           * @instance
           */
          BlockHashMessageProto.prototype.blockCreator = $util.newBuffer([]);

          /**
           * Creates a new BlockHashMessageProto instance using the specified properties.
           * @function create
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {casper.IBlockHashMessageProto=} [properties] Properties to set
           * @returns {casper.BlockHashMessageProto} BlockHashMessageProto instance
           */
          BlockHashMessageProto.create = function create(properties) {
              return new BlockHashMessageProto(properties);
          };

          /**
           * Encodes the specified BlockHashMessageProto message. Does not implicitly {@link casper.BlockHashMessageProto.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {casper.IBlockHashMessageProto} message BlockHashMessageProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockHashMessageProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
              if (message.blockCreator != null && message.hasOwnProperty("blockCreator"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blockCreator);
              return writer;
          };

          /**
           * Encodes the specified BlockHashMessageProto message, length delimited. Does not implicitly {@link casper.BlockHashMessageProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {casper.IBlockHashMessageProto} message BlockHashMessageProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockHashMessageProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockHashMessageProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockHashMessageProto} BlockHashMessageProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockHashMessageProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockHashMessageProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.hash = reader.bytes();
                      break;
                  case 2:
                      message.blockCreator = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockHashMessageProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockHashMessageProto} BlockHashMessageProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockHashMessageProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockHashMessageProto message.
           * @function verify
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockHashMessageProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                      return "hash: buffer expected";
              if (message.blockCreator != null && message.hasOwnProperty("blockCreator"))
                  if (!(message.blockCreator && typeof message.blockCreator.length === "number" || $util.isString(message.blockCreator)))
                      return "blockCreator: buffer expected";
              return null;
          };

          /**
           * Creates a BlockHashMessageProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockHashMessageProto} BlockHashMessageProto
           */
          BlockHashMessageProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockHashMessageProto)
                  return object;
              var message = new $root.casper.BlockHashMessageProto();
              if (object.hash != null)
                  if (typeof object.hash === "string")
                      $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                  else if (object.hash.length)
                      message.hash = object.hash;
              if (object.blockCreator != null)
                  if (typeof object.blockCreator === "string")
                      $util.base64.decode(object.blockCreator, message.blockCreator = $util.newBuffer($util.base64.length(object.blockCreator)), 0);
                  else if (object.blockCreator.length)
                      message.blockCreator = object.blockCreator;
              return message;
          };

          /**
           * Creates a plain object from a BlockHashMessageProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockHashMessageProto
           * @static
           * @param {casper.BlockHashMessageProto} message BlockHashMessageProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockHashMessageProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.hash = "";
                  else {
                      object.hash = [];
                      if (options.bytes !== Array)
                          object.hash = $util.newBuffer(object.hash);
                  }
                  if (options.bytes === String)
                      object.blockCreator = "";
                  else {
                      object.blockCreator = [];
                      if (options.bytes !== Array)
                          object.blockCreator = $util.newBuffer(object.blockCreator);
                  }
              }
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
              if (message.blockCreator != null && message.hasOwnProperty("blockCreator"))
                  object.blockCreator = options.bytes === String ? $util.base64.encode(message.blockCreator, 0, message.blockCreator.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockCreator) : message.blockCreator;
              return object;
          };

          /**
           * Converts this BlockHashMessageProto to JSON.
           * @function toJSON
           * @memberof casper.BlockHashMessageProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockHashMessageProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockHashMessageProto;
      })();

      casper.BlockMetadataInternal = (function() {

          /**
           * Properties of a BlockMetadataInternal.
           * @memberof casper
           * @interface IBlockMetadataInternal
           * @property {Uint8Array|null} [blockHash] BlockMetadataInternal blockHash
           * @property {Array.<Uint8Array>|null} [parents] BlockMetadataInternal parents
           * @property {Uint8Array|null} [sender] BlockMetadataInternal sender
           * @property {Array.<casper.IJustificationProto>|null} [justifications] BlockMetadataInternal justifications
           * @property {Array.<casper.IBondProto>|null} [bonds] BlockMetadataInternal bonds
           * @property {number|Long|null} [blockNum] BlockMetadataInternal blockNum
           * @property {number|null} [seqNum] BlockMetadataInternal seqNum
           * @property {boolean|null} [invalid] BlockMetadataInternal invalid
           */

          /**
           * Constructs a new BlockMetadataInternal.
           * @memberof casper
           * @classdesc Represents a BlockMetadataInternal.
           * @implements IBlockMetadataInternal
           * @constructor
           * @param {casper.IBlockMetadataInternal=} [properties] Properties to set
           */
          function BlockMetadataInternal(properties) {
              this.parents = [];
              this.justifications = [];
              this.bonds = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockMetadataInternal blockHash.
           * @member {Uint8Array} blockHash
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.blockHash = $util.newBuffer([]);

          /**
           * BlockMetadataInternal parents.
           * @member {Array.<Uint8Array>} parents
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.parents = $util.emptyArray;

          /**
           * BlockMetadataInternal sender.
           * @member {Uint8Array} sender
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.sender = $util.newBuffer([]);

          /**
           * BlockMetadataInternal justifications.
           * @member {Array.<casper.IJustificationProto>} justifications
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.justifications = $util.emptyArray;

          /**
           * BlockMetadataInternal bonds.
           * @member {Array.<casper.IBondProto>} bonds
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.bonds = $util.emptyArray;

          /**
           * BlockMetadataInternal blockNum.
           * @member {number|Long} blockNum
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.blockNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * BlockMetadataInternal seqNum.
           * @member {number} seqNum
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.seqNum = 0;

          /**
           * BlockMetadataInternal invalid.
           * @member {boolean} invalid
           * @memberof casper.BlockMetadataInternal
           * @instance
           */
          BlockMetadataInternal.prototype.invalid = false;

          /**
           * Creates a new BlockMetadataInternal instance using the specified properties.
           * @function create
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {casper.IBlockMetadataInternal=} [properties] Properties to set
           * @returns {casper.BlockMetadataInternal} BlockMetadataInternal instance
           */
          BlockMetadataInternal.create = function create(properties) {
              return new BlockMetadataInternal(properties);
          };

          /**
           * Encodes the specified BlockMetadataInternal message. Does not implicitly {@link casper.BlockMetadataInternal.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {casper.IBlockMetadataInternal} message BlockMetadataInternal message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockMetadataInternal.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockHash);
              if (message.parents != null && message.parents.length)
                  for (var i = 0; i < message.parents.length; ++i)
                      writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.parents[i]);
              if (message.sender != null && message.hasOwnProperty("sender"))
                  writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sender);
              if (message.justifications != null && message.justifications.length)
                  for (var i = 0; i < message.justifications.length; ++i)
                      $root.casper.JustificationProto.encode(message.justifications[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
              if (message.bonds != null && message.bonds.length)
                  for (var i = 0; i < message.bonds.length; ++i)
                      $root.casper.BondProto.encode(message.bonds[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
              if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                  writer.uint32(/* id 6, wireType 0 =*/48).int64(message.blockNum);
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  writer.uint32(/* id 7, wireType 0 =*/56).int32(message.seqNum);
              if (message.invalid != null && message.hasOwnProperty("invalid"))
                  writer.uint32(/* id 8, wireType 0 =*/64).bool(message.invalid);
              return writer;
          };

          /**
           * Encodes the specified BlockMetadataInternal message, length delimited. Does not implicitly {@link casper.BlockMetadataInternal.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {casper.IBlockMetadataInternal} message BlockMetadataInternal message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockMetadataInternal.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockMetadataInternal message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockMetadataInternal} BlockMetadataInternal
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockMetadataInternal.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockMetadataInternal();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.blockHash = reader.bytes();
                      break;
                  case 2:
                      if (!(message.parents && message.parents.length))
                          message.parents = [];
                      message.parents.push(reader.bytes());
                      break;
                  case 3:
                      message.sender = reader.bytes();
                      break;
                  case 4:
                      if (!(message.justifications && message.justifications.length))
                          message.justifications = [];
                      message.justifications.push($root.casper.JustificationProto.decode(reader, reader.uint32()));
                      break;
                  case 5:
                      if (!(message.bonds && message.bonds.length))
                          message.bonds = [];
                      message.bonds.push($root.casper.BondProto.decode(reader, reader.uint32()));
                      break;
                  case 6:
                      message.blockNum = reader.int64();
                      break;
                  case 7:
                      message.seqNum = reader.int32();
                      break;
                  case 8:
                      message.invalid = reader.bool();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockMetadataInternal message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockMetadataInternal} BlockMetadataInternal
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockMetadataInternal.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockMetadataInternal message.
           * @function verify
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockMetadataInternal.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  if (!(message.blockHash && typeof message.blockHash.length === "number" || $util.isString(message.blockHash)))
                      return "blockHash: buffer expected";
              if (message.parents != null && message.hasOwnProperty("parents")) {
                  if (!Array.isArray(message.parents))
                      return "parents: array expected";
                  for (var i = 0; i < message.parents.length; ++i)
                      if (!(message.parents[i] && typeof message.parents[i].length === "number" || $util.isString(message.parents[i])))
                          return "parents: buffer[] expected";
              }
              if (message.sender != null && message.hasOwnProperty("sender"))
                  if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                      return "sender: buffer expected";
              if (message.justifications != null && message.hasOwnProperty("justifications")) {
                  if (!Array.isArray(message.justifications))
                      return "justifications: array expected";
                  for (var i = 0; i < message.justifications.length; ++i) {
                      var error = $root.casper.JustificationProto.verify(message.justifications[i]);
                      if (error)
                          return "justifications." + error;
                  }
              }
              if (message.bonds != null && message.hasOwnProperty("bonds")) {
                  if (!Array.isArray(message.bonds))
                      return "bonds: array expected";
                  for (var i = 0; i < message.bonds.length; ++i) {
                      var error = $root.casper.BondProto.verify(message.bonds[i]);
                      if (error)
                          return "bonds." + error;
                  }
              }
              if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                  if (!$util.isInteger(message.blockNum) && !(message.blockNum && $util.isInteger(message.blockNum.low) && $util.isInteger(message.blockNum.high)))
                      return "blockNum: integer|Long expected";
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  if (!$util.isInteger(message.seqNum))
                      return "seqNum: integer expected";
              if (message.invalid != null && message.hasOwnProperty("invalid"))
                  if (typeof message.invalid !== "boolean")
                      return "invalid: boolean expected";
              return null;
          };

          /**
           * Creates a BlockMetadataInternal message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockMetadataInternal} BlockMetadataInternal
           */
          BlockMetadataInternal.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockMetadataInternal)
                  return object;
              var message = new $root.casper.BlockMetadataInternal();
              if (object.blockHash != null)
                  if (typeof object.blockHash === "string")
                      $util.base64.decode(object.blockHash, message.blockHash = $util.newBuffer($util.base64.length(object.blockHash)), 0);
                  else if (object.blockHash.length)
                      message.blockHash = object.blockHash;
              if (object.parents) {
                  if (!Array.isArray(object.parents))
                      throw TypeError(".casper.BlockMetadataInternal.parents: array expected");
                  message.parents = [];
                  for (var i = 0; i < object.parents.length; ++i)
                      if (typeof object.parents[i] === "string")
                          $util.base64.decode(object.parents[i], message.parents[i] = $util.newBuffer($util.base64.length(object.parents[i])), 0);
                      else if (object.parents[i].length)
                          message.parents[i] = object.parents[i];
              }
              if (object.sender != null)
                  if (typeof object.sender === "string")
                      $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                  else if (object.sender.length)
                      message.sender = object.sender;
              if (object.justifications) {
                  if (!Array.isArray(object.justifications))
                      throw TypeError(".casper.BlockMetadataInternal.justifications: array expected");
                  message.justifications = [];
                  for (var i = 0; i < object.justifications.length; ++i) {
                      if (typeof object.justifications[i] !== "object")
                          throw TypeError(".casper.BlockMetadataInternal.justifications: object expected");
                      message.justifications[i] = $root.casper.JustificationProto.fromObject(object.justifications[i]);
                  }
              }
              if (object.bonds) {
                  if (!Array.isArray(object.bonds))
                      throw TypeError(".casper.BlockMetadataInternal.bonds: array expected");
                  message.bonds = [];
                  for (var i = 0; i < object.bonds.length; ++i) {
                      if (typeof object.bonds[i] !== "object")
                          throw TypeError(".casper.BlockMetadataInternal.bonds: object expected");
                      message.bonds[i] = $root.casper.BondProto.fromObject(object.bonds[i]);
                  }
              }
              if (object.blockNum != null)
                  if ($util.Long)
                      (message.blockNum = $util.Long.fromValue(object.blockNum)).unsigned = false;
                  else if (typeof object.blockNum === "string")
                      message.blockNum = parseInt(object.blockNum, 10);
                  else if (typeof object.blockNum === "number")
                      message.blockNum = object.blockNum;
                  else if (typeof object.blockNum === "object")
                      message.blockNum = new $util.LongBits(object.blockNum.low >>> 0, object.blockNum.high >>> 0).toNumber();
              if (object.seqNum != null)
                  message.seqNum = object.seqNum | 0;
              if (object.invalid != null)
                  message.invalid = Boolean(object.invalid);
              return message;
          };

          /**
           * Creates a plain object from a BlockMetadataInternal message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockMetadataInternal
           * @static
           * @param {casper.BlockMetadataInternal} message BlockMetadataInternal
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockMetadataInternal.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object.parents = [];
                  object.justifications = [];
                  object.bonds = [];
              }
              if (options.defaults) {
                  if (options.bytes === String)
                      object.blockHash = "";
                  else {
                      object.blockHash = [];
                      if (options.bytes !== Array)
                          object.blockHash = $util.newBuffer(object.blockHash);
                  }
                  if (options.bytes === String)
                      object.sender = "";
                  else {
                      object.sender = [];
                      if (options.bytes !== Array)
                          object.sender = $util.newBuffer(object.sender);
                  }
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.blockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.blockNum = options.longs === String ? "0" : 0;
                  object.seqNum = 0;
                  object.invalid = false;
              }
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  object.blockHash = options.bytes === String ? $util.base64.encode(message.blockHash, 0, message.blockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockHash) : message.blockHash;
              if (message.parents && message.parents.length) {
                  object.parents = [];
                  for (var j = 0; j < message.parents.length; ++j)
                      object.parents[j] = options.bytes === String ? $util.base64.encode(message.parents[j], 0, message.parents[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.parents[j]) : message.parents[j];
              }
              if (message.sender != null && message.hasOwnProperty("sender"))
                  object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
              if (message.justifications && message.justifications.length) {
                  object.justifications = [];
                  for (var j = 0; j < message.justifications.length; ++j)
                      object.justifications[j] = $root.casper.JustificationProto.toObject(message.justifications[j], options);
              }
              if (message.bonds && message.bonds.length) {
                  object.bonds = [];
                  for (var j = 0; j < message.bonds.length; ++j)
                      object.bonds[j] = $root.casper.BondProto.toObject(message.bonds[j], options);
              }
              if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                  if (typeof message.blockNum === "number")
                      object.blockNum = options.longs === String ? String(message.blockNum) : message.blockNum;
                  else
                      object.blockNum = options.longs === String ? $util.Long.prototype.toString.call(message.blockNum) : options.longs === Number ? new $util.LongBits(message.blockNum.low >>> 0, message.blockNum.high >>> 0).toNumber() : message.blockNum;
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  object.seqNum = message.seqNum;
              if (message.invalid != null && message.hasOwnProperty("invalid"))
                  object.invalid = message.invalid;
              return object;
          };

          /**
           * Converts this BlockMetadataInternal to JSON.
           * @function toJSON
           * @memberof casper.BlockMetadataInternal
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockMetadataInternal.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockMetadataInternal;
      })();

      casper.HeaderProto = (function() {

          /**
           * Properties of a HeaderProto.
           * @memberof casper
           * @interface IHeaderProto
           * @property {Array.<Uint8Array>|null} [parentsHashList] HeaderProto parentsHashList
           * @property {number|Long|null} [timestamp] HeaderProto timestamp
           * @property {number|Long|null} [version] HeaderProto version
           * @property {Uint8Array|null} [extraBytes] HeaderProto extraBytes
           */

          /**
           * Constructs a new HeaderProto.
           * @memberof casper
           * @classdesc Represents a HeaderProto.
           * @implements IHeaderProto
           * @constructor
           * @param {casper.IHeaderProto=} [properties] Properties to set
           */
          function HeaderProto(properties) {
              this.parentsHashList = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * HeaderProto parentsHashList.
           * @member {Array.<Uint8Array>} parentsHashList
           * @memberof casper.HeaderProto
           * @instance
           */
          HeaderProto.prototype.parentsHashList = $util.emptyArray;

          /**
           * HeaderProto timestamp.
           * @member {number|Long} timestamp
           * @memberof casper.HeaderProto
           * @instance
           */
          HeaderProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * HeaderProto version.
           * @member {number|Long} version
           * @memberof casper.HeaderProto
           * @instance
           */
          HeaderProto.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * HeaderProto extraBytes.
           * @member {Uint8Array} extraBytes
           * @memberof casper.HeaderProto
           * @instance
           */
          HeaderProto.prototype.extraBytes = $util.newBuffer([]);

          /**
           * Creates a new HeaderProto instance using the specified properties.
           * @function create
           * @memberof casper.HeaderProto
           * @static
           * @param {casper.IHeaderProto=} [properties] Properties to set
           * @returns {casper.HeaderProto} HeaderProto instance
           */
          HeaderProto.create = function create(properties) {
              return new HeaderProto(properties);
          };

          /**
           * Encodes the specified HeaderProto message. Does not implicitly {@link casper.HeaderProto.verify|verify} messages.
           * @function encode
           * @memberof casper.HeaderProto
           * @static
           * @param {casper.IHeaderProto} message HeaderProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HeaderProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.parentsHashList != null && message.parentsHashList.length)
                  for (var i = 0; i < message.parentsHashList.length; ++i)
                      writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.parentsHashList[i]);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timestamp);
              if (message.version != null && message.hasOwnProperty("version"))
                  writer.uint32(/* id 6, wireType 0 =*/48).int64(message.version);
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.extraBytes);
              return writer;
          };

          /**
           * Encodes the specified HeaderProto message, length delimited. Does not implicitly {@link casper.HeaderProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.HeaderProto
           * @static
           * @param {casper.IHeaderProto} message HeaderProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HeaderProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a HeaderProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.HeaderProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.HeaderProto} HeaderProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HeaderProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.HeaderProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.parentsHashList && message.parentsHashList.length))
                          message.parentsHashList = [];
                      message.parentsHashList.push(reader.bytes());
                      break;
                  case 5:
                      message.timestamp = reader.int64();
                      break;
                  case 6:
                      message.version = reader.int64();
                      break;
                  case 7:
                      message.extraBytes = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a HeaderProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.HeaderProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.HeaderProto} HeaderProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HeaderProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a HeaderProto message.
           * @function verify
           * @memberof casper.HeaderProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          HeaderProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.parentsHashList != null && message.hasOwnProperty("parentsHashList")) {
                  if (!Array.isArray(message.parentsHashList))
                      return "parentsHashList: array expected";
                  for (var i = 0; i < message.parentsHashList.length; ++i)
                      if (!(message.parentsHashList[i] && typeof message.parentsHashList[i].length === "number" || $util.isString(message.parentsHashList[i])))
                          return "parentsHashList: buffer[] expected";
              }
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                      return "timestamp: integer|Long expected";
              if (message.version != null && message.hasOwnProperty("version"))
                  if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                      return "version: integer|Long expected";
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                      return "extraBytes: buffer expected";
              return null;
          };

          /**
           * Creates a HeaderProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.HeaderProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.HeaderProto} HeaderProto
           */
          HeaderProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.HeaderProto)
                  return object;
              var message = new $root.casper.HeaderProto();
              if (object.parentsHashList) {
                  if (!Array.isArray(object.parentsHashList))
                      throw TypeError(".casper.HeaderProto.parentsHashList: array expected");
                  message.parentsHashList = [];
                  for (var i = 0; i < object.parentsHashList.length; ++i)
                      if (typeof object.parentsHashList[i] === "string")
                          $util.base64.decode(object.parentsHashList[i], message.parentsHashList[i] = $util.newBuffer($util.base64.length(object.parentsHashList[i])), 0);
                      else if (object.parentsHashList[i].length)
                          message.parentsHashList[i] = object.parentsHashList[i];
              }
              if (object.timestamp != null)
                  if ($util.Long)
                      (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                  else if (typeof object.timestamp === "string")
                      message.timestamp = parseInt(object.timestamp, 10);
                  else if (typeof object.timestamp === "number")
                      message.timestamp = object.timestamp;
                  else if (typeof object.timestamp === "object")
                      message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
              if (object.version != null)
                  if ($util.Long)
                      (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                  else if (typeof object.version === "string")
                      message.version = parseInt(object.version, 10);
                  else if (typeof object.version === "number")
                      message.version = object.version;
                  else if (typeof object.version === "object")
                      message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
              if (object.extraBytes != null)
                  if (typeof object.extraBytes === "string")
                      $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                  else if (object.extraBytes.length)
                      message.extraBytes = object.extraBytes;
              return message;
          };

          /**
           * Creates a plain object from a HeaderProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.HeaderProto
           * @static
           * @param {casper.HeaderProto} message HeaderProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          HeaderProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.parentsHashList = [];
              if (options.defaults) {
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.timestamp = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.version = options.longs === String ? "0" : 0;
                  if (options.bytes === String)
                      object.extraBytes = "";
                  else {
                      object.extraBytes = [];
                      if (options.bytes !== Array)
                          object.extraBytes = $util.newBuffer(object.extraBytes);
                  }
              }
              if (message.parentsHashList && message.parentsHashList.length) {
                  object.parentsHashList = [];
                  for (var j = 0; j < message.parentsHashList.length; ++j)
                      object.parentsHashList[j] = options.bytes === String ? $util.base64.encode(message.parentsHashList[j], 0, message.parentsHashList[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.parentsHashList[j]) : message.parentsHashList[j];
              }
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (typeof message.timestamp === "number")
                      object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                  else
                      object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
              if (message.version != null && message.hasOwnProperty("version"))
                  if (typeof message.version === "number")
                      object.version = options.longs === String ? String(message.version) : message.version;
                  else
                      object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
              return object;
          };

          /**
           * Converts this HeaderProto to JSON.
           * @function toJSON
           * @memberof casper.HeaderProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          HeaderProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return HeaderProto;
      })();

      casper.DeployDataProto = (function() {

          /**
           * Properties of a DeployDataProto.
           * @memberof casper
           * @interface IDeployDataProto
           * @property {Uint8Array|null} [deployer] DeployDataProto deployer
           * @property {string|null} [term] DeployDataProto term
           * @property {number|Long|null} [timestamp] DeployDataProto timestamp
           * @property {Uint8Array|null} [sig] DeployDataProto sig
           * @property {string|null} [sigAlgorithm] DeployDataProto sigAlgorithm
           * @property {number|Long|null} [phloPrice] DeployDataProto phloPrice
           * @property {number|Long|null} [phloLimit] DeployDataProto phloLimit
           * @property {number|Long|null} [validAfterBlockNumber] DeployDataProto validAfterBlockNumber
           */

          /**
           * Constructs a new DeployDataProto.
           * @memberof casper
           * @classdesc Note: deploys are uniquely keyed by `user`, `timestamp`.
           * 
           * **TODO**: details of signatures and payment. See RHOL-781
           * @implements IDeployDataProto
           * @constructor
           * @param {casper.IDeployDataProto=} [properties] Properties to set
           */
          function DeployDataProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * DeployDataProto deployer.
           * @member {Uint8Array} deployer
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.deployer = $util.newBuffer([]);

          /**
           * DeployDataProto term.
           * @member {string} term
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.term = "";

          /**
           * DeployDataProto timestamp.
           * @member {number|Long} timestamp
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployDataProto sig.
           * @member {Uint8Array} sig
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.sig = $util.newBuffer([]);

          /**
           * DeployDataProto sigAlgorithm.
           * @member {string} sigAlgorithm
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.sigAlgorithm = "";

          /**
           * DeployDataProto phloPrice.
           * @member {number|Long} phloPrice
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.phloPrice = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployDataProto phloLimit.
           * @member {number|Long} phloLimit
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.phloLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployDataProto validAfterBlockNumber.
           * @member {number|Long} validAfterBlockNumber
           * @memberof casper.DeployDataProto
           * @instance
           */
          DeployDataProto.prototype.validAfterBlockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Creates a new DeployDataProto instance using the specified properties.
           * @function create
           * @memberof casper.DeployDataProto
           * @static
           * @param {casper.IDeployDataProto=} [properties] Properties to set
           * @returns {casper.DeployDataProto} DeployDataProto instance
           */
          DeployDataProto.create = function create(properties) {
              return new DeployDataProto(properties);
          };

          /**
           * Encodes the specified DeployDataProto message. Does not implicitly {@link casper.DeployDataProto.verify|verify} messages.
           * @function encode
           * @memberof casper.DeployDataProto
           * @static
           * @param {casper.IDeployDataProto} message DeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DeployDataProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.deployer != null && message.hasOwnProperty("deployer"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deployer);
              if (message.term != null && message.hasOwnProperty("term"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.term);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
              if (message.sig != null && message.hasOwnProperty("sig"))
                  writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sig);
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  writer.uint32(/* id 5, wireType 2 =*/42).string(message.sigAlgorithm);
              if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                  writer.uint32(/* id 7, wireType 0 =*/56).int64(message.phloPrice);
              if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                  writer.uint32(/* id 8, wireType 0 =*/64).int64(message.phloLimit);
              if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                  writer.uint32(/* id 10, wireType 0 =*/80).int64(message.validAfterBlockNumber);
              return writer;
          };

          /**
           * Encodes the specified DeployDataProto message, length delimited. Does not implicitly {@link casper.DeployDataProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.DeployDataProto
           * @static
           * @param {casper.IDeployDataProto} message DeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DeployDataProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DeployDataProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.DeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.DeployDataProto} DeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DeployDataProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DeployDataProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.deployer = reader.bytes();
                      break;
                  case 2:
                      message.term = reader.string();
                      break;
                  case 3:
                      message.timestamp = reader.int64();
                      break;
                  case 4:
                      message.sig = reader.bytes();
                      break;
                  case 5:
                      message.sigAlgorithm = reader.string();
                      break;
                  case 7:
                      message.phloPrice = reader.int64();
                      break;
                  case 8:
                      message.phloLimit = reader.int64();
                      break;
                  case 10:
                      message.validAfterBlockNumber = reader.int64();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a DeployDataProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.DeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.DeployDataProto} DeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DeployDataProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DeployDataProto message.
           * @function verify
           * @memberof casper.DeployDataProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DeployDataProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.deployer != null && message.hasOwnProperty("deployer"))
                  if (!(message.deployer && typeof message.deployer.length === "number" || $util.isString(message.deployer)))
                      return "deployer: buffer expected";
              if (message.term != null && message.hasOwnProperty("term"))
                  if (!$util.isString(message.term))
                      return "term: string expected";
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                      return "timestamp: integer|Long expected";
              if (message.sig != null && message.hasOwnProperty("sig"))
                  if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                      return "sig: buffer expected";
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  if (!$util.isString(message.sigAlgorithm))
                      return "sigAlgorithm: string expected";
              if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                  if (!$util.isInteger(message.phloPrice) && !(message.phloPrice && $util.isInteger(message.phloPrice.low) && $util.isInteger(message.phloPrice.high)))
                      return "phloPrice: integer|Long expected";
              if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                  if (!$util.isInteger(message.phloLimit) && !(message.phloLimit && $util.isInteger(message.phloLimit.low) && $util.isInteger(message.phloLimit.high)))
                      return "phloLimit: integer|Long expected";
              if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                  if (!$util.isInteger(message.validAfterBlockNumber) && !(message.validAfterBlockNumber && $util.isInteger(message.validAfterBlockNumber.low) && $util.isInteger(message.validAfterBlockNumber.high)))
                      return "validAfterBlockNumber: integer|Long expected";
              return null;
          };

          /**
           * Creates a DeployDataProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.DeployDataProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.DeployDataProto} DeployDataProto
           */
          DeployDataProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.DeployDataProto)
                  return object;
              var message = new $root.casper.DeployDataProto();
              if (object.deployer != null)
                  if (typeof object.deployer === "string")
                      $util.base64.decode(object.deployer, message.deployer = $util.newBuffer($util.base64.length(object.deployer)), 0);
                  else if (object.deployer.length)
                      message.deployer = object.deployer;
              if (object.term != null)
                  message.term = String(object.term);
              if (object.timestamp != null)
                  if ($util.Long)
                      (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                  else if (typeof object.timestamp === "string")
                      message.timestamp = parseInt(object.timestamp, 10);
                  else if (typeof object.timestamp === "number")
                      message.timestamp = object.timestamp;
                  else if (typeof object.timestamp === "object")
                      message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
              if (object.sig != null)
                  if (typeof object.sig === "string")
                      $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
                  else if (object.sig.length)
                      message.sig = object.sig;
              if (object.sigAlgorithm != null)
                  message.sigAlgorithm = String(object.sigAlgorithm);
              if (object.phloPrice != null)
                  if ($util.Long)
                      (message.phloPrice = $util.Long.fromValue(object.phloPrice)).unsigned = false;
                  else if (typeof object.phloPrice === "string")
                      message.phloPrice = parseInt(object.phloPrice, 10);
                  else if (typeof object.phloPrice === "number")
                      message.phloPrice = object.phloPrice;
                  else if (typeof object.phloPrice === "object")
                      message.phloPrice = new $util.LongBits(object.phloPrice.low >>> 0, object.phloPrice.high >>> 0).toNumber();
              if (object.phloLimit != null)
                  if ($util.Long)
                      (message.phloLimit = $util.Long.fromValue(object.phloLimit)).unsigned = false;
                  else if (typeof object.phloLimit === "string")
                      message.phloLimit = parseInt(object.phloLimit, 10);
                  else if (typeof object.phloLimit === "number")
                      message.phloLimit = object.phloLimit;
                  else if (typeof object.phloLimit === "object")
                      message.phloLimit = new $util.LongBits(object.phloLimit.low >>> 0, object.phloLimit.high >>> 0).toNumber();
              if (object.validAfterBlockNumber != null)
                  if ($util.Long)
                      (message.validAfterBlockNumber = $util.Long.fromValue(object.validAfterBlockNumber)).unsigned = false;
                  else if (typeof object.validAfterBlockNumber === "string")
                      message.validAfterBlockNumber = parseInt(object.validAfterBlockNumber, 10);
                  else if (typeof object.validAfterBlockNumber === "number")
                      message.validAfterBlockNumber = object.validAfterBlockNumber;
                  else if (typeof object.validAfterBlockNumber === "object")
                      message.validAfterBlockNumber = new $util.LongBits(object.validAfterBlockNumber.low >>> 0, object.validAfterBlockNumber.high >>> 0).toNumber();
              return message;
          };

          /**
           * Creates a plain object from a DeployDataProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.DeployDataProto
           * @static
           * @param {casper.DeployDataProto} message DeployDataProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DeployDataProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.deployer = "";
                  else {
                      object.deployer = [];
                      if (options.bytes !== Array)
                          object.deployer = $util.newBuffer(object.deployer);
                  }
                  object.term = "";
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.timestamp = options.longs === String ? "0" : 0;
                  if (options.bytes === String)
                      object.sig = "";
                  else {
                      object.sig = [];
                      if (options.bytes !== Array)
                          object.sig = $util.newBuffer(object.sig);
                  }
                  object.sigAlgorithm = "";
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.phloPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.phloPrice = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.phloLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.phloLimit = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.validAfterBlockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.validAfterBlockNumber = options.longs === String ? "0" : 0;
              }
              if (message.deployer != null && message.hasOwnProperty("deployer"))
                  object.deployer = options.bytes === String ? $util.base64.encode(message.deployer, 0, message.deployer.length) : options.bytes === Array ? Array.prototype.slice.call(message.deployer) : message.deployer;
              if (message.term != null && message.hasOwnProperty("term"))
                  object.term = message.term;
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (typeof message.timestamp === "number")
                      object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                  else
                      object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
              if (message.sig != null && message.hasOwnProperty("sig"))
                  object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  object.sigAlgorithm = message.sigAlgorithm;
              if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                  if (typeof message.phloPrice === "number")
                      object.phloPrice = options.longs === String ? String(message.phloPrice) : message.phloPrice;
                  else
                      object.phloPrice = options.longs === String ? $util.Long.prototype.toString.call(message.phloPrice) : options.longs === Number ? new $util.LongBits(message.phloPrice.low >>> 0, message.phloPrice.high >>> 0).toNumber() : message.phloPrice;
              if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                  if (typeof message.phloLimit === "number")
                      object.phloLimit = options.longs === String ? String(message.phloLimit) : message.phloLimit;
                  else
                      object.phloLimit = options.longs === String ? $util.Long.prototype.toString.call(message.phloLimit) : options.longs === Number ? new $util.LongBits(message.phloLimit.low >>> 0, message.phloLimit.high >>> 0).toNumber() : message.phloLimit;
              if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                  if (typeof message.validAfterBlockNumber === "number")
                      object.validAfterBlockNumber = options.longs === String ? String(message.validAfterBlockNumber) : message.validAfterBlockNumber;
                  else
                      object.validAfterBlockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.validAfterBlockNumber) : options.longs === Number ? new $util.LongBits(message.validAfterBlockNumber.low >>> 0, message.validAfterBlockNumber.high >>> 0).toNumber() : message.validAfterBlockNumber;
              return object;
          };

          /**
           * Converts this DeployDataProto to JSON.
           * @function toJSON
           * @memberof casper.DeployDataProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DeployDataProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return DeployDataProto;
      })();

      casper.ProcessedDeployProto = (function() {

          /**
           * Properties of a ProcessedDeployProto.
           * @memberof casper
           * @interface IProcessedDeployProto
           * @property {casper.IDeployDataProto|null} [deploy] ProcessedDeployProto deploy
           * @property {IPCost|null} [cost] ProcessedDeployProto cost
           * @property {Array.<casper.IEventProto>|null} [deployLog] ProcessedDeployProto deployLog
           * @property {boolean|null} [errored] ProcessedDeployProto errored
           * @property {string|null} [systemDeployError] ProcessedDeployProto systemDeployError
           */

          /**
           * Constructs a new ProcessedDeployProto.
           * @memberof casper
           * @classdesc Represents a ProcessedDeployProto.
           * @implements IProcessedDeployProto
           * @constructor
           * @param {casper.IProcessedDeployProto=} [properties] Properties to set
           */
          function ProcessedDeployProto(properties) {
              this.deployLog = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ProcessedDeployProto deploy.
           * @member {casper.IDeployDataProto|null|undefined} deploy
           * @memberof casper.ProcessedDeployProto
           * @instance
           */
          ProcessedDeployProto.prototype.deploy = null;

          /**
           * ProcessedDeployProto cost.
           * @member {IPCost|null|undefined} cost
           * @memberof casper.ProcessedDeployProto
           * @instance
           */
          ProcessedDeployProto.prototype.cost = null;

          /**
           * ProcessedDeployProto deployLog.
           * @member {Array.<casper.IEventProto>} deployLog
           * @memberof casper.ProcessedDeployProto
           * @instance
           */
          ProcessedDeployProto.prototype.deployLog = $util.emptyArray;

          /**
           * ProcessedDeployProto errored.
           * @member {boolean} errored
           * @memberof casper.ProcessedDeployProto
           * @instance
           */
          ProcessedDeployProto.prototype.errored = false;

          /**
           * ProcessedDeployProto systemDeployError.
           * @member {string} systemDeployError
           * @memberof casper.ProcessedDeployProto
           * @instance
           */
          ProcessedDeployProto.prototype.systemDeployError = "";

          /**
           * Creates a new ProcessedDeployProto instance using the specified properties.
           * @function create
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {casper.IProcessedDeployProto=} [properties] Properties to set
           * @returns {casper.ProcessedDeployProto} ProcessedDeployProto instance
           */
          ProcessedDeployProto.create = function create(properties) {
              return new ProcessedDeployProto(properties);
          };

          /**
           * Encodes the specified ProcessedDeployProto message. Does not implicitly {@link casper.ProcessedDeployProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {casper.IProcessedDeployProto} message ProcessedDeployProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProcessedDeployProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.deploy != null && message.hasOwnProperty("deploy"))
                  $root.casper.DeployDataProto.encode(message.deploy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.cost != null && message.hasOwnProperty("cost"))
                  $root.PCost.encode(message.cost, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.deployLog != null && message.deployLog.length)
                  for (var i = 0; i < message.deployLog.length; ++i)
                      $root.casper.EventProto.encode(message.deployLog[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              if (message.errored != null && message.hasOwnProperty("errored"))
                  writer.uint32(/* id 5, wireType 0 =*/40).bool(message.errored);
              if (message.systemDeployError != null && message.hasOwnProperty("systemDeployError"))
                  writer.uint32(/* id 6, wireType 2 =*/50).string(message.systemDeployError);
              return writer;
          };

          /**
           * Encodes the specified ProcessedDeployProto message, length delimited. Does not implicitly {@link casper.ProcessedDeployProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {casper.IProcessedDeployProto} message ProcessedDeployProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProcessedDeployProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ProcessedDeployProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ProcessedDeployProto} ProcessedDeployProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProcessedDeployProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ProcessedDeployProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.deploy = $root.casper.DeployDataProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.cost = $root.PCost.decode(reader, reader.uint32());
                      break;
                  case 3:
                      if (!(message.deployLog && message.deployLog.length))
                          message.deployLog = [];
                      message.deployLog.push($root.casper.EventProto.decode(reader, reader.uint32()));
                      break;
                  case 5:
                      message.errored = reader.bool();
                      break;
                  case 6:
                      message.systemDeployError = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ProcessedDeployProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ProcessedDeployProto} ProcessedDeployProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProcessedDeployProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ProcessedDeployProto message.
           * @function verify
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ProcessedDeployProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.deploy != null && message.hasOwnProperty("deploy")) {
                  var error = $root.casper.DeployDataProto.verify(message.deploy);
                  if (error)
                      return "deploy." + error;
              }
              if (message.cost != null && message.hasOwnProperty("cost")) {
                  var error = $root.PCost.verify(message.cost);
                  if (error)
                      return "cost." + error;
              }
              if (message.deployLog != null && message.hasOwnProperty("deployLog")) {
                  if (!Array.isArray(message.deployLog))
                      return "deployLog: array expected";
                  for (var i = 0; i < message.deployLog.length; ++i) {
                      var error = $root.casper.EventProto.verify(message.deployLog[i]);
                      if (error)
                          return "deployLog." + error;
                  }
              }
              if (message.errored != null && message.hasOwnProperty("errored"))
                  if (typeof message.errored !== "boolean")
                      return "errored: boolean expected";
              if (message.systemDeployError != null && message.hasOwnProperty("systemDeployError"))
                  if (!$util.isString(message.systemDeployError))
                      return "systemDeployError: string expected";
              return null;
          };

          /**
           * Creates a ProcessedDeployProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ProcessedDeployProto} ProcessedDeployProto
           */
          ProcessedDeployProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ProcessedDeployProto)
                  return object;
              var message = new $root.casper.ProcessedDeployProto();
              if (object.deploy != null) {
                  if (typeof object.deploy !== "object")
                      throw TypeError(".casper.ProcessedDeployProto.deploy: object expected");
                  message.deploy = $root.casper.DeployDataProto.fromObject(object.deploy);
              }
              if (object.cost != null) {
                  if (typeof object.cost !== "object")
                      throw TypeError(".casper.ProcessedDeployProto.cost: object expected");
                  message.cost = $root.PCost.fromObject(object.cost);
              }
              if (object.deployLog) {
                  if (!Array.isArray(object.deployLog))
                      throw TypeError(".casper.ProcessedDeployProto.deployLog: array expected");
                  message.deployLog = [];
                  for (var i = 0; i < object.deployLog.length; ++i) {
                      if (typeof object.deployLog[i] !== "object")
                          throw TypeError(".casper.ProcessedDeployProto.deployLog: object expected");
                      message.deployLog[i] = $root.casper.EventProto.fromObject(object.deployLog[i]);
                  }
              }
              if (object.errored != null)
                  message.errored = Boolean(object.errored);
              if (object.systemDeployError != null)
                  message.systemDeployError = String(object.systemDeployError);
              return message;
          };

          /**
           * Creates a plain object from a ProcessedDeployProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ProcessedDeployProto
           * @static
           * @param {casper.ProcessedDeployProto} message ProcessedDeployProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ProcessedDeployProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.deployLog = [];
              if (options.defaults) {
                  object.deploy = null;
                  object.cost = null;
                  object.errored = false;
                  object.systemDeployError = "";
              }
              if (message.deploy != null && message.hasOwnProperty("deploy"))
                  object.deploy = $root.casper.DeployDataProto.toObject(message.deploy, options);
              if (message.cost != null && message.hasOwnProperty("cost"))
                  object.cost = $root.PCost.toObject(message.cost, options);
              if (message.deployLog && message.deployLog.length) {
                  object.deployLog = [];
                  for (var j = 0; j < message.deployLog.length; ++j)
                      object.deployLog[j] = $root.casper.EventProto.toObject(message.deployLog[j], options);
              }
              if (message.errored != null && message.hasOwnProperty("errored"))
                  object.errored = message.errored;
              if (message.systemDeployError != null && message.hasOwnProperty("systemDeployError"))
                  object.systemDeployError = message.systemDeployError;
              return object;
          };

          /**
           * Converts this ProcessedDeployProto to JSON.
           * @function toJSON
           * @memberof casper.ProcessedDeployProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ProcessedDeployProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ProcessedDeployProto;
      })();

      casper.SlashSystemDeployDataProto = (function() {

          /**
           * Properties of a SlashSystemDeployDataProto.
           * @memberof casper
           * @interface ISlashSystemDeployDataProto
           * @property {Uint8Array|null} [invalidBlockHash] SlashSystemDeployDataProto invalidBlockHash
           * @property {Uint8Array|null} [issuerPublicKey] SlashSystemDeployDataProto issuerPublicKey
           */

          /**
           * Constructs a new SlashSystemDeployDataProto.
           * @memberof casper
           * @classdesc Represents a SlashSystemDeployDataProto.
           * @implements ISlashSystemDeployDataProto
           * @constructor
           * @param {casper.ISlashSystemDeployDataProto=} [properties] Properties to set
           */
          function SlashSystemDeployDataProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * SlashSystemDeployDataProto invalidBlockHash.
           * @member {Uint8Array} invalidBlockHash
           * @memberof casper.SlashSystemDeployDataProto
           * @instance
           */
          SlashSystemDeployDataProto.prototype.invalidBlockHash = $util.newBuffer([]);

          /**
           * SlashSystemDeployDataProto issuerPublicKey.
           * @member {Uint8Array} issuerPublicKey
           * @memberof casper.SlashSystemDeployDataProto
           * @instance
           */
          SlashSystemDeployDataProto.prototype.issuerPublicKey = $util.newBuffer([]);

          /**
           * Creates a new SlashSystemDeployDataProto instance using the specified properties.
           * @function create
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {casper.ISlashSystemDeployDataProto=} [properties] Properties to set
           * @returns {casper.SlashSystemDeployDataProto} SlashSystemDeployDataProto instance
           */
          SlashSystemDeployDataProto.create = function create(properties) {
              return new SlashSystemDeployDataProto(properties);
          };

          /**
           * Encodes the specified SlashSystemDeployDataProto message. Does not implicitly {@link casper.SlashSystemDeployDataProto.verify|verify} messages.
           * @function encode
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {casper.ISlashSystemDeployDataProto} message SlashSystemDeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SlashSystemDeployDataProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.invalidBlockHash != null && message.hasOwnProperty("invalidBlockHash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.invalidBlockHash);
              if (message.issuerPublicKey != null && message.hasOwnProperty("issuerPublicKey"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.issuerPublicKey);
              return writer;
          };

          /**
           * Encodes the specified SlashSystemDeployDataProto message, length delimited. Does not implicitly {@link casper.SlashSystemDeployDataProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {casper.ISlashSystemDeployDataProto} message SlashSystemDeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SlashSystemDeployDataProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SlashSystemDeployDataProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.SlashSystemDeployDataProto} SlashSystemDeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SlashSystemDeployDataProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.SlashSystemDeployDataProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.invalidBlockHash = reader.bytes();
                      break;
                  case 2:
                      message.issuerPublicKey = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a SlashSystemDeployDataProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.SlashSystemDeployDataProto} SlashSystemDeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SlashSystemDeployDataProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SlashSystemDeployDataProto message.
           * @function verify
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SlashSystemDeployDataProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.invalidBlockHash != null && message.hasOwnProperty("invalidBlockHash"))
                  if (!(message.invalidBlockHash && typeof message.invalidBlockHash.length === "number" || $util.isString(message.invalidBlockHash)))
                      return "invalidBlockHash: buffer expected";
              if (message.issuerPublicKey != null && message.hasOwnProperty("issuerPublicKey"))
                  if (!(message.issuerPublicKey && typeof message.issuerPublicKey.length === "number" || $util.isString(message.issuerPublicKey)))
                      return "issuerPublicKey: buffer expected";
              return null;
          };

          /**
           * Creates a SlashSystemDeployDataProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.SlashSystemDeployDataProto} SlashSystemDeployDataProto
           */
          SlashSystemDeployDataProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.SlashSystemDeployDataProto)
                  return object;
              var message = new $root.casper.SlashSystemDeployDataProto();
              if (object.invalidBlockHash != null)
                  if (typeof object.invalidBlockHash === "string")
                      $util.base64.decode(object.invalidBlockHash, message.invalidBlockHash = $util.newBuffer($util.base64.length(object.invalidBlockHash)), 0);
                  else if (object.invalidBlockHash.length)
                      message.invalidBlockHash = object.invalidBlockHash;
              if (object.issuerPublicKey != null)
                  if (typeof object.issuerPublicKey === "string")
                      $util.base64.decode(object.issuerPublicKey, message.issuerPublicKey = $util.newBuffer($util.base64.length(object.issuerPublicKey)), 0);
                  else if (object.issuerPublicKey.length)
                      message.issuerPublicKey = object.issuerPublicKey;
              return message;
          };

          /**
           * Creates a plain object from a SlashSystemDeployDataProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.SlashSystemDeployDataProto
           * @static
           * @param {casper.SlashSystemDeployDataProto} message SlashSystemDeployDataProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SlashSystemDeployDataProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.invalidBlockHash = "";
                  else {
                      object.invalidBlockHash = [];
                      if (options.bytes !== Array)
                          object.invalidBlockHash = $util.newBuffer(object.invalidBlockHash);
                  }
                  if (options.bytes === String)
                      object.issuerPublicKey = "";
                  else {
                      object.issuerPublicKey = [];
                      if (options.bytes !== Array)
                          object.issuerPublicKey = $util.newBuffer(object.issuerPublicKey);
                  }
              }
              if (message.invalidBlockHash != null && message.hasOwnProperty("invalidBlockHash"))
                  object.invalidBlockHash = options.bytes === String ? $util.base64.encode(message.invalidBlockHash, 0, message.invalidBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.invalidBlockHash) : message.invalidBlockHash;
              if (message.issuerPublicKey != null && message.hasOwnProperty("issuerPublicKey"))
                  object.issuerPublicKey = options.bytes === String ? $util.base64.encode(message.issuerPublicKey, 0, message.issuerPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.issuerPublicKey) : message.issuerPublicKey;
              return object;
          };

          /**
           * Converts this SlashSystemDeployDataProto to JSON.
           * @function toJSON
           * @memberof casper.SlashSystemDeployDataProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SlashSystemDeployDataProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return SlashSystemDeployDataProto;
      })();

      casper.CloseBlockSystemDeployDataProto = (function() {

          /**
           * Properties of a CloseBlockSystemDeployDataProto.
           * @memberof casper
           * @interface ICloseBlockSystemDeployDataProto
           */

          /**
           * Constructs a new CloseBlockSystemDeployDataProto.
           * @memberof casper
           * @classdesc Represents a CloseBlockSystemDeployDataProto.
           * @implements ICloseBlockSystemDeployDataProto
           * @constructor
           * @param {casper.ICloseBlockSystemDeployDataProto=} [properties] Properties to set
           */
          function CloseBlockSystemDeployDataProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new CloseBlockSystemDeployDataProto instance using the specified properties.
           * @function create
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {casper.ICloseBlockSystemDeployDataProto=} [properties] Properties to set
           * @returns {casper.CloseBlockSystemDeployDataProto} CloseBlockSystemDeployDataProto instance
           */
          CloseBlockSystemDeployDataProto.create = function create(properties) {
              return new CloseBlockSystemDeployDataProto(properties);
          };

          /**
           * Encodes the specified CloseBlockSystemDeployDataProto message. Does not implicitly {@link casper.CloseBlockSystemDeployDataProto.verify|verify} messages.
           * @function encode
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {casper.ICloseBlockSystemDeployDataProto} message CloseBlockSystemDeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CloseBlockSystemDeployDataProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified CloseBlockSystemDeployDataProto message, length delimited. Does not implicitly {@link casper.CloseBlockSystemDeployDataProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {casper.ICloseBlockSystemDeployDataProto} message CloseBlockSystemDeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CloseBlockSystemDeployDataProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a CloseBlockSystemDeployDataProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.CloseBlockSystemDeployDataProto} CloseBlockSystemDeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CloseBlockSystemDeployDataProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.CloseBlockSystemDeployDataProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a CloseBlockSystemDeployDataProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.CloseBlockSystemDeployDataProto} CloseBlockSystemDeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CloseBlockSystemDeployDataProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a CloseBlockSystemDeployDataProto message.
           * @function verify
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          CloseBlockSystemDeployDataProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a CloseBlockSystemDeployDataProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.CloseBlockSystemDeployDataProto} CloseBlockSystemDeployDataProto
           */
          CloseBlockSystemDeployDataProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.CloseBlockSystemDeployDataProto)
                  return object;
              return new $root.casper.CloseBlockSystemDeployDataProto();
          };

          /**
           * Creates a plain object from a CloseBlockSystemDeployDataProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @static
           * @param {casper.CloseBlockSystemDeployDataProto} message CloseBlockSystemDeployDataProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          CloseBlockSystemDeployDataProto.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this CloseBlockSystemDeployDataProto to JSON.
           * @function toJSON
           * @memberof casper.CloseBlockSystemDeployDataProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          CloseBlockSystemDeployDataProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return CloseBlockSystemDeployDataProto;
      })();

      casper.SystemDeployDataProto = (function() {

          /**
           * Properties of a SystemDeployDataProto.
           * @memberof casper
           * @interface ISystemDeployDataProto
           * @property {casper.ISlashSystemDeployDataProto|null} [slashSystemDeploy] SystemDeployDataProto slashSystemDeploy
           * @property {casper.ICloseBlockSystemDeployDataProto|null} [closeBlockSystemDeploy] SystemDeployDataProto closeBlockSystemDeploy
           */

          /**
           * Constructs a new SystemDeployDataProto.
           * @memberof casper
           * @classdesc Represents a SystemDeployDataProto.
           * @implements ISystemDeployDataProto
           * @constructor
           * @param {casper.ISystemDeployDataProto=} [properties] Properties to set
           */
          function SystemDeployDataProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * SystemDeployDataProto slashSystemDeploy.
           * @member {casper.ISlashSystemDeployDataProto|null|undefined} slashSystemDeploy
           * @memberof casper.SystemDeployDataProto
           * @instance
           */
          SystemDeployDataProto.prototype.slashSystemDeploy = null;

          /**
           * SystemDeployDataProto closeBlockSystemDeploy.
           * @member {casper.ICloseBlockSystemDeployDataProto|null|undefined} closeBlockSystemDeploy
           * @memberof casper.SystemDeployDataProto
           * @instance
           */
          SystemDeployDataProto.prototype.closeBlockSystemDeploy = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * SystemDeployDataProto systemDeploy.
           * @member {"slashSystemDeploy"|"closeBlockSystemDeploy"|undefined} systemDeploy
           * @memberof casper.SystemDeployDataProto
           * @instance
           */
          Object.defineProperty(SystemDeployDataProto.prototype, "systemDeploy", {
              get: $util.oneOfGetter($oneOfFields = ["slashSystemDeploy", "closeBlockSystemDeploy"]),
              set: $util.oneOfSetter($oneOfFields)
          });

          /**
           * Creates a new SystemDeployDataProto instance using the specified properties.
           * @function create
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {casper.ISystemDeployDataProto=} [properties] Properties to set
           * @returns {casper.SystemDeployDataProto} SystemDeployDataProto instance
           */
          SystemDeployDataProto.create = function create(properties) {
              return new SystemDeployDataProto(properties);
          };

          /**
           * Encodes the specified SystemDeployDataProto message. Does not implicitly {@link casper.SystemDeployDataProto.verify|verify} messages.
           * @function encode
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {casper.ISystemDeployDataProto} message SystemDeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SystemDeployDataProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.slashSystemDeploy != null && message.hasOwnProperty("slashSystemDeploy"))
                  $root.casper.SlashSystemDeployDataProto.encode(message.slashSystemDeploy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.closeBlockSystemDeploy != null && message.hasOwnProperty("closeBlockSystemDeploy"))
                  $root.casper.CloseBlockSystemDeployDataProto.encode(message.closeBlockSystemDeploy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified SystemDeployDataProto message, length delimited. Does not implicitly {@link casper.SystemDeployDataProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {casper.ISystemDeployDataProto} message SystemDeployDataProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SystemDeployDataProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SystemDeployDataProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.SystemDeployDataProto} SystemDeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SystemDeployDataProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.SystemDeployDataProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.slashSystemDeploy = $root.casper.SlashSystemDeployDataProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.closeBlockSystemDeploy = $root.casper.CloseBlockSystemDeployDataProto.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a SystemDeployDataProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.SystemDeployDataProto} SystemDeployDataProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SystemDeployDataProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SystemDeployDataProto message.
           * @function verify
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SystemDeployDataProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              var properties = {};
              if (message.slashSystemDeploy != null && message.hasOwnProperty("slashSystemDeploy")) {
                  properties.systemDeploy = 1;
                  {
                      var error = $root.casper.SlashSystemDeployDataProto.verify(message.slashSystemDeploy);
                      if (error)
                          return "slashSystemDeploy." + error;
                  }
              }
              if (message.closeBlockSystemDeploy != null && message.hasOwnProperty("closeBlockSystemDeploy")) {
                  if (properties.systemDeploy === 1)
                      return "systemDeploy: multiple values";
                  properties.systemDeploy = 1;
                  {
                      var error = $root.casper.CloseBlockSystemDeployDataProto.verify(message.closeBlockSystemDeploy);
                      if (error)
                          return "closeBlockSystemDeploy." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a SystemDeployDataProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.SystemDeployDataProto} SystemDeployDataProto
           */
          SystemDeployDataProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.SystemDeployDataProto)
                  return object;
              var message = new $root.casper.SystemDeployDataProto();
              if (object.slashSystemDeploy != null) {
                  if (typeof object.slashSystemDeploy !== "object")
                      throw TypeError(".casper.SystemDeployDataProto.slashSystemDeploy: object expected");
                  message.slashSystemDeploy = $root.casper.SlashSystemDeployDataProto.fromObject(object.slashSystemDeploy);
              }
              if (object.closeBlockSystemDeploy != null) {
                  if (typeof object.closeBlockSystemDeploy !== "object")
                      throw TypeError(".casper.SystemDeployDataProto.closeBlockSystemDeploy: object expected");
                  message.closeBlockSystemDeploy = $root.casper.CloseBlockSystemDeployDataProto.fromObject(object.closeBlockSystemDeploy);
              }
              return message;
          };

          /**
           * Creates a plain object from a SystemDeployDataProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.SystemDeployDataProto
           * @static
           * @param {casper.SystemDeployDataProto} message SystemDeployDataProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SystemDeployDataProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (message.slashSystemDeploy != null && message.hasOwnProperty("slashSystemDeploy")) {
                  object.slashSystemDeploy = $root.casper.SlashSystemDeployDataProto.toObject(message.slashSystemDeploy, options);
                  if (options.oneofs)
                      object.systemDeploy = "slashSystemDeploy";
              }
              if (message.closeBlockSystemDeploy != null && message.hasOwnProperty("closeBlockSystemDeploy")) {
                  object.closeBlockSystemDeploy = $root.casper.CloseBlockSystemDeployDataProto.toObject(message.closeBlockSystemDeploy, options);
                  if (options.oneofs)
                      object.systemDeploy = "closeBlockSystemDeploy";
              }
              return object;
          };

          /**
           * Converts this SystemDeployDataProto to JSON.
           * @function toJSON
           * @memberof casper.SystemDeployDataProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SystemDeployDataProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return SystemDeployDataProto;
      })();

      casper.ProcessedSystemDeployProto = (function() {

          /**
           * Properties of a ProcessedSystemDeployProto.
           * @memberof casper
           * @interface IProcessedSystemDeployProto
           * @property {casper.ISystemDeployDataProto|null} [systemDeploy] ProcessedSystemDeployProto systemDeploy
           * @property {Array.<casper.IEventProto>|null} [deployLog] ProcessedSystemDeployProto deployLog
           * @property {string|null} [errorMsg] ProcessedSystemDeployProto errorMsg
           */

          /**
           * Constructs a new ProcessedSystemDeployProto.
           * @memberof casper
           * @classdesc Represents a ProcessedSystemDeployProto.
           * @implements IProcessedSystemDeployProto
           * @constructor
           * @param {casper.IProcessedSystemDeployProto=} [properties] Properties to set
           */
          function ProcessedSystemDeployProto(properties) {
              this.deployLog = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ProcessedSystemDeployProto systemDeploy.
           * @member {casper.ISystemDeployDataProto|null|undefined} systemDeploy
           * @memberof casper.ProcessedSystemDeployProto
           * @instance
           */
          ProcessedSystemDeployProto.prototype.systemDeploy = null;

          /**
           * ProcessedSystemDeployProto deployLog.
           * @member {Array.<casper.IEventProto>} deployLog
           * @memberof casper.ProcessedSystemDeployProto
           * @instance
           */
          ProcessedSystemDeployProto.prototype.deployLog = $util.emptyArray;

          /**
           * ProcessedSystemDeployProto errorMsg.
           * @member {string} errorMsg
           * @memberof casper.ProcessedSystemDeployProto
           * @instance
           */
          ProcessedSystemDeployProto.prototype.errorMsg = "";

          /**
           * Creates a new ProcessedSystemDeployProto instance using the specified properties.
           * @function create
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {casper.IProcessedSystemDeployProto=} [properties] Properties to set
           * @returns {casper.ProcessedSystemDeployProto} ProcessedSystemDeployProto instance
           */
          ProcessedSystemDeployProto.create = function create(properties) {
              return new ProcessedSystemDeployProto(properties);
          };

          /**
           * Encodes the specified ProcessedSystemDeployProto message. Does not implicitly {@link casper.ProcessedSystemDeployProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {casper.IProcessedSystemDeployProto} message ProcessedSystemDeployProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProcessedSystemDeployProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.systemDeploy != null && message.hasOwnProperty("systemDeploy"))
                  $root.casper.SystemDeployDataProto.encode(message.systemDeploy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.deployLog != null && message.deployLog.length)
                  for (var i = 0; i < message.deployLog.length; ++i)
                      $root.casper.EventProto.encode(message.deployLog[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                  writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMsg);
              return writer;
          };

          /**
           * Encodes the specified ProcessedSystemDeployProto message, length delimited. Does not implicitly {@link casper.ProcessedSystemDeployProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {casper.IProcessedSystemDeployProto} message ProcessedSystemDeployProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProcessedSystemDeployProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ProcessedSystemDeployProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ProcessedSystemDeployProto} ProcessedSystemDeployProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProcessedSystemDeployProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ProcessedSystemDeployProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.systemDeploy = $root.casper.SystemDeployDataProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.deployLog && message.deployLog.length))
                          message.deployLog = [];
                      message.deployLog.push($root.casper.EventProto.decode(reader, reader.uint32()));
                      break;
                  case 3:
                      message.errorMsg = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ProcessedSystemDeployProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ProcessedSystemDeployProto} ProcessedSystemDeployProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProcessedSystemDeployProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ProcessedSystemDeployProto message.
           * @function verify
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ProcessedSystemDeployProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.systemDeploy != null && message.hasOwnProperty("systemDeploy")) {
                  var error = $root.casper.SystemDeployDataProto.verify(message.systemDeploy);
                  if (error)
                      return "systemDeploy." + error;
              }
              if (message.deployLog != null && message.hasOwnProperty("deployLog")) {
                  if (!Array.isArray(message.deployLog))
                      return "deployLog: array expected";
                  for (var i = 0; i < message.deployLog.length; ++i) {
                      var error = $root.casper.EventProto.verify(message.deployLog[i]);
                      if (error)
                          return "deployLog." + error;
                  }
              }
              if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                  if (!$util.isString(message.errorMsg))
                      return "errorMsg: string expected";
              return null;
          };

          /**
           * Creates a ProcessedSystemDeployProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ProcessedSystemDeployProto} ProcessedSystemDeployProto
           */
          ProcessedSystemDeployProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ProcessedSystemDeployProto)
                  return object;
              var message = new $root.casper.ProcessedSystemDeployProto();
              if (object.systemDeploy != null) {
                  if (typeof object.systemDeploy !== "object")
                      throw TypeError(".casper.ProcessedSystemDeployProto.systemDeploy: object expected");
                  message.systemDeploy = $root.casper.SystemDeployDataProto.fromObject(object.systemDeploy);
              }
              if (object.deployLog) {
                  if (!Array.isArray(object.deployLog))
                      throw TypeError(".casper.ProcessedSystemDeployProto.deployLog: array expected");
                  message.deployLog = [];
                  for (var i = 0; i < object.deployLog.length; ++i) {
                      if (typeof object.deployLog[i] !== "object")
                          throw TypeError(".casper.ProcessedSystemDeployProto.deployLog: object expected");
                      message.deployLog[i] = $root.casper.EventProto.fromObject(object.deployLog[i]);
                  }
              }
              if (object.errorMsg != null)
                  message.errorMsg = String(object.errorMsg);
              return message;
          };

          /**
           * Creates a plain object from a ProcessedSystemDeployProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ProcessedSystemDeployProto
           * @static
           * @param {casper.ProcessedSystemDeployProto} message ProcessedSystemDeployProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ProcessedSystemDeployProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.deployLog = [];
              if (options.defaults) {
                  object.systemDeploy = null;
                  object.errorMsg = "";
              }
              if (message.systemDeploy != null && message.hasOwnProperty("systemDeploy"))
                  object.systemDeploy = $root.casper.SystemDeployDataProto.toObject(message.systemDeploy, options);
              if (message.deployLog && message.deployLog.length) {
                  object.deployLog = [];
                  for (var j = 0; j < message.deployLog.length; ++j)
                      object.deployLog[j] = $root.casper.EventProto.toObject(message.deployLog[j], options);
              }
              if (message.errorMsg != null && message.hasOwnProperty("errorMsg"))
                  object.errorMsg = message.errorMsg;
              return object;
          };

          /**
           * Converts this ProcessedSystemDeployProto to JSON.
           * @function toJSON
           * @memberof casper.ProcessedSystemDeployProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ProcessedSystemDeployProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ProcessedSystemDeployProto;
      })();

      casper.BodyProto = (function() {

          /**
           * Properties of a BodyProto.
           * @memberof casper
           * @interface IBodyProto
           * @property {casper.IRChainStateProto|null} [state] BodyProto state
           * @property {Array.<casper.IProcessedDeployProto>|null} [deploys] BodyProto deploys
           * @property {Array.<casper.IProcessedSystemDeployProto>|null} [systemDeploys] BodyProto systemDeploys
           * @property {Uint8Array|null} [extraBytes] BodyProto extraBytes
           */

          /**
           * Constructs a new BodyProto.
           * @memberof casper
           * @classdesc Represents a BodyProto.
           * @implements IBodyProto
           * @constructor
           * @param {casper.IBodyProto=} [properties] Properties to set
           */
          function BodyProto(properties) {
              this.deploys = [];
              this.systemDeploys = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BodyProto state.
           * @member {casper.IRChainStateProto|null|undefined} state
           * @memberof casper.BodyProto
           * @instance
           */
          BodyProto.prototype.state = null;

          /**
           * BodyProto deploys.
           * @member {Array.<casper.IProcessedDeployProto>} deploys
           * @memberof casper.BodyProto
           * @instance
           */
          BodyProto.prototype.deploys = $util.emptyArray;

          /**
           * BodyProto systemDeploys.
           * @member {Array.<casper.IProcessedSystemDeployProto>} systemDeploys
           * @memberof casper.BodyProto
           * @instance
           */
          BodyProto.prototype.systemDeploys = $util.emptyArray;

          /**
           * BodyProto extraBytes.
           * @member {Uint8Array} extraBytes
           * @memberof casper.BodyProto
           * @instance
           */
          BodyProto.prototype.extraBytes = $util.newBuffer([]);

          /**
           * Creates a new BodyProto instance using the specified properties.
           * @function create
           * @memberof casper.BodyProto
           * @static
           * @param {casper.IBodyProto=} [properties] Properties to set
           * @returns {casper.BodyProto} BodyProto instance
           */
          BodyProto.create = function create(properties) {
              return new BodyProto(properties);
          };

          /**
           * Encodes the specified BodyProto message. Does not implicitly {@link casper.BodyProto.verify|verify} messages.
           * @function encode
           * @memberof casper.BodyProto
           * @static
           * @param {casper.IBodyProto} message BodyProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BodyProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.state != null && message.hasOwnProperty("state"))
                  $root.casper.RChainStateProto.encode(message.state, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.deploys != null && message.deploys.length)
                  for (var i = 0; i < message.deploys.length; ++i)
                      $root.casper.ProcessedDeployProto.encode(message.deploys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.systemDeploys != null && message.systemDeploys.length)
                  for (var i = 0; i < message.systemDeploys.length; ++i)
                      $root.casper.ProcessedSystemDeployProto.encode(message.systemDeploys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.extraBytes);
              return writer;
          };

          /**
           * Encodes the specified BodyProto message, length delimited. Does not implicitly {@link casper.BodyProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BodyProto
           * @static
           * @param {casper.IBodyProto} message BodyProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BodyProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BodyProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BodyProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BodyProto} BodyProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BodyProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BodyProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.state = $root.casper.RChainStateProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.deploys && message.deploys.length))
                          message.deploys = [];
                      message.deploys.push($root.casper.ProcessedDeployProto.decode(reader, reader.uint32()));
                      break;
                  case 3:
                      if (!(message.systemDeploys && message.systemDeploys.length))
                          message.systemDeploys = [];
                      message.systemDeploys.push($root.casper.ProcessedSystemDeployProto.decode(reader, reader.uint32()));
                      break;
                  case 4:
                      message.extraBytes = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BodyProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BodyProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BodyProto} BodyProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BodyProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BodyProto message.
           * @function verify
           * @memberof casper.BodyProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BodyProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.state != null && message.hasOwnProperty("state")) {
                  var error = $root.casper.RChainStateProto.verify(message.state);
                  if (error)
                      return "state." + error;
              }
              if (message.deploys != null && message.hasOwnProperty("deploys")) {
                  if (!Array.isArray(message.deploys))
                      return "deploys: array expected";
                  for (var i = 0; i < message.deploys.length; ++i) {
                      var error = $root.casper.ProcessedDeployProto.verify(message.deploys[i]);
                      if (error)
                          return "deploys." + error;
                  }
              }
              if (message.systemDeploys != null && message.hasOwnProperty("systemDeploys")) {
                  if (!Array.isArray(message.systemDeploys))
                      return "systemDeploys: array expected";
                  for (var i = 0; i < message.systemDeploys.length; ++i) {
                      var error = $root.casper.ProcessedSystemDeployProto.verify(message.systemDeploys[i]);
                      if (error)
                          return "systemDeploys." + error;
                  }
              }
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                      return "extraBytes: buffer expected";
              return null;
          };

          /**
           * Creates a BodyProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BodyProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BodyProto} BodyProto
           */
          BodyProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BodyProto)
                  return object;
              var message = new $root.casper.BodyProto();
              if (object.state != null) {
                  if (typeof object.state !== "object")
                      throw TypeError(".casper.BodyProto.state: object expected");
                  message.state = $root.casper.RChainStateProto.fromObject(object.state);
              }
              if (object.deploys) {
                  if (!Array.isArray(object.deploys))
                      throw TypeError(".casper.BodyProto.deploys: array expected");
                  message.deploys = [];
                  for (var i = 0; i < object.deploys.length; ++i) {
                      if (typeof object.deploys[i] !== "object")
                          throw TypeError(".casper.BodyProto.deploys: object expected");
                      message.deploys[i] = $root.casper.ProcessedDeployProto.fromObject(object.deploys[i]);
                  }
              }
              if (object.systemDeploys) {
                  if (!Array.isArray(object.systemDeploys))
                      throw TypeError(".casper.BodyProto.systemDeploys: array expected");
                  message.systemDeploys = [];
                  for (var i = 0; i < object.systemDeploys.length; ++i) {
                      if (typeof object.systemDeploys[i] !== "object")
                          throw TypeError(".casper.BodyProto.systemDeploys: object expected");
                      message.systemDeploys[i] = $root.casper.ProcessedSystemDeployProto.fromObject(object.systemDeploys[i]);
                  }
              }
              if (object.extraBytes != null)
                  if (typeof object.extraBytes === "string")
                      $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                  else if (object.extraBytes.length)
                      message.extraBytes = object.extraBytes;
              return message;
          };

          /**
           * Creates a plain object from a BodyProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BodyProto
           * @static
           * @param {casper.BodyProto} message BodyProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BodyProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object.deploys = [];
                  object.systemDeploys = [];
              }
              if (options.defaults) {
                  object.state = null;
                  if (options.bytes === String)
                      object.extraBytes = "";
                  else {
                      object.extraBytes = [];
                      if (options.bytes !== Array)
                          object.extraBytes = $util.newBuffer(object.extraBytes);
                  }
              }
              if (message.state != null && message.hasOwnProperty("state"))
                  object.state = $root.casper.RChainStateProto.toObject(message.state, options);
              if (message.deploys && message.deploys.length) {
                  object.deploys = [];
                  for (var j = 0; j < message.deploys.length; ++j)
                      object.deploys[j] = $root.casper.ProcessedDeployProto.toObject(message.deploys[j], options);
              }
              if (message.systemDeploys && message.systemDeploys.length) {
                  object.systemDeploys = [];
                  for (var j = 0; j < message.systemDeploys.length; ++j)
                      object.systemDeploys[j] = $root.casper.ProcessedSystemDeployProto.toObject(message.systemDeploys[j], options);
              }
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
              return object;
          };

          /**
           * Converts this BodyProto to JSON.
           * @function toJSON
           * @memberof casper.BodyProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BodyProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BodyProto;
      })();

      casper.JustificationProto = (function() {

          /**
           * Properties of a JustificationProto.
           * @memberof casper
           * @interface IJustificationProto
           * @property {Uint8Array|null} [validator] JustificationProto validator
           * @property {Uint8Array|null} [latestBlockHash] JustificationProto latestBlockHash
           */

          /**
           * Constructs a new JustificationProto.
           * @memberof casper
           * @classdesc Represents a JustificationProto.
           * @implements IJustificationProto
           * @constructor
           * @param {casper.IJustificationProto=} [properties] Properties to set
           */
          function JustificationProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * JustificationProto validator.
           * @member {Uint8Array} validator
           * @memberof casper.JustificationProto
           * @instance
           */
          JustificationProto.prototype.validator = $util.newBuffer([]);

          /**
           * JustificationProto latestBlockHash.
           * @member {Uint8Array} latestBlockHash
           * @memberof casper.JustificationProto
           * @instance
           */
          JustificationProto.prototype.latestBlockHash = $util.newBuffer([]);

          /**
           * Creates a new JustificationProto instance using the specified properties.
           * @function create
           * @memberof casper.JustificationProto
           * @static
           * @param {casper.IJustificationProto=} [properties] Properties to set
           * @returns {casper.JustificationProto} JustificationProto instance
           */
          JustificationProto.create = function create(properties) {
              return new JustificationProto(properties);
          };

          /**
           * Encodes the specified JustificationProto message. Does not implicitly {@link casper.JustificationProto.verify|verify} messages.
           * @function encode
           * @memberof casper.JustificationProto
           * @static
           * @param {casper.IJustificationProto} message JustificationProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          JustificationProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.validator != null && message.hasOwnProperty("validator"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.validator);
              if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.latestBlockHash);
              return writer;
          };

          /**
           * Encodes the specified JustificationProto message, length delimited. Does not implicitly {@link casper.JustificationProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.JustificationProto
           * @static
           * @param {casper.IJustificationProto} message JustificationProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          JustificationProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a JustificationProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.JustificationProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.JustificationProto} JustificationProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          JustificationProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.JustificationProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.validator = reader.bytes();
                      break;
                  case 2:
                      message.latestBlockHash = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a JustificationProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.JustificationProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.JustificationProto} JustificationProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          JustificationProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a JustificationProto message.
           * @function verify
           * @memberof casper.JustificationProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          JustificationProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.validator != null && message.hasOwnProperty("validator"))
                  if (!(message.validator && typeof message.validator.length === "number" || $util.isString(message.validator)))
                      return "validator: buffer expected";
              if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                  if (!(message.latestBlockHash && typeof message.latestBlockHash.length === "number" || $util.isString(message.latestBlockHash)))
                      return "latestBlockHash: buffer expected";
              return null;
          };

          /**
           * Creates a JustificationProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.JustificationProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.JustificationProto} JustificationProto
           */
          JustificationProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.JustificationProto)
                  return object;
              var message = new $root.casper.JustificationProto();
              if (object.validator != null)
                  if (typeof object.validator === "string")
                      $util.base64.decode(object.validator, message.validator = $util.newBuffer($util.base64.length(object.validator)), 0);
                  else if (object.validator.length)
                      message.validator = object.validator;
              if (object.latestBlockHash != null)
                  if (typeof object.latestBlockHash === "string")
                      $util.base64.decode(object.latestBlockHash, message.latestBlockHash = $util.newBuffer($util.base64.length(object.latestBlockHash)), 0);
                  else if (object.latestBlockHash.length)
                      message.latestBlockHash = object.latestBlockHash;
              return message;
          };

          /**
           * Creates a plain object from a JustificationProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.JustificationProto
           * @static
           * @param {casper.JustificationProto} message JustificationProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          JustificationProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.validator = "";
                  else {
                      object.validator = [];
                      if (options.bytes !== Array)
                          object.validator = $util.newBuffer(object.validator);
                  }
                  if (options.bytes === String)
                      object.latestBlockHash = "";
                  else {
                      object.latestBlockHash = [];
                      if (options.bytes !== Array)
                          object.latestBlockHash = $util.newBuffer(object.latestBlockHash);
                  }
              }
              if (message.validator != null && message.hasOwnProperty("validator"))
                  object.validator = options.bytes === String ? $util.base64.encode(message.validator, 0, message.validator.length) : options.bytes === Array ? Array.prototype.slice.call(message.validator) : message.validator;
              if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                  object.latestBlockHash = options.bytes === String ? $util.base64.encode(message.latestBlockHash, 0, message.latestBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.latestBlockHash) : message.latestBlockHash;
              return object;
          };

          /**
           * Converts this JustificationProto to JSON.
           * @function toJSON
           * @memberof casper.JustificationProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          JustificationProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return JustificationProto;
      })();

      casper.RChainStateProto = (function() {

          /**
           * Properties of a RChainStateProto.
           * @memberof casper
           * @interface IRChainStateProto
           * @property {Uint8Array|null} [preStateHash] RChainStateProto preStateHash
           * @property {Uint8Array|null} [postStateHash] RChainStateProto postStateHash
           * @property {Array.<casper.IBondProto>|null} [bonds] RChainStateProto bonds
           * @property {number|Long|null} [blockNumber] RChainStateProto blockNumber
           */

          /**
           * Constructs a new RChainStateProto.
           * @memberof casper
           * @classdesc Represents a RChainStateProto.
           * @implements IRChainStateProto
           * @constructor
           * @param {casper.IRChainStateProto=} [properties] Properties to set
           */
          function RChainStateProto(properties) {
              this.bonds = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * RChainStateProto preStateHash.
           * @member {Uint8Array} preStateHash
           * @memberof casper.RChainStateProto
           * @instance
           */
          RChainStateProto.prototype.preStateHash = $util.newBuffer([]);

          /**
           * RChainStateProto postStateHash.
           * @member {Uint8Array} postStateHash
           * @memberof casper.RChainStateProto
           * @instance
           */
          RChainStateProto.prototype.postStateHash = $util.newBuffer([]);

          /**
           * RChainStateProto bonds.
           * @member {Array.<casper.IBondProto>} bonds
           * @memberof casper.RChainStateProto
           * @instance
           */
          RChainStateProto.prototype.bonds = $util.emptyArray;

          /**
           * RChainStateProto blockNumber.
           * @member {number|Long} blockNumber
           * @memberof casper.RChainStateProto
           * @instance
           */
          RChainStateProto.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Creates a new RChainStateProto instance using the specified properties.
           * @function create
           * @memberof casper.RChainStateProto
           * @static
           * @param {casper.IRChainStateProto=} [properties] Properties to set
           * @returns {casper.RChainStateProto} RChainStateProto instance
           */
          RChainStateProto.create = function create(properties) {
              return new RChainStateProto(properties);
          };

          /**
           * Encodes the specified RChainStateProto message. Does not implicitly {@link casper.RChainStateProto.verify|verify} messages.
           * @function encode
           * @memberof casper.RChainStateProto
           * @static
           * @param {casper.IRChainStateProto} message RChainStateProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          RChainStateProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.preStateHash);
              if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.postStateHash);
              if (message.bonds != null && message.bonds.length)
                  for (var i = 0; i < message.bonds.length; ++i)
                      $root.casper.BondProto.encode(message.bonds[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                  writer.uint32(/* id 4, wireType 0 =*/32).int64(message.blockNumber);
              return writer;
          };

          /**
           * Encodes the specified RChainStateProto message, length delimited. Does not implicitly {@link casper.RChainStateProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.RChainStateProto
           * @static
           * @param {casper.IRChainStateProto} message RChainStateProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          RChainStateProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a RChainStateProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.RChainStateProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.RChainStateProto} RChainStateProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          RChainStateProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.RChainStateProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.preStateHash = reader.bytes();
                      break;
                  case 2:
                      message.postStateHash = reader.bytes();
                      break;
                  case 3:
                      if (!(message.bonds && message.bonds.length))
                          message.bonds = [];
                      message.bonds.push($root.casper.BondProto.decode(reader, reader.uint32()));
                      break;
                  case 4:
                      message.blockNumber = reader.int64();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a RChainStateProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.RChainStateProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.RChainStateProto} RChainStateProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          RChainStateProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a RChainStateProto message.
           * @function verify
           * @memberof casper.RChainStateProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          RChainStateProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                  if (!(message.preStateHash && typeof message.preStateHash.length === "number" || $util.isString(message.preStateHash)))
                      return "preStateHash: buffer expected";
              if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                  if (!(message.postStateHash && typeof message.postStateHash.length === "number" || $util.isString(message.postStateHash)))
                      return "postStateHash: buffer expected";
              if (message.bonds != null && message.hasOwnProperty("bonds")) {
                  if (!Array.isArray(message.bonds))
                      return "bonds: array expected";
                  for (var i = 0; i < message.bonds.length; ++i) {
                      var error = $root.casper.BondProto.verify(message.bonds[i]);
                      if (error)
                          return "bonds." + error;
                  }
              }
              if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                  if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                      return "blockNumber: integer|Long expected";
              return null;
          };

          /**
           * Creates a RChainStateProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.RChainStateProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.RChainStateProto} RChainStateProto
           */
          RChainStateProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.RChainStateProto)
                  return object;
              var message = new $root.casper.RChainStateProto();
              if (object.preStateHash != null)
                  if (typeof object.preStateHash === "string")
                      $util.base64.decode(object.preStateHash, message.preStateHash = $util.newBuffer($util.base64.length(object.preStateHash)), 0);
                  else if (object.preStateHash.length)
                      message.preStateHash = object.preStateHash;
              if (object.postStateHash != null)
                  if (typeof object.postStateHash === "string")
                      $util.base64.decode(object.postStateHash, message.postStateHash = $util.newBuffer($util.base64.length(object.postStateHash)), 0);
                  else if (object.postStateHash.length)
                      message.postStateHash = object.postStateHash;
              if (object.bonds) {
                  if (!Array.isArray(object.bonds))
                      throw TypeError(".casper.RChainStateProto.bonds: array expected");
                  message.bonds = [];
                  for (var i = 0; i < object.bonds.length; ++i) {
                      if (typeof object.bonds[i] !== "object")
                          throw TypeError(".casper.RChainStateProto.bonds: object expected");
                      message.bonds[i] = $root.casper.BondProto.fromObject(object.bonds[i]);
                  }
              }
              if (object.blockNumber != null)
                  if ($util.Long)
                      (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                  else if (typeof object.blockNumber === "string")
                      message.blockNumber = parseInt(object.blockNumber, 10);
                  else if (typeof object.blockNumber === "number")
                      message.blockNumber = object.blockNumber;
                  else if (typeof object.blockNumber === "object")
                      message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
              return message;
          };

          /**
           * Creates a plain object from a RChainStateProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.RChainStateProto
           * @static
           * @param {casper.RChainStateProto} message RChainStateProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          RChainStateProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.bonds = [];
              if (options.defaults) {
                  if (options.bytes === String)
                      object.preStateHash = "";
                  else {
                      object.preStateHash = [];
                      if (options.bytes !== Array)
                          object.preStateHash = $util.newBuffer(object.preStateHash);
                  }
                  if (options.bytes === String)
                      object.postStateHash = "";
                  else {
                      object.postStateHash = [];
                      if (options.bytes !== Array)
                          object.postStateHash = $util.newBuffer(object.postStateHash);
                  }
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.blockNumber = options.longs === String ? "0" : 0;
              }
              if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                  object.preStateHash = options.bytes === String ? $util.base64.encode(message.preStateHash, 0, message.preStateHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.preStateHash) : message.preStateHash;
              if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                  object.postStateHash = options.bytes === String ? $util.base64.encode(message.postStateHash, 0, message.postStateHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.postStateHash) : message.postStateHash;
              if (message.bonds && message.bonds.length) {
                  object.bonds = [];
                  for (var j = 0; j < message.bonds.length; ++j)
                      object.bonds[j] = $root.casper.BondProto.toObject(message.bonds[j], options);
              }
              if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                  if (typeof message.blockNumber === "number")
                      object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                  else
                      object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
              return object;
          };

          /**
           * Converts this RChainStateProto to JSON.
           * @function toJSON
           * @memberof casper.RChainStateProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          RChainStateProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return RChainStateProto;
      })();

      casper.EventProto = (function() {

          /**
           * Properties of an EventProto.
           * @memberof casper
           * @interface IEventProto
           * @property {casper.IProduceEventProto|null} [produce] EventProto produce
           * @property {casper.IConsumeEventProto|null} [consume] EventProto consume
           * @property {casper.ICommEventProto|null} [comm] EventProto comm
           */

          /**
           * Constructs a new EventProto.
           * @memberof casper
           * @classdesc Represents an EventProto.
           * @implements IEventProto
           * @constructor
           * @param {casper.IEventProto=} [properties] Properties to set
           */
          function EventProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * EventProto produce.
           * @member {casper.IProduceEventProto|null|undefined} produce
           * @memberof casper.EventProto
           * @instance
           */
          EventProto.prototype.produce = null;

          /**
           * EventProto consume.
           * @member {casper.IConsumeEventProto|null|undefined} consume
           * @memberof casper.EventProto
           * @instance
           */
          EventProto.prototype.consume = null;

          /**
           * EventProto comm.
           * @member {casper.ICommEventProto|null|undefined} comm
           * @memberof casper.EventProto
           * @instance
           */
          EventProto.prototype.comm = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * EventProto event_instance.
           * @member {"produce"|"consume"|"comm"|undefined} event_instance
           * @memberof casper.EventProto
           * @instance
           */
          Object.defineProperty(EventProto.prototype, "event_instance", {
              get: $util.oneOfGetter($oneOfFields = ["produce", "consume", "comm"]),
              set: $util.oneOfSetter($oneOfFields)
          });

          /**
           * Creates a new EventProto instance using the specified properties.
           * @function create
           * @memberof casper.EventProto
           * @static
           * @param {casper.IEventProto=} [properties] Properties to set
           * @returns {casper.EventProto} EventProto instance
           */
          EventProto.create = function create(properties) {
              return new EventProto(properties);
          };

          /**
           * Encodes the specified EventProto message. Does not implicitly {@link casper.EventProto.verify|verify} messages.
           * @function encode
           * @memberof casper.EventProto
           * @static
           * @param {casper.IEventProto} message EventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          EventProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.produce != null && message.hasOwnProperty("produce"))
                  $root.casper.ProduceEventProto.encode(message.produce, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.consume != null && message.hasOwnProperty("consume"))
                  $root.casper.ConsumeEventProto.encode(message.consume, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.comm != null && message.hasOwnProperty("comm"))
                  $root.casper.CommEventProto.encode(message.comm, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified EventProto message, length delimited. Does not implicitly {@link casper.EventProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.EventProto
           * @static
           * @param {casper.IEventProto} message EventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          EventProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an EventProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.EventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.EventProto} EventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          EventProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.EventProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.produce = $root.casper.ProduceEventProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.consume = $root.casper.ConsumeEventProto.decode(reader, reader.uint32());
                      break;
                  case 3:
                      message.comm = $root.casper.CommEventProto.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an EventProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.EventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.EventProto} EventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          EventProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an EventProto message.
           * @function verify
           * @memberof casper.EventProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          EventProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              var properties = {};
              if (message.produce != null && message.hasOwnProperty("produce")) {
                  properties.event_instance = 1;
                  {
                      var error = $root.casper.ProduceEventProto.verify(message.produce);
                      if (error)
                          return "produce." + error;
                  }
              }
              if (message.consume != null && message.hasOwnProperty("consume")) {
                  if (properties.event_instance === 1)
                      return "event_instance: multiple values";
                  properties.event_instance = 1;
                  {
                      var error = $root.casper.ConsumeEventProto.verify(message.consume);
                      if (error)
                          return "consume." + error;
                  }
              }
              if (message.comm != null && message.hasOwnProperty("comm")) {
                  if (properties.event_instance === 1)
                      return "event_instance: multiple values";
                  properties.event_instance = 1;
                  {
                      var error = $root.casper.CommEventProto.verify(message.comm);
                      if (error)
                          return "comm." + error;
                  }
              }
              return null;
          };

          /**
           * Creates an EventProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.EventProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.EventProto} EventProto
           */
          EventProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.EventProto)
                  return object;
              var message = new $root.casper.EventProto();
              if (object.produce != null) {
                  if (typeof object.produce !== "object")
                      throw TypeError(".casper.EventProto.produce: object expected");
                  message.produce = $root.casper.ProduceEventProto.fromObject(object.produce);
              }
              if (object.consume != null) {
                  if (typeof object.consume !== "object")
                      throw TypeError(".casper.EventProto.consume: object expected");
                  message.consume = $root.casper.ConsumeEventProto.fromObject(object.consume);
              }
              if (object.comm != null) {
                  if (typeof object.comm !== "object")
                      throw TypeError(".casper.EventProto.comm: object expected");
                  message.comm = $root.casper.CommEventProto.fromObject(object.comm);
              }
              return message;
          };

          /**
           * Creates a plain object from an EventProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.EventProto
           * @static
           * @param {casper.EventProto} message EventProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          EventProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (message.produce != null && message.hasOwnProperty("produce")) {
                  object.produce = $root.casper.ProduceEventProto.toObject(message.produce, options);
                  if (options.oneofs)
                      object.event_instance = "produce";
              }
              if (message.consume != null && message.hasOwnProperty("consume")) {
                  object.consume = $root.casper.ConsumeEventProto.toObject(message.consume, options);
                  if (options.oneofs)
                      object.event_instance = "consume";
              }
              if (message.comm != null && message.hasOwnProperty("comm")) {
                  object.comm = $root.casper.CommEventProto.toObject(message.comm, options);
                  if (options.oneofs)
                      object.event_instance = "comm";
              }
              return object;
          };

          /**
           * Converts this EventProto to JSON.
           * @function toJSON
           * @memberof casper.EventProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          EventProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return EventProto;
      })();

      casper.ProduceEventProto = (function() {

          /**
           * Properties of a ProduceEventProto.
           * @memberof casper
           * @interface IProduceEventProto
           * @property {Uint8Array|null} [channelsHash] ProduceEventProto channelsHash
           * @property {Uint8Array|null} [hash] ProduceEventProto hash
           * @property {boolean|null} [persistent] ProduceEventProto persistent
           * @property {number|null} [timesRepeated] ProduceEventProto timesRepeated
           */

          /**
           * Constructs a new ProduceEventProto.
           * @memberof casper
           * @classdesc Represents a ProduceEventProto.
           * @implements IProduceEventProto
           * @constructor
           * @param {casper.IProduceEventProto=} [properties] Properties to set
           */
          function ProduceEventProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ProduceEventProto channelsHash.
           * @member {Uint8Array} channelsHash
           * @memberof casper.ProduceEventProto
           * @instance
           */
          ProduceEventProto.prototype.channelsHash = $util.newBuffer([]);

          /**
           * ProduceEventProto hash.
           * @member {Uint8Array} hash
           * @memberof casper.ProduceEventProto
           * @instance
           */
          ProduceEventProto.prototype.hash = $util.newBuffer([]);

          /**
           * ProduceEventProto persistent.
           * @member {boolean} persistent
           * @memberof casper.ProduceEventProto
           * @instance
           */
          ProduceEventProto.prototype.persistent = false;

          /**
           * ProduceEventProto timesRepeated.
           * @member {number} timesRepeated
           * @memberof casper.ProduceEventProto
           * @instance
           */
          ProduceEventProto.prototype.timesRepeated = 0;

          /**
           * Creates a new ProduceEventProto instance using the specified properties.
           * @function create
           * @memberof casper.ProduceEventProto
           * @static
           * @param {casper.IProduceEventProto=} [properties] Properties to set
           * @returns {casper.ProduceEventProto} ProduceEventProto instance
           */
          ProduceEventProto.create = function create(properties) {
              return new ProduceEventProto(properties);
          };

          /**
           * Encodes the specified ProduceEventProto message. Does not implicitly {@link casper.ProduceEventProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ProduceEventProto
           * @static
           * @param {casper.IProduceEventProto} message ProduceEventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProduceEventProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.channelsHash != null && message.hasOwnProperty("channelsHash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelsHash);
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
              if (message.persistent != null && message.hasOwnProperty("persistent"))
                  writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
              if (message.timesRepeated != null && message.hasOwnProperty("timesRepeated"))
                  writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timesRepeated);
              return writer;
          };

          /**
           * Encodes the specified ProduceEventProto message, length delimited. Does not implicitly {@link casper.ProduceEventProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ProduceEventProto
           * @static
           * @param {casper.IProduceEventProto} message ProduceEventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProduceEventProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ProduceEventProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ProduceEventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ProduceEventProto} ProduceEventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProduceEventProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ProduceEventProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.channelsHash = reader.bytes();
                      break;
                  case 2:
                      message.hash = reader.bytes();
                      break;
                  case 3:
                      message.persistent = reader.bool();
                      break;
                  case 4:
                      message.timesRepeated = reader.int32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ProduceEventProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ProduceEventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ProduceEventProto} ProduceEventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProduceEventProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ProduceEventProto message.
           * @function verify
           * @memberof casper.ProduceEventProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ProduceEventProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.channelsHash != null && message.hasOwnProperty("channelsHash"))
                  if (!(message.channelsHash && typeof message.channelsHash.length === "number" || $util.isString(message.channelsHash)))
                      return "channelsHash: buffer expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                      return "hash: buffer expected";
              if (message.persistent != null && message.hasOwnProperty("persistent"))
                  if (typeof message.persistent !== "boolean")
                      return "persistent: boolean expected";
              if (message.timesRepeated != null && message.hasOwnProperty("timesRepeated"))
                  if (!$util.isInteger(message.timesRepeated))
                      return "timesRepeated: integer expected";
              return null;
          };

          /**
           * Creates a ProduceEventProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ProduceEventProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ProduceEventProto} ProduceEventProto
           */
          ProduceEventProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ProduceEventProto)
                  return object;
              var message = new $root.casper.ProduceEventProto();
              if (object.channelsHash != null)
                  if (typeof object.channelsHash === "string")
                      $util.base64.decode(object.channelsHash, message.channelsHash = $util.newBuffer($util.base64.length(object.channelsHash)), 0);
                  else if (object.channelsHash.length)
                      message.channelsHash = object.channelsHash;
              if (object.hash != null)
                  if (typeof object.hash === "string")
                      $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                  else if (object.hash.length)
                      message.hash = object.hash;
              if (object.persistent != null)
                  message.persistent = Boolean(object.persistent);
              if (object.timesRepeated != null)
                  message.timesRepeated = object.timesRepeated | 0;
              return message;
          };

          /**
           * Creates a plain object from a ProduceEventProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ProduceEventProto
           * @static
           * @param {casper.ProduceEventProto} message ProduceEventProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ProduceEventProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.channelsHash = "";
                  else {
                      object.channelsHash = [];
                      if (options.bytes !== Array)
                          object.channelsHash = $util.newBuffer(object.channelsHash);
                  }
                  if (options.bytes === String)
                      object.hash = "";
                  else {
                      object.hash = [];
                      if (options.bytes !== Array)
                          object.hash = $util.newBuffer(object.hash);
                  }
                  object.persistent = false;
                  object.timesRepeated = 0;
              }
              if (message.channelsHash != null && message.hasOwnProperty("channelsHash"))
                  object.channelsHash = options.bytes === String ? $util.base64.encode(message.channelsHash, 0, message.channelsHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelsHash) : message.channelsHash;
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
              if (message.persistent != null && message.hasOwnProperty("persistent"))
                  object.persistent = message.persistent;
              if (message.timesRepeated != null && message.hasOwnProperty("timesRepeated"))
                  object.timesRepeated = message.timesRepeated;
              return object;
          };

          /**
           * Converts this ProduceEventProto to JSON.
           * @function toJSON
           * @memberof casper.ProduceEventProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ProduceEventProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ProduceEventProto;
      })();

      casper.ConsumeEventProto = (function() {

          /**
           * Properties of a ConsumeEventProto.
           * @memberof casper
           * @interface IConsumeEventProto
           * @property {Array.<Uint8Array>|null} [channelsHashes] ConsumeEventProto channelsHashes
           * @property {Uint8Array|null} [hash] ConsumeEventProto hash
           * @property {boolean|null} [persistent] ConsumeEventProto persistent
           */

          /**
           * Constructs a new ConsumeEventProto.
           * @memberof casper
           * @classdesc Represents a ConsumeEventProto.
           * @implements IConsumeEventProto
           * @constructor
           * @param {casper.IConsumeEventProto=} [properties] Properties to set
           */
          function ConsumeEventProto(properties) {
              this.channelsHashes = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ConsumeEventProto channelsHashes.
           * @member {Array.<Uint8Array>} channelsHashes
           * @memberof casper.ConsumeEventProto
           * @instance
           */
          ConsumeEventProto.prototype.channelsHashes = $util.emptyArray;

          /**
           * ConsumeEventProto hash.
           * @member {Uint8Array} hash
           * @memberof casper.ConsumeEventProto
           * @instance
           */
          ConsumeEventProto.prototype.hash = $util.newBuffer([]);

          /**
           * ConsumeEventProto persistent.
           * @member {boolean} persistent
           * @memberof casper.ConsumeEventProto
           * @instance
           */
          ConsumeEventProto.prototype.persistent = false;

          /**
           * Creates a new ConsumeEventProto instance using the specified properties.
           * @function create
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {casper.IConsumeEventProto=} [properties] Properties to set
           * @returns {casper.ConsumeEventProto} ConsumeEventProto instance
           */
          ConsumeEventProto.create = function create(properties) {
              return new ConsumeEventProto(properties);
          };

          /**
           * Encodes the specified ConsumeEventProto message. Does not implicitly {@link casper.ConsumeEventProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {casper.IConsumeEventProto} message ConsumeEventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ConsumeEventProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.channelsHashes != null && message.channelsHashes.length)
                  for (var i = 0; i < message.channelsHashes.length; ++i)
                      writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelsHashes[i]);
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
              if (message.persistent != null && message.hasOwnProperty("persistent"))
                  writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
              return writer;
          };

          /**
           * Encodes the specified ConsumeEventProto message, length delimited. Does not implicitly {@link casper.ConsumeEventProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {casper.IConsumeEventProto} message ConsumeEventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ConsumeEventProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ConsumeEventProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ConsumeEventProto} ConsumeEventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ConsumeEventProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ConsumeEventProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.channelsHashes && message.channelsHashes.length))
                          message.channelsHashes = [];
                      message.channelsHashes.push(reader.bytes());
                      break;
                  case 2:
                      message.hash = reader.bytes();
                      break;
                  case 3:
                      message.persistent = reader.bool();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ConsumeEventProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ConsumeEventProto} ConsumeEventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ConsumeEventProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ConsumeEventProto message.
           * @function verify
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ConsumeEventProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.channelsHashes != null && message.hasOwnProperty("channelsHashes")) {
                  if (!Array.isArray(message.channelsHashes))
                      return "channelsHashes: array expected";
                  for (var i = 0; i < message.channelsHashes.length; ++i)
                      if (!(message.channelsHashes[i] && typeof message.channelsHashes[i].length === "number" || $util.isString(message.channelsHashes[i])))
                          return "channelsHashes: buffer[] expected";
              }
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                      return "hash: buffer expected";
              if (message.persistent != null && message.hasOwnProperty("persistent"))
                  if (typeof message.persistent !== "boolean")
                      return "persistent: boolean expected";
              return null;
          };

          /**
           * Creates a ConsumeEventProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ConsumeEventProto} ConsumeEventProto
           */
          ConsumeEventProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ConsumeEventProto)
                  return object;
              var message = new $root.casper.ConsumeEventProto();
              if (object.channelsHashes) {
                  if (!Array.isArray(object.channelsHashes))
                      throw TypeError(".casper.ConsumeEventProto.channelsHashes: array expected");
                  message.channelsHashes = [];
                  for (var i = 0; i < object.channelsHashes.length; ++i)
                      if (typeof object.channelsHashes[i] === "string")
                          $util.base64.decode(object.channelsHashes[i], message.channelsHashes[i] = $util.newBuffer($util.base64.length(object.channelsHashes[i])), 0);
                      else if (object.channelsHashes[i].length)
                          message.channelsHashes[i] = object.channelsHashes[i];
              }
              if (object.hash != null)
                  if (typeof object.hash === "string")
                      $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                  else if (object.hash.length)
                      message.hash = object.hash;
              if (object.persistent != null)
                  message.persistent = Boolean(object.persistent);
              return message;
          };

          /**
           * Creates a plain object from a ConsumeEventProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ConsumeEventProto
           * @static
           * @param {casper.ConsumeEventProto} message ConsumeEventProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ConsumeEventProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.channelsHashes = [];
              if (options.defaults) {
                  if (options.bytes === String)
                      object.hash = "";
                  else {
                      object.hash = [];
                      if (options.bytes !== Array)
                          object.hash = $util.newBuffer(object.hash);
                  }
                  object.persistent = false;
              }
              if (message.channelsHashes && message.channelsHashes.length) {
                  object.channelsHashes = [];
                  for (var j = 0; j < message.channelsHashes.length; ++j)
                      object.channelsHashes[j] = options.bytes === String ? $util.base64.encode(message.channelsHashes[j], 0, message.channelsHashes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.channelsHashes[j]) : message.channelsHashes[j];
              }
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
              if (message.persistent != null && message.hasOwnProperty("persistent"))
                  object.persistent = message.persistent;
              return object;
          };

          /**
           * Converts this ConsumeEventProto to JSON.
           * @function toJSON
           * @memberof casper.ConsumeEventProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ConsumeEventProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ConsumeEventProto;
      })();

      casper.CommEventProto = (function() {

          /**
           * Properties of a CommEventProto.
           * @memberof casper
           * @interface ICommEventProto
           * @property {casper.IConsumeEventProto|null} [consume] CommEventProto consume
           * @property {Array.<casper.IProduceEventProto>|null} [produces] CommEventProto produces
           * @property {Array.<casper.IPeekProto>|null} [peeks] CommEventProto peeks
           */

          /**
           * Constructs a new CommEventProto.
           * @memberof casper
           * @classdesc Represents a CommEventProto.
           * @implements ICommEventProto
           * @constructor
           * @param {casper.ICommEventProto=} [properties] Properties to set
           */
          function CommEventProto(properties) {
              this.produces = [];
              this.peeks = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * CommEventProto consume.
           * @member {casper.IConsumeEventProto|null|undefined} consume
           * @memberof casper.CommEventProto
           * @instance
           */
          CommEventProto.prototype.consume = null;

          /**
           * CommEventProto produces.
           * @member {Array.<casper.IProduceEventProto>} produces
           * @memberof casper.CommEventProto
           * @instance
           */
          CommEventProto.prototype.produces = $util.emptyArray;

          /**
           * CommEventProto peeks.
           * @member {Array.<casper.IPeekProto>} peeks
           * @memberof casper.CommEventProto
           * @instance
           */
          CommEventProto.prototype.peeks = $util.emptyArray;

          /**
           * Creates a new CommEventProto instance using the specified properties.
           * @function create
           * @memberof casper.CommEventProto
           * @static
           * @param {casper.ICommEventProto=} [properties] Properties to set
           * @returns {casper.CommEventProto} CommEventProto instance
           */
          CommEventProto.create = function create(properties) {
              return new CommEventProto(properties);
          };

          /**
           * Encodes the specified CommEventProto message. Does not implicitly {@link casper.CommEventProto.verify|verify} messages.
           * @function encode
           * @memberof casper.CommEventProto
           * @static
           * @param {casper.ICommEventProto} message CommEventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CommEventProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.consume != null && message.hasOwnProperty("consume"))
                  $root.casper.ConsumeEventProto.encode(message.consume, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.produces != null && message.produces.length)
                  for (var i = 0; i < message.produces.length; ++i)
                      $root.casper.ProduceEventProto.encode(message.produces[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.peeks != null && message.peeks.length)
                  for (var i = 0; i < message.peeks.length; ++i)
                      $root.casper.PeekProto.encode(message.peeks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified CommEventProto message, length delimited. Does not implicitly {@link casper.CommEventProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.CommEventProto
           * @static
           * @param {casper.ICommEventProto} message CommEventProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CommEventProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a CommEventProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.CommEventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.CommEventProto} CommEventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CommEventProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.CommEventProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.consume = $root.casper.ConsumeEventProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.produces && message.produces.length))
                          message.produces = [];
                      message.produces.push($root.casper.ProduceEventProto.decode(reader, reader.uint32()));
                      break;
                  case 3:
                      if (!(message.peeks && message.peeks.length))
                          message.peeks = [];
                      message.peeks.push($root.casper.PeekProto.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a CommEventProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.CommEventProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.CommEventProto} CommEventProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CommEventProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a CommEventProto message.
           * @function verify
           * @memberof casper.CommEventProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          CommEventProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.consume != null && message.hasOwnProperty("consume")) {
                  var error = $root.casper.ConsumeEventProto.verify(message.consume);
                  if (error)
                      return "consume." + error;
              }
              if (message.produces != null && message.hasOwnProperty("produces")) {
                  if (!Array.isArray(message.produces))
                      return "produces: array expected";
                  for (var i = 0; i < message.produces.length; ++i) {
                      var error = $root.casper.ProduceEventProto.verify(message.produces[i]);
                      if (error)
                          return "produces." + error;
                  }
              }
              if (message.peeks != null && message.hasOwnProperty("peeks")) {
                  if (!Array.isArray(message.peeks))
                      return "peeks: array expected";
                  for (var i = 0; i < message.peeks.length; ++i) {
                      var error = $root.casper.PeekProto.verify(message.peeks[i]);
                      if (error)
                          return "peeks." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a CommEventProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.CommEventProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.CommEventProto} CommEventProto
           */
          CommEventProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.CommEventProto)
                  return object;
              var message = new $root.casper.CommEventProto();
              if (object.consume != null) {
                  if (typeof object.consume !== "object")
                      throw TypeError(".casper.CommEventProto.consume: object expected");
                  message.consume = $root.casper.ConsumeEventProto.fromObject(object.consume);
              }
              if (object.produces) {
                  if (!Array.isArray(object.produces))
                      throw TypeError(".casper.CommEventProto.produces: array expected");
                  message.produces = [];
                  for (var i = 0; i < object.produces.length; ++i) {
                      if (typeof object.produces[i] !== "object")
                          throw TypeError(".casper.CommEventProto.produces: object expected");
                      message.produces[i] = $root.casper.ProduceEventProto.fromObject(object.produces[i]);
                  }
              }
              if (object.peeks) {
                  if (!Array.isArray(object.peeks))
                      throw TypeError(".casper.CommEventProto.peeks: array expected");
                  message.peeks = [];
                  for (var i = 0; i < object.peeks.length; ++i) {
                      if (typeof object.peeks[i] !== "object")
                          throw TypeError(".casper.CommEventProto.peeks: object expected");
                      message.peeks[i] = $root.casper.PeekProto.fromObject(object.peeks[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a CommEventProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.CommEventProto
           * @static
           * @param {casper.CommEventProto} message CommEventProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          CommEventProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object.produces = [];
                  object.peeks = [];
              }
              if (options.defaults)
                  object.consume = null;
              if (message.consume != null && message.hasOwnProperty("consume"))
                  object.consume = $root.casper.ConsumeEventProto.toObject(message.consume, options);
              if (message.produces && message.produces.length) {
                  object.produces = [];
                  for (var j = 0; j < message.produces.length; ++j)
                      object.produces[j] = $root.casper.ProduceEventProto.toObject(message.produces[j], options);
              }
              if (message.peeks && message.peeks.length) {
                  object.peeks = [];
                  for (var j = 0; j < message.peeks.length; ++j)
                      object.peeks[j] = $root.casper.PeekProto.toObject(message.peeks[j], options);
              }
              return object;
          };

          /**
           * Converts this CommEventProto to JSON.
           * @function toJSON
           * @memberof casper.CommEventProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          CommEventProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return CommEventProto;
      })();

      casper.PeekProto = (function() {

          /**
           * Properties of a PeekProto.
           * @memberof casper
           * @interface IPeekProto
           * @property {number|null} [channelIndex] PeekProto channelIndex
           */

          /**
           * Constructs a new PeekProto.
           * @memberof casper
           * @classdesc Represents a PeekProto.
           * @implements IPeekProto
           * @constructor
           * @param {casper.IPeekProto=} [properties] Properties to set
           */
          function PeekProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * PeekProto channelIndex.
           * @member {number} channelIndex
           * @memberof casper.PeekProto
           * @instance
           */
          PeekProto.prototype.channelIndex = 0;

          /**
           * Creates a new PeekProto instance using the specified properties.
           * @function create
           * @memberof casper.PeekProto
           * @static
           * @param {casper.IPeekProto=} [properties] Properties to set
           * @returns {casper.PeekProto} PeekProto instance
           */
          PeekProto.create = function create(properties) {
              return new PeekProto(properties);
          };

          /**
           * Encodes the specified PeekProto message. Does not implicitly {@link casper.PeekProto.verify|verify} messages.
           * @function encode
           * @memberof casper.PeekProto
           * @static
           * @param {casper.IPeekProto} message PeekProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PeekProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                  writer.uint32(/* id 1, wireType 0 =*/8).int32(message.channelIndex);
              return writer;
          };

          /**
           * Encodes the specified PeekProto message, length delimited. Does not implicitly {@link casper.PeekProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.PeekProto
           * @static
           * @param {casper.IPeekProto} message PeekProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PeekProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PeekProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.PeekProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.PeekProto} PeekProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PeekProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.PeekProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.channelIndex = reader.int32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a PeekProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.PeekProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.PeekProto} PeekProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PeekProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PeekProto message.
           * @function verify
           * @memberof casper.PeekProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PeekProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                  if (!$util.isInteger(message.channelIndex))
                      return "channelIndex: integer expected";
              return null;
          };

          /**
           * Creates a PeekProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.PeekProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.PeekProto} PeekProto
           */
          PeekProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.PeekProto)
                  return object;
              var message = new $root.casper.PeekProto();
              if (object.channelIndex != null)
                  message.channelIndex = object.channelIndex | 0;
              return message;
          };

          /**
           * Creates a plain object from a PeekProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.PeekProto
           * @static
           * @param {casper.PeekProto} message PeekProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PeekProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.channelIndex = 0;
              if (message.channelIndex != null && message.hasOwnProperty("channelIndex"))
                  object.channelIndex = message.channelIndex;
              return object;
          };

          /**
           * Converts this PeekProto to JSON.
           * @function toJSON
           * @memberof casper.PeekProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PeekProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return PeekProto;
      })();

      casper.BondProto = (function() {

          /**
           * Properties of a BondProto.
           * @memberof casper
           * @interface IBondProto
           * @property {Uint8Array|null} [validator] BondProto validator
           * @property {number|Long|null} [stake] BondProto stake
           */

          /**
           * Constructs a new BondProto.
           * @memberof casper
           * @classdesc Represents a BondProto.
           * @implements IBondProto
           * @constructor
           * @param {casper.IBondProto=} [properties] Properties to set
           */
          function BondProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BondProto validator.
           * @member {Uint8Array} validator
           * @memberof casper.BondProto
           * @instance
           */
          BondProto.prototype.validator = $util.newBuffer([]);

          /**
           * BondProto stake.
           * @member {number|Long} stake
           * @memberof casper.BondProto
           * @instance
           */
          BondProto.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Creates a new BondProto instance using the specified properties.
           * @function create
           * @memberof casper.BondProto
           * @static
           * @param {casper.IBondProto=} [properties] Properties to set
           * @returns {casper.BondProto} BondProto instance
           */
          BondProto.create = function create(properties) {
              return new BondProto(properties);
          };

          /**
           * Encodes the specified BondProto message. Does not implicitly {@link casper.BondProto.verify|verify} messages.
           * @function encode
           * @memberof casper.BondProto
           * @static
           * @param {casper.IBondProto} message BondProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BondProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.validator != null && message.hasOwnProperty("validator"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.validator);
              if (message.stake != null && message.hasOwnProperty("stake"))
                  writer.uint32(/* id 2, wireType 0 =*/16).int64(message.stake);
              return writer;
          };

          /**
           * Encodes the specified BondProto message, length delimited. Does not implicitly {@link casper.BondProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BondProto
           * @static
           * @param {casper.IBondProto} message BondProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BondProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BondProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BondProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BondProto} BondProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BondProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BondProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.validator = reader.bytes();
                      break;
                  case 2:
                      message.stake = reader.int64();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BondProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BondProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BondProto} BondProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BondProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BondProto message.
           * @function verify
           * @memberof casper.BondProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BondProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.validator != null && message.hasOwnProperty("validator"))
                  if (!(message.validator && typeof message.validator.length === "number" || $util.isString(message.validator)))
                      return "validator: buffer expected";
              if (message.stake != null && message.hasOwnProperty("stake"))
                  if (!$util.isInteger(message.stake) && !(message.stake && $util.isInteger(message.stake.low) && $util.isInteger(message.stake.high)))
                      return "stake: integer|Long expected";
              return null;
          };

          /**
           * Creates a BondProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BondProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BondProto} BondProto
           */
          BondProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BondProto)
                  return object;
              var message = new $root.casper.BondProto();
              if (object.validator != null)
                  if (typeof object.validator === "string")
                      $util.base64.decode(object.validator, message.validator = $util.newBuffer($util.base64.length(object.validator)), 0);
                  else if (object.validator.length)
                      message.validator = object.validator;
              if (object.stake != null)
                  if ($util.Long)
                      (message.stake = $util.Long.fromValue(object.stake)).unsigned = false;
                  else if (typeof object.stake === "string")
                      message.stake = parseInt(object.stake, 10);
                  else if (typeof object.stake === "number")
                      message.stake = object.stake;
                  else if (typeof object.stake === "object")
                      message.stake = new $util.LongBits(object.stake.low >>> 0, object.stake.high >>> 0).toNumber();
              return message;
          };

          /**
           * Creates a plain object from a BondProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BondProto
           * @static
           * @param {casper.BondProto} message BondProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BondProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.validator = "";
                  else {
                      object.validator = [];
                      if (options.bytes !== Array)
                          object.validator = $util.newBuffer(object.validator);
                  }
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.stake = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.stake = options.longs === String ? "0" : 0;
              }
              if (message.validator != null && message.hasOwnProperty("validator"))
                  object.validator = options.bytes === String ? $util.base64.encode(message.validator, 0, message.validator.length) : options.bytes === Array ? Array.prototype.slice.call(message.validator) : message.validator;
              if (message.stake != null && message.hasOwnProperty("stake"))
                  if (typeof message.stake === "number")
                      object.stake = options.longs === String ? String(message.stake) : message.stake;
                  else
                      object.stake = options.longs === String ? $util.Long.prototype.toString.call(message.stake) : options.longs === Number ? new $util.LongBits(message.stake.low >>> 0, message.stake.high >>> 0).toNumber() : message.stake;
              return object;
          };

          /**
           * Converts this BondProto to JSON.
           * @function toJSON
           * @memberof casper.BondProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BondProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BondProto;
      })();

      casper.FindDeployQuery = (function() {

          /**
           * Properties of a FindDeployQuery.
           * @memberof casper
           * @interface IFindDeployQuery
           * @property {Uint8Array|null} [deployId] FindDeployQuery deployId
           */

          /**
           * Constructs a new FindDeployQuery.
           * @memberof casper
           * @classdesc Represents a FindDeployQuery.
           * @implements IFindDeployQuery
           * @constructor
           * @param {casper.IFindDeployQuery=} [properties] Properties to set
           */
          function FindDeployQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * FindDeployQuery deployId.
           * @member {Uint8Array} deployId
           * @memberof casper.FindDeployQuery
           * @instance
           */
          FindDeployQuery.prototype.deployId = $util.newBuffer([]);

          /**
           * Creates a new FindDeployQuery instance using the specified properties.
           * @function create
           * @memberof casper.FindDeployQuery
           * @static
           * @param {casper.IFindDeployQuery=} [properties] Properties to set
           * @returns {casper.FindDeployQuery} FindDeployQuery instance
           */
          FindDeployQuery.create = function create(properties) {
              return new FindDeployQuery(properties);
          };

          /**
           * Encodes the specified FindDeployQuery message. Does not implicitly {@link casper.FindDeployQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.FindDeployQuery
           * @static
           * @param {casper.IFindDeployQuery} message FindDeployQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          FindDeployQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.deployId != null && message.hasOwnProperty("deployId"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deployId);
              return writer;
          };

          /**
           * Encodes the specified FindDeployQuery message, length delimited. Does not implicitly {@link casper.FindDeployQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.FindDeployQuery
           * @static
           * @param {casper.IFindDeployQuery} message FindDeployQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          FindDeployQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a FindDeployQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.FindDeployQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.FindDeployQuery} FindDeployQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          FindDeployQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.FindDeployQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.deployId = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a FindDeployQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.FindDeployQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.FindDeployQuery} FindDeployQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          FindDeployQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a FindDeployQuery message.
           * @function verify
           * @memberof casper.FindDeployQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          FindDeployQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.deployId != null && message.hasOwnProperty("deployId"))
                  if (!(message.deployId && typeof message.deployId.length === "number" || $util.isString(message.deployId)))
                      return "deployId: buffer expected";
              return null;
          };

          /**
           * Creates a FindDeployQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.FindDeployQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.FindDeployQuery} FindDeployQuery
           */
          FindDeployQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.FindDeployQuery)
                  return object;
              var message = new $root.casper.FindDeployQuery();
              if (object.deployId != null)
                  if (typeof object.deployId === "string")
                      $util.base64.decode(object.deployId, message.deployId = $util.newBuffer($util.base64.length(object.deployId)), 0);
                  else if (object.deployId.length)
                      message.deployId = object.deployId;
              return message;
          };

          /**
           * Creates a plain object from a FindDeployQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.FindDeployQuery
           * @static
           * @param {casper.FindDeployQuery} message FindDeployQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          FindDeployQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.deployId = "";
                  else {
                      object.deployId = [];
                      if (options.bytes !== Array)
                          object.deployId = $util.newBuffer(object.deployId);
                  }
              if (message.deployId != null && message.hasOwnProperty("deployId"))
                  object.deployId = options.bytes === String ? $util.base64.encode(message.deployId, 0, message.deployId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deployId) : message.deployId;
              return object;
          };

          /**
           * Converts this FindDeployQuery to JSON.
           * @function toJSON
           * @memberof casper.FindDeployQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          FindDeployQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return FindDeployQuery;
      })();

      casper.BlockQuery = (function() {

          /**
           * Properties of a BlockQuery.
           * @memberof casper
           * @interface IBlockQuery
           * @property {string|null} [hash] BlockQuery hash
           */

          /**
           * Constructs a new BlockQuery.
           * @memberof casper
           * @classdesc Represents a BlockQuery.
           * @implements IBlockQuery
           * @constructor
           * @param {casper.IBlockQuery=} [properties] Properties to set
           */
          function BlockQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockQuery hash.
           * @member {string} hash
           * @memberof casper.BlockQuery
           * @instance
           */
          BlockQuery.prototype.hash = "";

          /**
           * Creates a new BlockQuery instance using the specified properties.
           * @function create
           * @memberof casper.BlockQuery
           * @static
           * @param {casper.IBlockQuery=} [properties] Properties to set
           * @returns {casper.BlockQuery} BlockQuery instance
           */
          BlockQuery.create = function create(properties) {
              return new BlockQuery(properties);
          };

          /**
           * Encodes the specified BlockQuery message. Does not implicitly {@link casper.BlockQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockQuery
           * @static
           * @param {casper.IBlockQuery} message BlockQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
              return writer;
          };

          /**
           * Encodes the specified BlockQuery message, length delimited. Does not implicitly {@link casper.BlockQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockQuery
           * @static
           * @param {casper.IBlockQuery} message BlockQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockQuery} BlockQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.hash = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockQuery} BlockQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockQuery message.
           * @function verify
           * @memberof casper.BlockQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!$util.isString(message.hash))
                      return "hash: string expected";
              return null;
          };

          /**
           * Creates a BlockQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockQuery} BlockQuery
           */
          BlockQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockQuery)
                  return object;
              var message = new $root.casper.BlockQuery();
              if (object.hash != null)
                  message.hash = String(object.hash);
              return message;
          };

          /**
           * Creates a plain object from a BlockQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockQuery
           * @static
           * @param {casper.BlockQuery} message BlockQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.hash = "";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = message.hash;
              return object;
          };

          /**
           * Converts this BlockQuery to JSON.
           * @function toJSON
           * @memberof casper.BlockQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockQuery;
      })();

      casper.BlocksQuery = (function() {

          /**
           * Properties of a BlocksQuery.
           * @memberof casper
           * @interface IBlocksQuery
           * @property {number|null} [depth] BlocksQuery depth
           */

          /**
           * Constructs a new BlocksQuery.
           * @memberof casper
           * @classdesc Represents a BlocksQuery.
           * @implements IBlocksQuery
           * @constructor
           * @param {casper.IBlocksQuery=} [properties] Properties to set
           */
          function BlocksQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlocksQuery depth.
           * @member {number} depth
           * @memberof casper.BlocksQuery
           * @instance
           */
          BlocksQuery.prototype.depth = 0;

          /**
           * Creates a new BlocksQuery instance using the specified properties.
           * @function create
           * @memberof casper.BlocksQuery
           * @static
           * @param {casper.IBlocksQuery=} [properties] Properties to set
           * @returns {casper.BlocksQuery} BlocksQuery instance
           */
          BlocksQuery.create = function create(properties) {
              return new BlocksQuery(properties);
          };

          /**
           * Encodes the specified BlocksQuery message. Does not implicitly {@link casper.BlocksQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.BlocksQuery
           * @static
           * @param {casper.IBlocksQuery} message BlocksQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlocksQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.depth != null && message.hasOwnProperty("depth"))
                  writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
              return writer;
          };

          /**
           * Encodes the specified BlocksQuery message, length delimited. Does not implicitly {@link casper.BlocksQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlocksQuery
           * @static
           * @param {casper.IBlocksQuery} message BlocksQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlocksQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlocksQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlocksQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlocksQuery} BlocksQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlocksQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlocksQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.depth = reader.int32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlocksQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlocksQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlocksQuery} BlocksQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlocksQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlocksQuery message.
           * @function verify
           * @memberof casper.BlocksQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlocksQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.depth != null && message.hasOwnProperty("depth"))
                  if (!$util.isInteger(message.depth))
                      return "depth: integer expected";
              return null;
          };

          /**
           * Creates a BlocksQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlocksQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlocksQuery} BlocksQuery
           */
          BlocksQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlocksQuery)
                  return object;
              var message = new $root.casper.BlocksQuery();
              if (object.depth != null)
                  message.depth = object.depth | 0;
              return message;
          };

          /**
           * Creates a plain object from a BlocksQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlocksQuery
           * @static
           * @param {casper.BlocksQuery} message BlocksQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlocksQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.depth = 0;
              if (message.depth != null && message.hasOwnProperty("depth"))
                  object.depth = message.depth;
              return object;
          };

          /**
           * Converts this BlocksQuery to JSON.
           * @function toJSON
           * @memberof casper.BlocksQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlocksQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlocksQuery;
      })();

      casper.BlocksQueryByHeight = (function() {

          /**
           * Properties of a BlocksQueryByHeight.
           * @memberof casper
           * @interface IBlocksQueryByHeight
           * @property {number|Long|null} [startBlockNumber] BlocksQueryByHeight startBlockNumber
           * @property {number|Long|null} [endBlockNumber] BlocksQueryByHeight endBlockNumber
           */

          /**
           * Constructs a new BlocksQueryByHeight.
           * @memberof casper
           * @classdesc Represents a BlocksQueryByHeight.
           * @implements IBlocksQueryByHeight
           * @constructor
           * @param {casper.IBlocksQueryByHeight=} [properties] Properties to set
           */
          function BlocksQueryByHeight(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlocksQueryByHeight startBlockNumber.
           * @member {number|Long} startBlockNumber
           * @memberof casper.BlocksQueryByHeight
           * @instance
           */
          BlocksQueryByHeight.prototype.startBlockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * BlocksQueryByHeight endBlockNumber.
           * @member {number|Long} endBlockNumber
           * @memberof casper.BlocksQueryByHeight
           * @instance
           */
          BlocksQueryByHeight.prototype.endBlockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Creates a new BlocksQueryByHeight instance using the specified properties.
           * @function create
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {casper.IBlocksQueryByHeight=} [properties] Properties to set
           * @returns {casper.BlocksQueryByHeight} BlocksQueryByHeight instance
           */
          BlocksQueryByHeight.create = function create(properties) {
              return new BlocksQueryByHeight(properties);
          };

          /**
           * Encodes the specified BlocksQueryByHeight message. Does not implicitly {@link casper.BlocksQueryByHeight.verify|verify} messages.
           * @function encode
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {casper.IBlocksQueryByHeight} message BlocksQueryByHeight message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlocksQueryByHeight.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.startBlockNumber != null && message.hasOwnProperty("startBlockNumber"))
                  writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startBlockNumber);
              if (message.endBlockNumber != null && message.hasOwnProperty("endBlockNumber"))
                  writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endBlockNumber);
              return writer;
          };

          /**
           * Encodes the specified BlocksQueryByHeight message, length delimited. Does not implicitly {@link casper.BlocksQueryByHeight.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {casper.IBlocksQueryByHeight} message BlocksQueryByHeight message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlocksQueryByHeight.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlocksQueryByHeight message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlocksQueryByHeight} BlocksQueryByHeight
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlocksQueryByHeight.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlocksQueryByHeight();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.startBlockNumber = reader.int64();
                      break;
                  case 2:
                      message.endBlockNumber = reader.int64();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlocksQueryByHeight message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlocksQueryByHeight} BlocksQueryByHeight
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlocksQueryByHeight.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlocksQueryByHeight message.
           * @function verify
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlocksQueryByHeight.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.startBlockNumber != null && message.hasOwnProperty("startBlockNumber"))
                  if (!$util.isInteger(message.startBlockNumber) && !(message.startBlockNumber && $util.isInteger(message.startBlockNumber.low) && $util.isInteger(message.startBlockNumber.high)))
                      return "startBlockNumber: integer|Long expected";
              if (message.endBlockNumber != null && message.hasOwnProperty("endBlockNumber"))
                  if (!$util.isInteger(message.endBlockNumber) && !(message.endBlockNumber && $util.isInteger(message.endBlockNumber.low) && $util.isInteger(message.endBlockNumber.high)))
                      return "endBlockNumber: integer|Long expected";
              return null;
          };

          /**
           * Creates a BlocksQueryByHeight message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlocksQueryByHeight} BlocksQueryByHeight
           */
          BlocksQueryByHeight.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlocksQueryByHeight)
                  return object;
              var message = new $root.casper.BlocksQueryByHeight();
              if (object.startBlockNumber != null)
                  if ($util.Long)
                      (message.startBlockNumber = $util.Long.fromValue(object.startBlockNumber)).unsigned = false;
                  else if (typeof object.startBlockNumber === "string")
                      message.startBlockNumber = parseInt(object.startBlockNumber, 10);
                  else if (typeof object.startBlockNumber === "number")
                      message.startBlockNumber = object.startBlockNumber;
                  else if (typeof object.startBlockNumber === "object")
                      message.startBlockNumber = new $util.LongBits(object.startBlockNumber.low >>> 0, object.startBlockNumber.high >>> 0).toNumber();
              if (object.endBlockNumber != null)
                  if ($util.Long)
                      (message.endBlockNumber = $util.Long.fromValue(object.endBlockNumber)).unsigned = false;
                  else if (typeof object.endBlockNumber === "string")
                      message.endBlockNumber = parseInt(object.endBlockNumber, 10);
                  else if (typeof object.endBlockNumber === "number")
                      message.endBlockNumber = object.endBlockNumber;
                  else if (typeof object.endBlockNumber === "object")
                      message.endBlockNumber = new $util.LongBits(object.endBlockNumber.low >>> 0, object.endBlockNumber.high >>> 0).toNumber();
              return message;
          };

          /**
           * Creates a plain object from a BlocksQueryByHeight message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlocksQueryByHeight
           * @static
           * @param {casper.BlocksQueryByHeight} message BlocksQueryByHeight
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlocksQueryByHeight.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.startBlockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.startBlockNumber = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.endBlockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.endBlockNumber = options.longs === String ? "0" : 0;
              }
              if (message.startBlockNumber != null && message.hasOwnProperty("startBlockNumber"))
                  if (typeof message.startBlockNumber === "number")
                      object.startBlockNumber = options.longs === String ? String(message.startBlockNumber) : message.startBlockNumber;
                  else
                      object.startBlockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.startBlockNumber) : options.longs === Number ? new $util.LongBits(message.startBlockNumber.low >>> 0, message.startBlockNumber.high >>> 0).toNumber() : message.startBlockNumber;
              if (message.endBlockNumber != null && message.hasOwnProperty("endBlockNumber"))
                  if (typeof message.endBlockNumber === "number")
                      object.endBlockNumber = options.longs === String ? String(message.endBlockNumber) : message.endBlockNumber;
                  else
                      object.endBlockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.endBlockNumber) : options.longs === Number ? new $util.LongBits(message.endBlockNumber.low >>> 0, message.endBlockNumber.high >>> 0).toNumber() : message.endBlockNumber;
              return object;
          };

          /**
           * Converts this BlocksQueryByHeight to JSON.
           * @function toJSON
           * @memberof casper.BlocksQueryByHeight
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlocksQueryByHeight.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlocksQueryByHeight;
      })();

      casper.DataAtNameQuery = (function() {

          /**
           * Properties of a DataAtNameQuery.
           * @memberof casper
           * @interface IDataAtNameQuery
           * @property {number|null} [depth] DataAtNameQuery depth
           * @property {IPar|null} [name] DataAtNameQuery name
           */

          /**
           * Constructs a new DataAtNameQuery.
           * @memberof casper
           * @classdesc Represents a DataAtNameQuery.
           * @implements IDataAtNameQuery
           * @constructor
           * @param {casper.IDataAtNameQuery=} [properties] Properties to set
           */
          function DataAtNameQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * DataAtNameQuery depth.
           * @member {number} depth
           * @memberof casper.DataAtNameQuery
           * @instance
           */
          DataAtNameQuery.prototype.depth = 0;

          /**
           * DataAtNameQuery name.
           * @member {IPar|null|undefined} name
           * @memberof casper.DataAtNameQuery
           * @instance
           */
          DataAtNameQuery.prototype.name = null;

          /**
           * Creates a new DataAtNameQuery instance using the specified properties.
           * @function create
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {casper.IDataAtNameQuery=} [properties] Properties to set
           * @returns {casper.DataAtNameQuery} DataAtNameQuery instance
           */
          DataAtNameQuery.create = function create(properties) {
              return new DataAtNameQuery(properties);
          };

          /**
           * Encodes the specified DataAtNameQuery message. Does not implicitly {@link casper.DataAtNameQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {casper.IDataAtNameQuery} message DataAtNameQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DataAtNameQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.depth != null && message.hasOwnProperty("depth"))
                  writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
              if (message.name != null && message.hasOwnProperty("name"))
                  $root.Par.encode(message.name, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified DataAtNameQuery message, length delimited. Does not implicitly {@link casper.DataAtNameQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {casper.IDataAtNameQuery} message DataAtNameQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DataAtNameQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DataAtNameQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.DataAtNameQuery} DataAtNameQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DataAtNameQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DataAtNameQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.depth = reader.int32();
                      break;
                  case 2:
                      message.name = $root.Par.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a DataAtNameQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.DataAtNameQuery} DataAtNameQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DataAtNameQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DataAtNameQuery message.
           * @function verify
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DataAtNameQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.depth != null && message.hasOwnProperty("depth"))
                  if (!$util.isInteger(message.depth))
                      return "depth: integer expected";
              if (message.name != null && message.hasOwnProperty("name")) {
                  var error = $root.Par.verify(message.name);
                  if (error)
                      return "name." + error;
              }
              return null;
          };

          /**
           * Creates a DataAtNameQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.DataAtNameQuery} DataAtNameQuery
           */
          DataAtNameQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.DataAtNameQuery)
                  return object;
              var message = new $root.casper.DataAtNameQuery();
              if (object.depth != null)
                  message.depth = object.depth | 0;
              if (object.name != null) {
                  if (typeof object.name !== "object")
                      throw TypeError(".casper.DataAtNameQuery.name: object expected");
                  message.name = $root.Par.fromObject(object.name);
              }
              return message;
          };

          /**
           * Creates a plain object from a DataAtNameQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.DataAtNameQuery
           * @static
           * @param {casper.DataAtNameQuery} message DataAtNameQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DataAtNameQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.depth = 0;
                  object.name = null;
              }
              if (message.depth != null && message.hasOwnProperty("depth"))
                  object.depth = message.depth;
              if (message.name != null && message.hasOwnProperty("name"))
                  object.name = $root.Par.toObject(message.name, options);
              return object;
          };

          /**
           * Converts this DataAtNameQuery to JSON.
           * @function toJSON
           * @memberof casper.DataAtNameQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DataAtNameQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return DataAtNameQuery;
      })();

      casper.ContinuationAtNameQuery = (function() {

          /**
           * Properties of a ContinuationAtNameQuery.
           * @memberof casper
           * @interface IContinuationAtNameQuery
           * @property {number|null} [depth] ContinuationAtNameQuery depth
           * @property {Array.<IPar>|null} [names] ContinuationAtNameQuery names
           */

          /**
           * Constructs a new ContinuationAtNameQuery.
           * @memberof casper
           * @classdesc Represents a ContinuationAtNameQuery.
           * @implements IContinuationAtNameQuery
           * @constructor
           * @param {casper.IContinuationAtNameQuery=} [properties] Properties to set
           */
          function ContinuationAtNameQuery(properties) {
              this.names = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ContinuationAtNameQuery depth.
           * @member {number} depth
           * @memberof casper.ContinuationAtNameQuery
           * @instance
           */
          ContinuationAtNameQuery.prototype.depth = 0;

          /**
           * ContinuationAtNameQuery names.
           * @member {Array.<IPar>} names
           * @memberof casper.ContinuationAtNameQuery
           * @instance
           */
          ContinuationAtNameQuery.prototype.names = $util.emptyArray;

          /**
           * Creates a new ContinuationAtNameQuery instance using the specified properties.
           * @function create
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {casper.IContinuationAtNameQuery=} [properties] Properties to set
           * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery instance
           */
          ContinuationAtNameQuery.create = function create(properties) {
              return new ContinuationAtNameQuery(properties);
          };

          /**
           * Encodes the specified ContinuationAtNameQuery message. Does not implicitly {@link casper.ContinuationAtNameQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {casper.IContinuationAtNameQuery} message ContinuationAtNameQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ContinuationAtNameQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.depth != null && message.hasOwnProperty("depth"))
                  writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
              if (message.names != null && message.names.length)
                  for (var i = 0; i < message.names.length; ++i)
                      $root.Par.encode(message.names[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ContinuationAtNameQuery message, length delimited. Does not implicitly {@link casper.ContinuationAtNameQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {casper.IContinuationAtNameQuery} message ContinuationAtNameQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ContinuationAtNameQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ContinuationAtNameQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ContinuationAtNameQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ContinuationAtNameQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.depth = reader.int32();
                      break;
                  case 2:
                      if (!(message.names && message.names.length))
                          message.names = [];
                      message.names.push($root.Par.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ContinuationAtNameQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ContinuationAtNameQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ContinuationAtNameQuery message.
           * @function verify
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ContinuationAtNameQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.depth != null && message.hasOwnProperty("depth"))
                  if (!$util.isInteger(message.depth))
                      return "depth: integer expected";
              if (message.names != null && message.hasOwnProperty("names")) {
                  if (!Array.isArray(message.names))
                      return "names: array expected";
                  for (var i = 0; i < message.names.length; ++i) {
                      var error = $root.Par.verify(message.names[i]);
                      if (error)
                          return "names." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a ContinuationAtNameQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ContinuationAtNameQuery} ContinuationAtNameQuery
           */
          ContinuationAtNameQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ContinuationAtNameQuery)
                  return object;
              var message = new $root.casper.ContinuationAtNameQuery();
              if (object.depth != null)
                  message.depth = object.depth | 0;
              if (object.names) {
                  if (!Array.isArray(object.names))
                      throw TypeError(".casper.ContinuationAtNameQuery.names: array expected");
                  message.names = [];
                  for (var i = 0; i < object.names.length; ++i) {
                      if (typeof object.names[i] !== "object")
                          throw TypeError(".casper.ContinuationAtNameQuery.names: object expected");
                      message.names[i] = $root.Par.fromObject(object.names[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a ContinuationAtNameQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ContinuationAtNameQuery
           * @static
           * @param {casper.ContinuationAtNameQuery} message ContinuationAtNameQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ContinuationAtNameQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.names = [];
              if (options.defaults)
                  object.depth = 0;
              if (message.depth != null && message.hasOwnProperty("depth"))
                  object.depth = message.depth;
              if (message.names && message.names.length) {
                  object.names = [];
                  for (var j = 0; j < message.names.length; ++j)
                      object.names[j] = $root.Par.toObject(message.names[j], options);
              }
              return object;
          };

          /**
           * Converts this ContinuationAtNameQuery to JSON.
           * @function toJSON
           * @memberof casper.ContinuationAtNameQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ContinuationAtNameQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ContinuationAtNameQuery;
      })();

      casper.VisualizeDagQuery = (function() {

          /**
           * Properties of a VisualizeDagQuery.
           * @memberof casper
           * @interface IVisualizeDagQuery
           * @property {number|null} [depth] VisualizeDagQuery depth
           * @property {boolean|null} [showJustificationLines] VisualizeDagQuery showJustificationLines
           * @property {number|null} [startBlockNumber] VisualizeDagQuery startBlockNumber
           */

          /**
           * Constructs a new VisualizeDagQuery.
           * @memberof casper
           * @classdesc Represents a VisualizeDagQuery.
           * @implements IVisualizeDagQuery
           * @constructor
           * @param {casper.IVisualizeDagQuery=} [properties] Properties to set
           */
          function VisualizeDagQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * VisualizeDagQuery depth.
           * @member {number} depth
           * @memberof casper.VisualizeDagQuery
           * @instance
           */
          VisualizeDagQuery.prototype.depth = 0;

          /**
           * VisualizeDagQuery showJustificationLines.
           * @member {boolean} showJustificationLines
           * @memberof casper.VisualizeDagQuery
           * @instance
           */
          VisualizeDagQuery.prototype.showJustificationLines = false;

          /**
           * VisualizeDagQuery startBlockNumber.
           * @member {number} startBlockNumber
           * @memberof casper.VisualizeDagQuery
           * @instance
           */
          VisualizeDagQuery.prototype.startBlockNumber = 0;

          /**
           * Creates a new VisualizeDagQuery instance using the specified properties.
           * @function create
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {casper.IVisualizeDagQuery=} [properties] Properties to set
           * @returns {casper.VisualizeDagQuery} VisualizeDagQuery instance
           */
          VisualizeDagQuery.create = function create(properties) {
              return new VisualizeDagQuery(properties);
          };

          /**
           * Encodes the specified VisualizeDagQuery message. Does not implicitly {@link casper.VisualizeDagQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {casper.IVisualizeDagQuery} message VisualizeDagQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VisualizeDagQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.depth != null && message.hasOwnProperty("depth"))
                  writer.uint32(/* id 1, wireType 0 =*/8).int32(message.depth);
              if (message.showJustificationLines != null && message.hasOwnProperty("showJustificationLines"))
                  writer.uint32(/* id 2, wireType 0 =*/16).bool(message.showJustificationLines);
              if (message.startBlockNumber != null && message.hasOwnProperty("startBlockNumber"))
                  writer.uint32(/* id 3, wireType 0 =*/24).int32(message.startBlockNumber);
              return writer;
          };

          /**
           * Encodes the specified VisualizeDagQuery message, length delimited. Does not implicitly {@link casper.VisualizeDagQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {casper.IVisualizeDagQuery} message VisualizeDagQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VisualizeDagQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a VisualizeDagQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.VisualizeDagQuery} VisualizeDagQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VisualizeDagQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.VisualizeDagQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.depth = reader.int32();
                      break;
                  case 2:
                      message.showJustificationLines = reader.bool();
                      break;
                  case 3:
                      message.startBlockNumber = reader.int32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a VisualizeDagQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.VisualizeDagQuery} VisualizeDagQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VisualizeDagQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a VisualizeDagQuery message.
           * @function verify
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          VisualizeDagQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.depth != null && message.hasOwnProperty("depth"))
                  if (!$util.isInteger(message.depth))
                      return "depth: integer expected";
              if (message.showJustificationLines != null && message.hasOwnProperty("showJustificationLines"))
                  if (typeof message.showJustificationLines !== "boolean")
                      return "showJustificationLines: boolean expected";
              if (message.startBlockNumber != null && message.hasOwnProperty("startBlockNumber"))
                  if (!$util.isInteger(message.startBlockNumber))
                      return "startBlockNumber: integer expected";
              return null;
          };

          /**
           * Creates a VisualizeDagQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.VisualizeDagQuery} VisualizeDagQuery
           */
          VisualizeDagQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.VisualizeDagQuery)
                  return object;
              var message = new $root.casper.VisualizeDagQuery();
              if (object.depth != null)
                  message.depth = object.depth | 0;
              if (object.showJustificationLines != null)
                  message.showJustificationLines = Boolean(object.showJustificationLines);
              if (object.startBlockNumber != null)
                  message.startBlockNumber = object.startBlockNumber | 0;
              return message;
          };

          /**
           * Creates a plain object from a VisualizeDagQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.VisualizeDagQuery
           * @static
           * @param {casper.VisualizeDagQuery} message VisualizeDagQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          VisualizeDagQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.depth = 0;
                  object.showJustificationLines = false;
                  object.startBlockNumber = 0;
              }
              if (message.depth != null && message.hasOwnProperty("depth"))
                  object.depth = message.depth;
              if (message.showJustificationLines != null && message.hasOwnProperty("showJustificationLines"))
                  object.showJustificationLines = message.showJustificationLines;
              if (message.startBlockNumber != null && message.hasOwnProperty("startBlockNumber"))
                  object.startBlockNumber = message.startBlockNumber;
              return object;
          };

          /**
           * Converts this VisualizeDagQuery to JSON.
           * @function toJSON
           * @memberof casper.VisualizeDagQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          VisualizeDagQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return VisualizeDagQuery;
      })();

      casper.MachineVerifyQuery = (function() {

          /**
           * Properties of a MachineVerifyQuery.
           * @memberof casper
           * @interface IMachineVerifyQuery
           */

          /**
           * Constructs a new MachineVerifyQuery.
           * @memberof casper
           * @classdesc Represents a MachineVerifyQuery.
           * @implements IMachineVerifyQuery
           * @constructor
           * @param {casper.IMachineVerifyQuery=} [properties] Properties to set
           */
          function MachineVerifyQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new MachineVerifyQuery instance using the specified properties.
           * @function create
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {casper.IMachineVerifyQuery=} [properties] Properties to set
           * @returns {casper.MachineVerifyQuery} MachineVerifyQuery instance
           */
          MachineVerifyQuery.create = function create(properties) {
              return new MachineVerifyQuery(properties);
          };

          /**
           * Encodes the specified MachineVerifyQuery message. Does not implicitly {@link casper.MachineVerifyQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {casper.IMachineVerifyQuery} message MachineVerifyQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MachineVerifyQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified MachineVerifyQuery message, length delimited. Does not implicitly {@link casper.MachineVerifyQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {casper.IMachineVerifyQuery} message MachineVerifyQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MachineVerifyQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a MachineVerifyQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.MachineVerifyQuery} MachineVerifyQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MachineVerifyQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.MachineVerifyQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a MachineVerifyQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.MachineVerifyQuery} MachineVerifyQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MachineVerifyQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a MachineVerifyQuery message.
           * @function verify
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          MachineVerifyQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a MachineVerifyQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.MachineVerifyQuery} MachineVerifyQuery
           */
          MachineVerifyQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.MachineVerifyQuery)
                  return object;
              return new $root.casper.MachineVerifyQuery();
          };

          /**
           * Creates a plain object from a MachineVerifyQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.MachineVerifyQuery
           * @static
           * @param {casper.MachineVerifyQuery} message MachineVerifyQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          MachineVerifyQuery.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this MachineVerifyQuery to JSON.
           * @function toJSON
           * @memberof casper.MachineVerifyQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          MachineVerifyQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return MachineVerifyQuery;
      })();

      casper.PrivateNamePreviewQuery = (function() {

          /**
           * Properties of a PrivateNamePreviewQuery.
           * @memberof casper
           * @interface IPrivateNamePreviewQuery
           * @property {Uint8Array|null} [user] PrivateNamePreviewQuery user
           * @property {number|Long|null} [timestamp] PrivateNamePreviewQuery timestamp
           * @property {number|null} [nameQty] PrivateNamePreviewQuery nameQty
           */

          /**
           * Constructs a new PrivateNamePreviewQuery.
           * @memberof casper
           * @classdesc Represents a PrivateNamePreviewQuery.
           * @implements IPrivateNamePreviewQuery
           * @constructor
           * @param {casper.IPrivateNamePreviewQuery=} [properties] Properties to set
           */
          function PrivateNamePreviewQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * PrivateNamePreviewQuery user.
           * @member {Uint8Array} user
           * @memberof casper.PrivateNamePreviewQuery
           * @instance
           */
          PrivateNamePreviewQuery.prototype.user = $util.newBuffer([]);

          /**
           * PrivateNamePreviewQuery timestamp.
           * @member {number|Long} timestamp
           * @memberof casper.PrivateNamePreviewQuery
           * @instance
           */
          PrivateNamePreviewQuery.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * PrivateNamePreviewQuery nameQty.
           * @member {number} nameQty
           * @memberof casper.PrivateNamePreviewQuery
           * @instance
           */
          PrivateNamePreviewQuery.prototype.nameQty = 0;

          /**
           * Creates a new PrivateNamePreviewQuery instance using the specified properties.
           * @function create
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {casper.IPrivateNamePreviewQuery=} [properties] Properties to set
           * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery instance
           */
          PrivateNamePreviewQuery.create = function create(properties) {
              return new PrivateNamePreviewQuery(properties);
          };

          /**
           * Encodes the specified PrivateNamePreviewQuery message. Does not implicitly {@link casper.PrivateNamePreviewQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {casper.IPrivateNamePreviewQuery} message PrivateNamePreviewQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PrivateNamePreviewQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.user != null && message.hasOwnProperty("user"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.user);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
              if (message.nameQty != null && message.hasOwnProperty("nameQty"))
                  writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nameQty);
              return writer;
          };

          /**
           * Encodes the specified PrivateNamePreviewQuery message, length delimited. Does not implicitly {@link casper.PrivateNamePreviewQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {casper.IPrivateNamePreviewQuery} message PrivateNamePreviewQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PrivateNamePreviewQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PrivateNamePreviewQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PrivateNamePreviewQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.PrivateNamePreviewQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.user = reader.bytes();
                      break;
                  case 2:
                      message.timestamp = reader.int64();
                      break;
                  case 3:
                      message.nameQty = reader.int32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a PrivateNamePreviewQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PrivateNamePreviewQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PrivateNamePreviewQuery message.
           * @function verify
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PrivateNamePreviewQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.user != null && message.hasOwnProperty("user"))
                  if (!(message.user && typeof message.user.length === "number" || $util.isString(message.user)))
                      return "user: buffer expected";
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                      return "timestamp: integer|Long expected";
              if (message.nameQty != null && message.hasOwnProperty("nameQty"))
                  if (!$util.isInteger(message.nameQty))
                      return "nameQty: integer expected";
              return null;
          };

          /**
           * Creates a PrivateNamePreviewQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.PrivateNamePreviewQuery} PrivateNamePreviewQuery
           */
          PrivateNamePreviewQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.PrivateNamePreviewQuery)
                  return object;
              var message = new $root.casper.PrivateNamePreviewQuery();
              if (object.user != null)
                  if (typeof object.user === "string")
                      $util.base64.decode(object.user, message.user = $util.newBuffer($util.base64.length(object.user)), 0);
                  else if (object.user.length)
                      message.user = object.user;
              if (object.timestamp != null)
                  if ($util.Long)
                      (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                  else if (typeof object.timestamp === "string")
                      message.timestamp = parseInt(object.timestamp, 10);
                  else if (typeof object.timestamp === "number")
                      message.timestamp = object.timestamp;
                  else if (typeof object.timestamp === "object")
                      message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
              if (object.nameQty != null)
                  message.nameQty = object.nameQty | 0;
              return message;
          };

          /**
           * Creates a plain object from a PrivateNamePreviewQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.PrivateNamePreviewQuery
           * @static
           * @param {casper.PrivateNamePreviewQuery} message PrivateNamePreviewQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PrivateNamePreviewQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.user = "";
                  else {
                      object.user = [];
                      if (options.bytes !== Array)
                          object.user = $util.newBuffer(object.user);
                  }
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.timestamp = options.longs === String ? "0" : 0;
                  object.nameQty = 0;
              }
              if (message.user != null && message.hasOwnProperty("user"))
                  object.user = options.bytes === String ? $util.base64.encode(message.user, 0, message.user.length) : options.bytes === Array ? Array.prototype.slice.call(message.user) : message.user;
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (typeof message.timestamp === "number")
                      object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                  else
                      object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
              if (message.nameQty != null && message.hasOwnProperty("nameQty"))
                  object.nameQty = message.nameQty;
              return object;
          };

          /**
           * Converts this PrivateNamePreviewQuery to JSON.
           * @function toJSON
           * @memberof casper.PrivateNamePreviewQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PrivateNamePreviewQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return PrivateNamePreviewQuery;
      })();

      casper.LastFinalizedBlockQuery = (function() {

          /**
           * Properties of a LastFinalizedBlockQuery.
           * @memberof casper
           * @interface ILastFinalizedBlockQuery
           */

          /**
           * Constructs a new LastFinalizedBlockQuery.
           * @memberof casper
           * @classdesc Represents a LastFinalizedBlockQuery.
           * @implements ILastFinalizedBlockQuery
           * @constructor
           * @param {casper.ILastFinalizedBlockQuery=} [properties] Properties to set
           */
          function LastFinalizedBlockQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new LastFinalizedBlockQuery instance using the specified properties.
           * @function create
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {casper.ILastFinalizedBlockQuery=} [properties] Properties to set
           * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery instance
           */
          LastFinalizedBlockQuery.create = function create(properties) {
              return new LastFinalizedBlockQuery(properties);
          };

          /**
           * Encodes the specified LastFinalizedBlockQuery message. Does not implicitly {@link casper.LastFinalizedBlockQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {casper.ILastFinalizedBlockQuery} message LastFinalizedBlockQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LastFinalizedBlockQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified LastFinalizedBlockQuery message, length delimited. Does not implicitly {@link casper.LastFinalizedBlockQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {casper.ILastFinalizedBlockQuery} message LastFinalizedBlockQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LastFinalizedBlockQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a LastFinalizedBlockQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LastFinalizedBlockQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.LastFinalizedBlockQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a LastFinalizedBlockQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LastFinalizedBlockQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a LastFinalizedBlockQuery message.
           * @function verify
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          LastFinalizedBlockQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a LastFinalizedBlockQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.LastFinalizedBlockQuery} LastFinalizedBlockQuery
           */
          LastFinalizedBlockQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.LastFinalizedBlockQuery)
                  return object;
              return new $root.casper.LastFinalizedBlockQuery();
          };

          /**
           * Creates a plain object from a LastFinalizedBlockQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.LastFinalizedBlockQuery
           * @static
           * @param {casper.LastFinalizedBlockQuery} message LastFinalizedBlockQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          LastFinalizedBlockQuery.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this LastFinalizedBlockQuery to JSON.
           * @function toJSON
           * @memberof casper.LastFinalizedBlockQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          LastFinalizedBlockQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return LastFinalizedBlockQuery;
      })();

      casper.IsFinalizedQuery = (function() {

          /**
           * Properties of an IsFinalizedQuery.
           * @memberof casper
           * @interface IIsFinalizedQuery
           * @property {string|null} [hash] IsFinalizedQuery hash
           */

          /**
           * Constructs a new IsFinalizedQuery.
           * @memberof casper
           * @classdesc Represents an IsFinalizedQuery.
           * @implements IIsFinalizedQuery
           * @constructor
           * @param {casper.IIsFinalizedQuery=} [properties] Properties to set
           */
          function IsFinalizedQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * IsFinalizedQuery hash.
           * @member {string} hash
           * @memberof casper.IsFinalizedQuery
           * @instance
           */
          IsFinalizedQuery.prototype.hash = "";

          /**
           * Creates a new IsFinalizedQuery instance using the specified properties.
           * @function create
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {casper.IIsFinalizedQuery=} [properties] Properties to set
           * @returns {casper.IsFinalizedQuery} IsFinalizedQuery instance
           */
          IsFinalizedQuery.create = function create(properties) {
              return new IsFinalizedQuery(properties);
          };

          /**
           * Encodes the specified IsFinalizedQuery message. Does not implicitly {@link casper.IsFinalizedQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {casper.IIsFinalizedQuery} message IsFinalizedQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          IsFinalizedQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.hash != null && message.hasOwnProperty("hash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
              return writer;
          };

          /**
           * Encodes the specified IsFinalizedQuery message, length delimited. Does not implicitly {@link casper.IsFinalizedQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {casper.IIsFinalizedQuery} message IsFinalizedQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          IsFinalizedQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an IsFinalizedQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.IsFinalizedQuery} IsFinalizedQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          IsFinalizedQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.IsFinalizedQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.hash = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an IsFinalizedQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.IsFinalizedQuery} IsFinalizedQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          IsFinalizedQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an IsFinalizedQuery message.
           * @function verify
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          IsFinalizedQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  if (!$util.isString(message.hash))
                      return "hash: string expected";
              return null;
          };

          /**
           * Creates an IsFinalizedQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.IsFinalizedQuery} IsFinalizedQuery
           */
          IsFinalizedQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.IsFinalizedQuery)
                  return object;
              var message = new $root.casper.IsFinalizedQuery();
              if (object.hash != null)
                  message.hash = String(object.hash);
              return message;
          };

          /**
           * Creates a plain object from an IsFinalizedQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.IsFinalizedQuery
           * @static
           * @param {casper.IsFinalizedQuery} message IsFinalizedQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          IsFinalizedQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.hash = "";
              if (message.hash != null && message.hasOwnProperty("hash"))
                  object.hash = message.hash;
              return object;
          };

          /**
           * Converts this IsFinalizedQuery to JSON.
           * @function toJSON
           * @memberof casper.IsFinalizedQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          IsFinalizedQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return IsFinalizedQuery;
      })();

      casper.BondStatusQuery = (function() {

          /**
           * Properties of a BondStatusQuery.
           * @memberof casper
           * @interface IBondStatusQuery
           * @property {Uint8Array|null} [publicKey] BondStatusQuery publicKey
           */

          /**
           * Constructs a new BondStatusQuery.
           * @memberof casper
           * @classdesc Represents a BondStatusQuery.
           * @implements IBondStatusQuery
           * @constructor
           * @param {casper.IBondStatusQuery=} [properties] Properties to set
           */
          function BondStatusQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BondStatusQuery publicKey.
           * @member {Uint8Array} publicKey
           * @memberof casper.BondStatusQuery
           * @instance
           */
          BondStatusQuery.prototype.publicKey = $util.newBuffer([]);

          /**
           * Creates a new BondStatusQuery instance using the specified properties.
           * @function create
           * @memberof casper.BondStatusQuery
           * @static
           * @param {casper.IBondStatusQuery=} [properties] Properties to set
           * @returns {casper.BondStatusQuery} BondStatusQuery instance
           */
          BondStatusQuery.create = function create(properties) {
              return new BondStatusQuery(properties);
          };

          /**
           * Encodes the specified BondStatusQuery message. Does not implicitly {@link casper.BondStatusQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.BondStatusQuery
           * @static
           * @param {casper.IBondStatusQuery} message BondStatusQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BondStatusQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
              return writer;
          };

          /**
           * Encodes the specified BondStatusQuery message, length delimited. Does not implicitly {@link casper.BondStatusQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BondStatusQuery
           * @static
           * @param {casper.IBondStatusQuery} message BondStatusQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BondStatusQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BondStatusQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BondStatusQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BondStatusQuery} BondStatusQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BondStatusQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BondStatusQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.publicKey = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BondStatusQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BondStatusQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BondStatusQuery} BondStatusQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BondStatusQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BondStatusQuery message.
           * @function verify
           * @memberof casper.BondStatusQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BondStatusQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                  if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                      return "publicKey: buffer expected";
              return null;
          };

          /**
           * Creates a BondStatusQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BondStatusQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BondStatusQuery} BondStatusQuery
           */
          BondStatusQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BondStatusQuery)
                  return object;
              var message = new $root.casper.BondStatusQuery();
              if (object.publicKey != null)
                  if (typeof object.publicKey === "string")
                      $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                  else if (object.publicKey.length)
                      message.publicKey = object.publicKey;
              return message;
          };

          /**
           * Creates a plain object from a BondStatusQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BondStatusQuery
           * @static
           * @param {casper.BondStatusQuery} message BondStatusQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BondStatusQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.publicKey = "";
                  else {
                      object.publicKey = [];
                      if (options.bytes !== Array)
                          object.publicKey = $util.newBuffer(object.publicKey);
                  }
              if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                  object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
              return object;
          };

          /**
           * Converts this BondStatusQuery to JSON.
           * @function toJSON
           * @memberof casper.BondStatusQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BondStatusQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BondStatusQuery;
      })();

      casper.ExploratoryDeployQuery = (function() {

          /**
           * Properties of an ExploratoryDeployQuery.
           * @memberof casper
           * @interface IExploratoryDeployQuery
           * @property {string|null} [term] ExploratoryDeployQuery term
           * @property {string|null} [blockHash] ExploratoryDeployQuery blockHash
           * @property {boolean|null} [usePreStateHash] ExploratoryDeployQuery usePreStateHash
           */

          /**
           * Constructs a new ExploratoryDeployQuery.
           * @memberof casper
           * @classdesc Represents an ExploratoryDeployQuery.
           * @implements IExploratoryDeployQuery
           * @constructor
           * @param {casper.IExploratoryDeployQuery=} [properties] Properties to set
           */
          function ExploratoryDeployQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ExploratoryDeployQuery term.
           * @member {string} term
           * @memberof casper.ExploratoryDeployQuery
           * @instance
           */
          ExploratoryDeployQuery.prototype.term = "";

          /**
           * ExploratoryDeployQuery blockHash.
           * @member {string} blockHash
           * @memberof casper.ExploratoryDeployQuery
           * @instance
           */
          ExploratoryDeployQuery.prototype.blockHash = "";

          /**
           * ExploratoryDeployQuery usePreStateHash.
           * @member {boolean} usePreStateHash
           * @memberof casper.ExploratoryDeployQuery
           * @instance
           */
          ExploratoryDeployQuery.prototype.usePreStateHash = false;

          /**
           * Creates a new ExploratoryDeployQuery instance using the specified properties.
           * @function create
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {casper.IExploratoryDeployQuery=} [properties] Properties to set
           * @returns {casper.ExploratoryDeployQuery} ExploratoryDeployQuery instance
           */
          ExploratoryDeployQuery.create = function create(properties) {
              return new ExploratoryDeployQuery(properties);
          };

          /**
           * Encodes the specified ExploratoryDeployQuery message. Does not implicitly {@link casper.ExploratoryDeployQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {casper.IExploratoryDeployQuery} message ExploratoryDeployQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ExploratoryDeployQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.term != null && message.hasOwnProperty("term"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.term);
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockHash);
              if (message.usePreStateHash != null && message.hasOwnProperty("usePreStateHash"))
                  writer.uint32(/* id 3, wireType 0 =*/24).bool(message.usePreStateHash);
              return writer;
          };

          /**
           * Encodes the specified ExploratoryDeployQuery message, length delimited. Does not implicitly {@link casper.ExploratoryDeployQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {casper.IExploratoryDeployQuery} message ExploratoryDeployQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ExploratoryDeployQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an ExploratoryDeployQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ExploratoryDeployQuery} ExploratoryDeployQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ExploratoryDeployQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ExploratoryDeployQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.term = reader.string();
                      break;
                  case 2:
                      message.blockHash = reader.string();
                      break;
                  case 3:
                      message.usePreStateHash = reader.bool();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an ExploratoryDeployQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ExploratoryDeployQuery} ExploratoryDeployQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ExploratoryDeployQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an ExploratoryDeployQuery message.
           * @function verify
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ExploratoryDeployQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.term != null && message.hasOwnProperty("term"))
                  if (!$util.isString(message.term))
                      return "term: string expected";
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  if (!$util.isString(message.blockHash))
                      return "blockHash: string expected";
              if (message.usePreStateHash != null && message.hasOwnProperty("usePreStateHash"))
                  if (typeof message.usePreStateHash !== "boolean")
                      return "usePreStateHash: boolean expected";
              return null;
          };

          /**
           * Creates an ExploratoryDeployQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ExploratoryDeployQuery} ExploratoryDeployQuery
           */
          ExploratoryDeployQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ExploratoryDeployQuery)
                  return object;
              var message = new $root.casper.ExploratoryDeployQuery();
              if (object.term != null)
                  message.term = String(object.term);
              if (object.blockHash != null)
                  message.blockHash = String(object.blockHash);
              if (object.usePreStateHash != null)
                  message.usePreStateHash = Boolean(object.usePreStateHash);
              return message;
          };

          /**
           * Creates a plain object from an ExploratoryDeployQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ExploratoryDeployQuery
           * @static
           * @param {casper.ExploratoryDeployQuery} message ExploratoryDeployQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ExploratoryDeployQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.term = "";
                  object.blockHash = "";
                  object.usePreStateHash = false;
              }
              if (message.term != null && message.hasOwnProperty("term"))
                  object.term = message.term;
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  object.blockHash = message.blockHash;
              if (message.usePreStateHash != null && message.hasOwnProperty("usePreStateHash"))
                  object.usePreStateHash = message.usePreStateHash;
              return object;
          };

          /**
           * Converts this ExploratoryDeployQuery to JSON.
           * @function toJSON
           * @memberof casper.ExploratoryDeployQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ExploratoryDeployQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ExploratoryDeployQuery;
      })();

      casper.BondInfo = (function() {

          /**
           * Properties of a BondInfo.
           * @memberof casper
           * @interface IBondInfo
           * @property {string|null} [validator] BondInfo validator
           * @property {number|Long|null} [stake] BondInfo stake
           */

          /**
           * Constructs a new BondInfo.
           * @memberof casper
           * @classdesc Represents a BondInfo.
           * @implements IBondInfo
           * @constructor
           * @param {casper.IBondInfo=} [properties] Properties to set
           */
          function BondInfo(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BondInfo validator.
           * @member {string} validator
           * @memberof casper.BondInfo
           * @instance
           */
          BondInfo.prototype.validator = "";

          /**
           * BondInfo stake.
           * @member {number|Long} stake
           * @memberof casper.BondInfo
           * @instance
           */
          BondInfo.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Creates a new BondInfo instance using the specified properties.
           * @function create
           * @memberof casper.BondInfo
           * @static
           * @param {casper.IBondInfo=} [properties] Properties to set
           * @returns {casper.BondInfo} BondInfo instance
           */
          BondInfo.create = function create(properties) {
              return new BondInfo(properties);
          };

          /**
           * Encodes the specified BondInfo message. Does not implicitly {@link casper.BondInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.BondInfo
           * @static
           * @param {casper.IBondInfo} message BondInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BondInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.validator != null && message.hasOwnProperty("validator"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator);
              if (message.stake != null && message.hasOwnProperty("stake"))
                  writer.uint32(/* id 2, wireType 0 =*/16).int64(message.stake);
              return writer;
          };

          /**
           * Encodes the specified BondInfo message, length delimited. Does not implicitly {@link casper.BondInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BondInfo
           * @static
           * @param {casper.IBondInfo} message BondInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BondInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BondInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BondInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BondInfo} BondInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BondInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BondInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.validator = reader.string();
                      break;
                  case 2:
                      message.stake = reader.int64();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BondInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BondInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BondInfo} BondInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BondInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BondInfo message.
           * @function verify
           * @memberof casper.BondInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BondInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.validator != null && message.hasOwnProperty("validator"))
                  if (!$util.isString(message.validator))
                      return "validator: string expected";
              if (message.stake != null && message.hasOwnProperty("stake"))
                  if (!$util.isInteger(message.stake) && !(message.stake && $util.isInteger(message.stake.low) && $util.isInteger(message.stake.high)))
                      return "stake: integer|Long expected";
              return null;
          };

          /**
           * Creates a BondInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BondInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BondInfo} BondInfo
           */
          BondInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BondInfo)
                  return object;
              var message = new $root.casper.BondInfo();
              if (object.validator != null)
                  message.validator = String(object.validator);
              if (object.stake != null)
                  if ($util.Long)
                      (message.stake = $util.Long.fromValue(object.stake)).unsigned = false;
                  else if (typeof object.stake === "string")
                      message.stake = parseInt(object.stake, 10);
                  else if (typeof object.stake === "number")
                      message.stake = object.stake;
                  else if (typeof object.stake === "object")
                      message.stake = new $util.LongBits(object.stake.low >>> 0, object.stake.high >>> 0).toNumber();
              return message;
          };

          /**
           * Creates a plain object from a BondInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BondInfo
           * @static
           * @param {casper.BondInfo} message BondInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BondInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.validator = "";
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.stake = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.stake = options.longs === String ? "0" : 0;
              }
              if (message.validator != null && message.hasOwnProperty("validator"))
                  object.validator = message.validator;
              if (message.stake != null && message.hasOwnProperty("stake"))
                  if (typeof message.stake === "number")
                      object.stake = options.longs === String ? String(message.stake) : message.stake;
                  else
                      object.stake = options.longs === String ? $util.Long.prototype.toString.call(message.stake) : options.longs === Number ? new $util.LongBits(message.stake.low >>> 0, message.stake.high >>> 0).toNumber() : message.stake;
              return object;
          };

          /**
           * Converts this BondInfo to JSON.
           * @function toJSON
           * @memberof casper.BondInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BondInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BondInfo;
      })();

      casper.JustificationInfo = (function() {

          /**
           * Properties of a JustificationInfo.
           * @memberof casper
           * @interface IJustificationInfo
           * @property {string|null} [validator] JustificationInfo validator
           * @property {string|null} [latestBlockHash] JustificationInfo latestBlockHash
           */

          /**
           * Constructs a new JustificationInfo.
           * @memberof casper
           * @classdesc Represents a JustificationInfo.
           * @implements IJustificationInfo
           * @constructor
           * @param {casper.IJustificationInfo=} [properties] Properties to set
           */
          function JustificationInfo(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * JustificationInfo validator.
           * @member {string} validator
           * @memberof casper.JustificationInfo
           * @instance
           */
          JustificationInfo.prototype.validator = "";

          /**
           * JustificationInfo latestBlockHash.
           * @member {string} latestBlockHash
           * @memberof casper.JustificationInfo
           * @instance
           */
          JustificationInfo.prototype.latestBlockHash = "";

          /**
           * Creates a new JustificationInfo instance using the specified properties.
           * @function create
           * @memberof casper.JustificationInfo
           * @static
           * @param {casper.IJustificationInfo=} [properties] Properties to set
           * @returns {casper.JustificationInfo} JustificationInfo instance
           */
          JustificationInfo.create = function create(properties) {
              return new JustificationInfo(properties);
          };

          /**
           * Encodes the specified JustificationInfo message. Does not implicitly {@link casper.JustificationInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.JustificationInfo
           * @static
           * @param {casper.IJustificationInfo} message JustificationInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          JustificationInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.validator != null && message.hasOwnProperty("validator"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.validator);
              if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.latestBlockHash);
              return writer;
          };

          /**
           * Encodes the specified JustificationInfo message, length delimited. Does not implicitly {@link casper.JustificationInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.JustificationInfo
           * @static
           * @param {casper.IJustificationInfo} message JustificationInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          JustificationInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a JustificationInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.JustificationInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.JustificationInfo} JustificationInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          JustificationInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.JustificationInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.validator = reader.string();
                      break;
                  case 2:
                      message.latestBlockHash = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a JustificationInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.JustificationInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.JustificationInfo} JustificationInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          JustificationInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a JustificationInfo message.
           * @function verify
           * @memberof casper.JustificationInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          JustificationInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.validator != null && message.hasOwnProperty("validator"))
                  if (!$util.isString(message.validator))
                      return "validator: string expected";
              if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                  if (!$util.isString(message.latestBlockHash))
                      return "latestBlockHash: string expected";
              return null;
          };

          /**
           * Creates a JustificationInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.JustificationInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.JustificationInfo} JustificationInfo
           */
          JustificationInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.JustificationInfo)
                  return object;
              var message = new $root.casper.JustificationInfo();
              if (object.validator != null)
                  message.validator = String(object.validator);
              if (object.latestBlockHash != null)
                  message.latestBlockHash = String(object.latestBlockHash);
              return message;
          };

          /**
           * Creates a plain object from a JustificationInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.JustificationInfo
           * @static
           * @param {casper.JustificationInfo} message JustificationInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          JustificationInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.validator = "";
                  object.latestBlockHash = "";
              }
              if (message.validator != null && message.hasOwnProperty("validator"))
                  object.validator = message.validator;
              if (message.latestBlockHash != null && message.hasOwnProperty("latestBlockHash"))
                  object.latestBlockHash = message.latestBlockHash;
              return object;
          };

          /**
           * Converts this JustificationInfo to JSON.
           * @function toJSON
           * @memberof casper.JustificationInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          JustificationInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return JustificationInfo;
      })();

      casper.DeployInfo = (function() {

          /**
           * Properties of a DeployInfo.
           * @memberof casper
           * @interface IDeployInfo
           * @property {string|null} [deployer] DeployInfo deployer
           * @property {string|null} [term] DeployInfo term
           * @property {number|Long|null} [timestamp] DeployInfo timestamp
           * @property {string|null} [sig] DeployInfo sig
           * @property {string|null} [sigAlgorithm] DeployInfo sigAlgorithm
           * @property {number|Long|null} [phloPrice] DeployInfo phloPrice
           * @property {number|Long|null} [phloLimit] DeployInfo phloLimit
           * @property {number|Long|null} [validAfterBlockNumber] DeployInfo validAfterBlockNumber
           * @property {number|Long|null} [cost] DeployInfo cost
           * @property {boolean|null} [errored] DeployInfo errored
           * @property {string|null} [systemDeployError] DeployInfo systemDeployError
           */

          /**
           * Constructs a new DeployInfo.
           * @memberof casper
           * @classdesc Represents a DeployInfo.
           * @implements IDeployInfo
           * @constructor
           * @param {casper.IDeployInfo=} [properties] Properties to set
           */
          function DeployInfo(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * DeployInfo deployer.
           * @member {string} deployer
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.deployer = "";

          /**
           * DeployInfo term.
           * @member {string} term
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.term = "";

          /**
           * DeployInfo timestamp.
           * @member {number|Long} timestamp
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployInfo sig.
           * @member {string} sig
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.sig = "";

          /**
           * DeployInfo sigAlgorithm.
           * @member {string} sigAlgorithm
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.sigAlgorithm = "";

          /**
           * DeployInfo phloPrice.
           * @member {number|Long} phloPrice
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.phloPrice = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployInfo phloLimit.
           * @member {number|Long} phloLimit
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.phloLimit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployInfo validAfterBlockNumber.
           * @member {number|Long} validAfterBlockNumber
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.validAfterBlockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * DeployInfo cost.
           * @member {number|Long} cost
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

          /**
           * DeployInfo errored.
           * @member {boolean} errored
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.errored = false;

          /**
           * DeployInfo systemDeployError.
           * @member {string} systemDeployError
           * @memberof casper.DeployInfo
           * @instance
           */
          DeployInfo.prototype.systemDeployError = "";

          /**
           * Creates a new DeployInfo instance using the specified properties.
           * @function create
           * @memberof casper.DeployInfo
           * @static
           * @param {casper.IDeployInfo=} [properties] Properties to set
           * @returns {casper.DeployInfo} DeployInfo instance
           */
          DeployInfo.create = function create(properties) {
              return new DeployInfo(properties);
          };

          /**
           * Encodes the specified DeployInfo message. Does not implicitly {@link casper.DeployInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.DeployInfo
           * @static
           * @param {casper.IDeployInfo} message DeployInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DeployInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.deployer != null && message.hasOwnProperty("deployer"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.deployer);
              if (message.term != null && message.hasOwnProperty("term"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.term);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
              if (message.sig != null && message.hasOwnProperty("sig"))
                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.sig);
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  writer.uint32(/* id 5, wireType 2 =*/42).string(message.sigAlgorithm);
              if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                  writer.uint32(/* id 7, wireType 0 =*/56).int64(message.phloPrice);
              if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                  writer.uint32(/* id 8, wireType 0 =*/64).int64(message.phloLimit);
              if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                  writer.uint32(/* id 9, wireType 0 =*/72).int64(message.validAfterBlockNumber);
              if (message.cost != null && message.hasOwnProperty("cost"))
                  writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.cost);
              if (message.errored != null && message.hasOwnProperty("errored"))
                  writer.uint32(/* id 11, wireType 0 =*/88).bool(message.errored);
              if (message.systemDeployError != null && message.hasOwnProperty("systemDeployError"))
                  writer.uint32(/* id 12, wireType 2 =*/98).string(message.systemDeployError);
              return writer;
          };

          /**
           * Encodes the specified DeployInfo message, length delimited. Does not implicitly {@link casper.DeployInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.DeployInfo
           * @static
           * @param {casper.IDeployInfo} message DeployInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DeployInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DeployInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.DeployInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.DeployInfo} DeployInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DeployInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DeployInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.deployer = reader.string();
                      break;
                  case 2:
                      message.term = reader.string();
                      break;
                  case 3:
                      message.timestamp = reader.int64();
                      break;
                  case 4:
                      message.sig = reader.string();
                      break;
                  case 5:
                      message.sigAlgorithm = reader.string();
                      break;
                  case 7:
                      message.phloPrice = reader.int64();
                      break;
                  case 8:
                      message.phloLimit = reader.int64();
                      break;
                  case 9:
                      message.validAfterBlockNumber = reader.int64();
                      break;
                  case 10:
                      message.cost = reader.uint64();
                      break;
                  case 11:
                      message.errored = reader.bool();
                      break;
                  case 12:
                      message.systemDeployError = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a DeployInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.DeployInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.DeployInfo} DeployInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DeployInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DeployInfo message.
           * @function verify
           * @memberof casper.DeployInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DeployInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.deployer != null && message.hasOwnProperty("deployer"))
                  if (!$util.isString(message.deployer))
                      return "deployer: string expected";
              if (message.term != null && message.hasOwnProperty("term"))
                  if (!$util.isString(message.term))
                      return "term: string expected";
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                      return "timestamp: integer|Long expected";
              if (message.sig != null && message.hasOwnProperty("sig"))
                  if (!$util.isString(message.sig))
                      return "sig: string expected";
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  if (!$util.isString(message.sigAlgorithm))
                      return "sigAlgorithm: string expected";
              if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                  if (!$util.isInteger(message.phloPrice) && !(message.phloPrice && $util.isInteger(message.phloPrice.low) && $util.isInteger(message.phloPrice.high)))
                      return "phloPrice: integer|Long expected";
              if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                  if (!$util.isInteger(message.phloLimit) && !(message.phloLimit && $util.isInteger(message.phloLimit.low) && $util.isInteger(message.phloLimit.high)))
                      return "phloLimit: integer|Long expected";
              if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                  if (!$util.isInteger(message.validAfterBlockNumber) && !(message.validAfterBlockNumber && $util.isInteger(message.validAfterBlockNumber.low) && $util.isInteger(message.validAfterBlockNumber.high)))
                      return "validAfterBlockNumber: integer|Long expected";
              if (message.cost != null && message.hasOwnProperty("cost"))
                  if (!$util.isInteger(message.cost) && !(message.cost && $util.isInteger(message.cost.low) && $util.isInteger(message.cost.high)))
                      return "cost: integer|Long expected";
              if (message.errored != null && message.hasOwnProperty("errored"))
                  if (typeof message.errored !== "boolean")
                      return "errored: boolean expected";
              if (message.systemDeployError != null && message.hasOwnProperty("systemDeployError"))
                  if (!$util.isString(message.systemDeployError))
                      return "systemDeployError: string expected";
              return null;
          };

          /**
           * Creates a DeployInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.DeployInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.DeployInfo} DeployInfo
           */
          DeployInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.DeployInfo)
                  return object;
              var message = new $root.casper.DeployInfo();
              if (object.deployer != null)
                  message.deployer = String(object.deployer);
              if (object.term != null)
                  message.term = String(object.term);
              if (object.timestamp != null)
                  if ($util.Long)
                      (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                  else if (typeof object.timestamp === "string")
                      message.timestamp = parseInt(object.timestamp, 10);
                  else if (typeof object.timestamp === "number")
                      message.timestamp = object.timestamp;
                  else if (typeof object.timestamp === "object")
                      message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
              if (object.sig != null)
                  message.sig = String(object.sig);
              if (object.sigAlgorithm != null)
                  message.sigAlgorithm = String(object.sigAlgorithm);
              if (object.phloPrice != null)
                  if ($util.Long)
                      (message.phloPrice = $util.Long.fromValue(object.phloPrice)).unsigned = false;
                  else if (typeof object.phloPrice === "string")
                      message.phloPrice = parseInt(object.phloPrice, 10);
                  else if (typeof object.phloPrice === "number")
                      message.phloPrice = object.phloPrice;
                  else if (typeof object.phloPrice === "object")
                      message.phloPrice = new $util.LongBits(object.phloPrice.low >>> 0, object.phloPrice.high >>> 0).toNumber();
              if (object.phloLimit != null)
                  if ($util.Long)
                      (message.phloLimit = $util.Long.fromValue(object.phloLimit)).unsigned = false;
                  else if (typeof object.phloLimit === "string")
                      message.phloLimit = parseInt(object.phloLimit, 10);
                  else if (typeof object.phloLimit === "number")
                      message.phloLimit = object.phloLimit;
                  else if (typeof object.phloLimit === "object")
                      message.phloLimit = new $util.LongBits(object.phloLimit.low >>> 0, object.phloLimit.high >>> 0).toNumber();
              if (object.validAfterBlockNumber != null)
                  if ($util.Long)
                      (message.validAfterBlockNumber = $util.Long.fromValue(object.validAfterBlockNumber)).unsigned = false;
                  else if (typeof object.validAfterBlockNumber === "string")
                      message.validAfterBlockNumber = parseInt(object.validAfterBlockNumber, 10);
                  else if (typeof object.validAfterBlockNumber === "number")
                      message.validAfterBlockNumber = object.validAfterBlockNumber;
                  else if (typeof object.validAfterBlockNumber === "object")
                      message.validAfterBlockNumber = new $util.LongBits(object.validAfterBlockNumber.low >>> 0, object.validAfterBlockNumber.high >>> 0).toNumber();
              if (object.cost != null)
                  if ($util.Long)
                      (message.cost = $util.Long.fromValue(object.cost)).unsigned = true;
                  else if (typeof object.cost === "string")
                      message.cost = parseInt(object.cost, 10);
                  else if (typeof object.cost === "number")
                      message.cost = object.cost;
                  else if (typeof object.cost === "object")
                      message.cost = new $util.LongBits(object.cost.low >>> 0, object.cost.high >>> 0).toNumber(true);
              if (object.errored != null)
                  message.errored = Boolean(object.errored);
              if (object.systemDeployError != null)
                  message.systemDeployError = String(object.systemDeployError);
              return message;
          };

          /**
           * Creates a plain object from a DeployInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.DeployInfo
           * @static
           * @param {casper.DeployInfo} message DeployInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DeployInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.deployer = "";
                  object.term = "";
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.timestamp = options.longs === String ? "0" : 0;
                  object.sig = "";
                  object.sigAlgorithm = "";
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.phloPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.phloPrice = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.phloLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.phloLimit = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.validAfterBlockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.validAfterBlockNumber = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, true);
                      object.cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.cost = options.longs === String ? "0" : 0;
                  object.errored = false;
                  object.systemDeployError = "";
              }
              if (message.deployer != null && message.hasOwnProperty("deployer"))
                  object.deployer = message.deployer;
              if (message.term != null && message.hasOwnProperty("term"))
                  object.term = message.term;
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (typeof message.timestamp === "number")
                      object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                  else
                      object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
              if (message.sig != null && message.hasOwnProperty("sig"))
                  object.sig = message.sig;
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  object.sigAlgorithm = message.sigAlgorithm;
              if (message.phloPrice != null && message.hasOwnProperty("phloPrice"))
                  if (typeof message.phloPrice === "number")
                      object.phloPrice = options.longs === String ? String(message.phloPrice) : message.phloPrice;
                  else
                      object.phloPrice = options.longs === String ? $util.Long.prototype.toString.call(message.phloPrice) : options.longs === Number ? new $util.LongBits(message.phloPrice.low >>> 0, message.phloPrice.high >>> 0).toNumber() : message.phloPrice;
              if (message.phloLimit != null && message.hasOwnProperty("phloLimit"))
                  if (typeof message.phloLimit === "number")
                      object.phloLimit = options.longs === String ? String(message.phloLimit) : message.phloLimit;
                  else
                      object.phloLimit = options.longs === String ? $util.Long.prototype.toString.call(message.phloLimit) : options.longs === Number ? new $util.LongBits(message.phloLimit.low >>> 0, message.phloLimit.high >>> 0).toNumber() : message.phloLimit;
              if (message.validAfterBlockNumber != null && message.hasOwnProperty("validAfterBlockNumber"))
                  if (typeof message.validAfterBlockNumber === "number")
                      object.validAfterBlockNumber = options.longs === String ? String(message.validAfterBlockNumber) : message.validAfterBlockNumber;
                  else
                      object.validAfterBlockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.validAfterBlockNumber) : options.longs === Number ? new $util.LongBits(message.validAfterBlockNumber.low >>> 0, message.validAfterBlockNumber.high >>> 0).toNumber() : message.validAfterBlockNumber;
              if (message.cost != null && message.hasOwnProperty("cost"))
                  if (typeof message.cost === "number")
                      object.cost = options.longs === String ? String(message.cost) : message.cost;
                  else
                      object.cost = options.longs === String ? $util.Long.prototype.toString.call(message.cost) : options.longs === Number ? new $util.LongBits(message.cost.low >>> 0, message.cost.high >>> 0).toNumber(true) : message.cost;
              if (message.errored != null && message.hasOwnProperty("errored"))
                  object.errored = message.errored;
              if (message.systemDeployError != null && message.hasOwnProperty("systemDeployError"))
                  object.systemDeployError = message.systemDeployError;
              return object;
          };

          /**
           * Converts this DeployInfo to JSON.
           * @function toJSON
           * @memberof casper.DeployInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DeployInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return DeployInfo;
      })();

      casper.LightBlockInfo = (function() {

          /**
           * Properties of a LightBlockInfo.
           * @memberof casper
           * @interface ILightBlockInfo
           * @property {string|null} [blockHash] LightBlockInfo blockHash
           * @property {string|null} [sender] LightBlockInfo sender
           * @property {number|Long|null} [seqNum] LightBlockInfo seqNum
           * @property {string|null} [sig] LightBlockInfo sig
           * @property {string|null} [sigAlgorithm] LightBlockInfo sigAlgorithm
           * @property {string|null} [shardId] LightBlockInfo shardId
           * @property {Uint8Array|null} [extraBytes] LightBlockInfo extraBytes
           * @property {number|Long|null} [version] LightBlockInfo version
           * @property {number|Long|null} [timestamp] LightBlockInfo timestamp
           * @property {Uint8Array|null} [headerExtraBytes] LightBlockInfo headerExtraBytes
           * @property {Array.<string>|null} [parentsHashList] LightBlockInfo parentsHashList
           * @property {number|Long|null} [blockNumber] LightBlockInfo blockNumber
           * @property {string|null} [preStateHash] LightBlockInfo preStateHash
           * @property {string|null} [postStateHash] LightBlockInfo postStateHash
           * @property {Uint8Array|null} [bodyExtraBytes] LightBlockInfo bodyExtraBytes
           * @property {Array.<casper.IBondInfo>|null} [bonds] LightBlockInfo bonds
           * @property {string|null} [blockSize] LightBlockInfo blockSize
           * @property {number|null} [deployCount] LightBlockInfo deployCount
           * @property {number|null} [faultTolerance] LightBlockInfo faultTolerance
           * @property {Array.<casper.IJustificationInfo>|null} [justifications] LightBlockInfo justifications
           */

          /**
           * Constructs a new LightBlockInfo.
           * @memberof casper
           * @classdesc Represents a LightBlockInfo.
           * @implements ILightBlockInfo
           * @constructor
           * @param {casper.ILightBlockInfo=} [properties] Properties to set
           */
          function LightBlockInfo(properties) {
              this.parentsHashList = [];
              this.bonds = [];
              this.justifications = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * LightBlockInfo blockHash.
           * @member {string} blockHash
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.blockHash = "";

          /**
           * LightBlockInfo sender.
           * @member {string} sender
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.sender = "";

          /**
           * LightBlockInfo seqNum.
           * @member {number|Long} seqNum
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.seqNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * LightBlockInfo sig.
           * @member {string} sig
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.sig = "";

          /**
           * LightBlockInfo sigAlgorithm.
           * @member {string} sigAlgorithm
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.sigAlgorithm = "";

          /**
           * LightBlockInfo shardId.
           * @member {string} shardId
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.shardId = "";

          /**
           * LightBlockInfo extraBytes.
           * @member {Uint8Array} extraBytes
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.extraBytes = $util.newBuffer([]);

          /**
           * LightBlockInfo version.
           * @member {number|Long} version
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * LightBlockInfo timestamp.
           * @member {number|Long} timestamp
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * LightBlockInfo headerExtraBytes.
           * @member {Uint8Array} headerExtraBytes
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.headerExtraBytes = $util.newBuffer([]);

          /**
           * LightBlockInfo parentsHashList.
           * @member {Array.<string>} parentsHashList
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.parentsHashList = $util.emptyArray;

          /**
           * LightBlockInfo blockNumber.
           * @member {number|Long} blockNumber
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * LightBlockInfo preStateHash.
           * @member {string} preStateHash
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.preStateHash = "";

          /**
           * LightBlockInfo postStateHash.
           * @member {string} postStateHash
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.postStateHash = "";

          /**
           * LightBlockInfo bodyExtraBytes.
           * @member {Uint8Array} bodyExtraBytes
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.bodyExtraBytes = $util.newBuffer([]);

          /**
           * LightBlockInfo bonds.
           * @member {Array.<casper.IBondInfo>} bonds
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.bonds = $util.emptyArray;

          /**
           * LightBlockInfo blockSize.
           * @member {string} blockSize
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.blockSize = "";

          /**
           * LightBlockInfo deployCount.
           * @member {number} deployCount
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.deployCount = 0;

          /**
           * LightBlockInfo faultTolerance.
           * @member {number} faultTolerance
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.faultTolerance = 0;

          /**
           * LightBlockInfo justifications.
           * @member {Array.<casper.IJustificationInfo>} justifications
           * @memberof casper.LightBlockInfo
           * @instance
           */
          LightBlockInfo.prototype.justifications = $util.emptyArray;

          /**
           * Creates a new LightBlockInfo instance using the specified properties.
           * @function create
           * @memberof casper.LightBlockInfo
           * @static
           * @param {casper.ILightBlockInfo=} [properties] Properties to set
           * @returns {casper.LightBlockInfo} LightBlockInfo instance
           */
          LightBlockInfo.create = function create(properties) {
              return new LightBlockInfo(properties);
          };

          /**
           * Encodes the specified LightBlockInfo message. Does not implicitly {@link casper.LightBlockInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.LightBlockInfo
           * @static
           * @param {casper.ILightBlockInfo} message LightBlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LightBlockInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockHash);
              if (message.sender != null && message.hasOwnProperty("sender"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender);
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  writer.uint32(/* id 3, wireType 0 =*/24).int64(message.seqNum);
              if (message.sig != null && message.hasOwnProperty("sig"))
                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.sig);
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  writer.uint32(/* id 5, wireType 2 =*/42).string(message.sigAlgorithm);
              if (message.shardId != null && message.hasOwnProperty("shardId"))
                  writer.uint32(/* id 6, wireType 2 =*/50).string(message.shardId);
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.extraBytes);
              if (message.version != null && message.hasOwnProperty("version"))
                  writer.uint32(/* id 8, wireType 0 =*/64).int64(message.version);
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timestamp);
              if (message.headerExtraBytes != null && message.hasOwnProperty("headerExtraBytes"))
                  writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.headerExtraBytes);
              if (message.parentsHashList != null && message.parentsHashList.length)
                  for (var i = 0; i < message.parentsHashList.length; ++i)
                      writer.uint32(/* id 11, wireType 2 =*/90).string(message.parentsHashList[i]);
              if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                  writer.uint32(/* id 12, wireType 0 =*/96).int64(message.blockNumber);
              if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                  writer.uint32(/* id 13, wireType 2 =*/106).string(message.preStateHash);
              if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                  writer.uint32(/* id 14, wireType 2 =*/114).string(message.postStateHash);
              if (message.bodyExtraBytes != null && message.hasOwnProperty("bodyExtraBytes"))
                  writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.bodyExtraBytes);
              if (message.bonds != null && message.bonds.length)
                  for (var i = 0; i < message.bonds.length; ++i)
                      $root.casper.BondInfo.encode(message.bonds[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
              if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                  writer.uint32(/* id 17, wireType 2 =*/138).string(message.blockSize);
              if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                  writer.uint32(/* id 18, wireType 0 =*/144).int32(message.deployCount);
              if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                  writer.uint32(/* id 19, wireType 5 =*/157).float(message.faultTolerance);
              if (message.justifications != null && message.justifications.length)
                  for (var i = 0; i < message.justifications.length; ++i)
                      $root.casper.JustificationInfo.encode(message.justifications[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified LightBlockInfo message, length delimited. Does not implicitly {@link casper.LightBlockInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.LightBlockInfo
           * @static
           * @param {casper.ILightBlockInfo} message LightBlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LightBlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a LightBlockInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.LightBlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.LightBlockInfo} LightBlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LightBlockInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.LightBlockInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.blockHash = reader.string();
                      break;
                  case 2:
                      message.sender = reader.string();
                      break;
                  case 3:
                      message.seqNum = reader.int64();
                      break;
                  case 4:
                      message.sig = reader.string();
                      break;
                  case 5:
                      message.sigAlgorithm = reader.string();
                      break;
                  case 6:
                      message.shardId = reader.string();
                      break;
                  case 7:
                      message.extraBytes = reader.bytes();
                      break;
                  case 8:
                      message.version = reader.int64();
                      break;
                  case 9:
                      message.timestamp = reader.int64();
                      break;
                  case 10:
                      message.headerExtraBytes = reader.bytes();
                      break;
                  case 11:
                      if (!(message.parentsHashList && message.parentsHashList.length))
                          message.parentsHashList = [];
                      message.parentsHashList.push(reader.string());
                      break;
                  case 12:
                      message.blockNumber = reader.int64();
                      break;
                  case 13:
                      message.preStateHash = reader.string();
                      break;
                  case 14:
                      message.postStateHash = reader.string();
                      break;
                  case 15:
                      message.bodyExtraBytes = reader.bytes();
                      break;
                  case 16:
                      if (!(message.bonds && message.bonds.length))
                          message.bonds = [];
                      message.bonds.push($root.casper.BondInfo.decode(reader, reader.uint32()));
                      break;
                  case 17:
                      message.blockSize = reader.string();
                      break;
                  case 18:
                      message.deployCount = reader.int32();
                      break;
                  case 19:
                      message.faultTolerance = reader.float();
                      break;
                  case 20:
                      if (!(message.justifications && message.justifications.length))
                          message.justifications = [];
                      message.justifications.push($root.casper.JustificationInfo.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a LightBlockInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.LightBlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.LightBlockInfo} LightBlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LightBlockInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a LightBlockInfo message.
           * @function verify
           * @memberof casper.LightBlockInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          LightBlockInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  if (!$util.isString(message.blockHash))
                      return "blockHash: string expected";
              if (message.sender != null && message.hasOwnProperty("sender"))
                  if (!$util.isString(message.sender))
                      return "sender: string expected";
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  if (!$util.isInteger(message.seqNum) && !(message.seqNum && $util.isInteger(message.seqNum.low) && $util.isInteger(message.seqNum.high)))
                      return "seqNum: integer|Long expected";
              if (message.sig != null && message.hasOwnProperty("sig"))
                  if (!$util.isString(message.sig))
                      return "sig: string expected";
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  if (!$util.isString(message.sigAlgorithm))
                      return "sigAlgorithm: string expected";
              if (message.shardId != null && message.hasOwnProperty("shardId"))
                  if (!$util.isString(message.shardId))
                      return "shardId: string expected";
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  if (!(message.extraBytes && typeof message.extraBytes.length === "number" || $util.isString(message.extraBytes)))
                      return "extraBytes: buffer expected";
              if (message.version != null && message.hasOwnProperty("version"))
                  if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                      return "version: integer|Long expected";
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                      return "timestamp: integer|Long expected";
              if (message.headerExtraBytes != null && message.hasOwnProperty("headerExtraBytes"))
                  if (!(message.headerExtraBytes && typeof message.headerExtraBytes.length === "number" || $util.isString(message.headerExtraBytes)))
                      return "headerExtraBytes: buffer expected";
              if (message.parentsHashList != null && message.hasOwnProperty("parentsHashList")) {
                  if (!Array.isArray(message.parentsHashList))
                      return "parentsHashList: array expected";
                  for (var i = 0; i < message.parentsHashList.length; ++i)
                      if (!$util.isString(message.parentsHashList[i]))
                          return "parentsHashList: string[] expected";
              }
              if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                  if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                      return "blockNumber: integer|Long expected";
              if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                  if (!$util.isString(message.preStateHash))
                      return "preStateHash: string expected";
              if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                  if (!$util.isString(message.postStateHash))
                      return "postStateHash: string expected";
              if (message.bodyExtraBytes != null && message.hasOwnProperty("bodyExtraBytes"))
                  if (!(message.bodyExtraBytes && typeof message.bodyExtraBytes.length === "number" || $util.isString(message.bodyExtraBytes)))
                      return "bodyExtraBytes: buffer expected";
              if (message.bonds != null && message.hasOwnProperty("bonds")) {
                  if (!Array.isArray(message.bonds))
                      return "bonds: array expected";
                  for (var i = 0; i < message.bonds.length; ++i) {
                      var error = $root.casper.BondInfo.verify(message.bonds[i]);
                      if (error)
                          return "bonds." + error;
                  }
              }
              if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                  if (!$util.isString(message.blockSize))
                      return "blockSize: string expected";
              if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                  if (!$util.isInteger(message.deployCount))
                      return "deployCount: integer expected";
              if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                  if (typeof message.faultTolerance !== "number")
                      return "faultTolerance: number expected";
              if (message.justifications != null && message.hasOwnProperty("justifications")) {
                  if (!Array.isArray(message.justifications))
                      return "justifications: array expected";
                  for (var i = 0; i < message.justifications.length; ++i) {
                      var error = $root.casper.JustificationInfo.verify(message.justifications[i]);
                      if (error)
                          return "justifications." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a LightBlockInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.LightBlockInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.LightBlockInfo} LightBlockInfo
           */
          LightBlockInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.LightBlockInfo)
                  return object;
              var message = new $root.casper.LightBlockInfo();
              if (object.blockHash != null)
                  message.blockHash = String(object.blockHash);
              if (object.sender != null)
                  message.sender = String(object.sender);
              if (object.seqNum != null)
                  if ($util.Long)
                      (message.seqNum = $util.Long.fromValue(object.seqNum)).unsigned = false;
                  else if (typeof object.seqNum === "string")
                      message.seqNum = parseInt(object.seqNum, 10);
                  else if (typeof object.seqNum === "number")
                      message.seqNum = object.seqNum;
                  else if (typeof object.seqNum === "object")
                      message.seqNum = new $util.LongBits(object.seqNum.low >>> 0, object.seqNum.high >>> 0).toNumber();
              if (object.sig != null)
                  message.sig = String(object.sig);
              if (object.sigAlgorithm != null)
                  message.sigAlgorithm = String(object.sigAlgorithm);
              if (object.shardId != null)
                  message.shardId = String(object.shardId);
              if (object.extraBytes != null)
                  if (typeof object.extraBytes === "string")
                      $util.base64.decode(object.extraBytes, message.extraBytes = $util.newBuffer($util.base64.length(object.extraBytes)), 0);
                  else if (object.extraBytes.length)
                      message.extraBytes = object.extraBytes;
              if (object.version != null)
                  if ($util.Long)
                      (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                  else if (typeof object.version === "string")
                      message.version = parseInt(object.version, 10);
                  else if (typeof object.version === "number")
                      message.version = object.version;
                  else if (typeof object.version === "object")
                      message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
              if (object.timestamp != null)
                  if ($util.Long)
                      (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                  else if (typeof object.timestamp === "string")
                      message.timestamp = parseInt(object.timestamp, 10);
                  else if (typeof object.timestamp === "number")
                      message.timestamp = object.timestamp;
                  else if (typeof object.timestamp === "object")
                      message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
              if (object.headerExtraBytes != null)
                  if (typeof object.headerExtraBytes === "string")
                      $util.base64.decode(object.headerExtraBytes, message.headerExtraBytes = $util.newBuffer($util.base64.length(object.headerExtraBytes)), 0);
                  else if (object.headerExtraBytes.length)
                      message.headerExtraBytes = object.headerExtraBytes;
              if (object.parentsHashList) {
                  if (!Array.isArray(object.parentsHashList))
                      throw TypeError(".casper.LightBlockInfo.parentsHashList: array expected");
                  message.parentsHashList = [];
                  for (var i = 0; i < object.parentsHashList.length; ++i)
                      message.parentsHashList[i] = String(object.parentsHashList[i]);
              }
              if (object.blockNumber != null)
                  if ($util.Long)
                      (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                  else if (typeof object.blockNumber === "string")
                      message.blockNumber = parseInt(object.blockNumber, 10);
                  else if (typeof object.blockNumber === "number")
                      message.blockNumber = object.blockNumber;
                  else if (typeof object.blockNumber === "object")
                      message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
              if (object.preStateHash != null)
                  message.preStateHash = String(object.preStateHash);
              if (object.postStateHash != null)
                  message.postStateHash = String(object.postStateHash);
              if (object.bodyExtraBytes != null)
                  if (typeof object.bodyExtraBytes === "string")
                      $util.base64.decode(object.bodyExtraBytes, message.bodyExtraBytes = $util.newBuffer($util.base64.length(object.bodyExtraBytes)), 0);
                  else if (object.bodyExtraBytes.length)
                      message.bodyExtraBytes = object.bodyExtraBytes;
              if (object.bonds) {
                  if (!Array.isArray(object.bonds))
                      throw TypeError(".casper.LightBlockInfo.bonds: array expected");
                  message.bonds = [];
                  for (var i = 0; i < object.bonds.length; ++i) {
                      if (typeof object.bonds[i] !== "object")
                          throw TypeError(".casper.LightBlockInfo.bonds: object expected");
                      message.bonds[i] = $root.casper.BondInfo.fromObject(object.bonds[i]);
                  }
              }
              if (object.blockSize != null)
                  message.blockSize = String(object.blockSize);
              if (object.deployCount != null)
                  message.deployCount = object.deployCount | 0;
              if (object.faultTolerance != null)
                  message.faultTolerance = Number(object.faultTolerance);
              if (object.justifications) {
                  if (!Array.isArray(object.justifications))
                      throw TypeError(".casper.LightBlockInfo.justifications: array expected");
                  message.justifications = [];
                  for (var i = 0; i < object.justifications.length; ++i) {
                      if (typeof object.justifications[i] !== "object")
                          throw TypeError(".casper.LightBlockInfo.justifications: object expected");
                      message.justifications[i] = $root.casper.JustificationInfo.fromObject(object.justifications[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a LightBlockInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.LightBlockInfo
           * @static
           * @param {casper.LightBlockInfo} message LightBlockInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          LightBlockInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object.parentsHashList = [];
                  object.bonds = [];
                  object.justifications = [];
              }
              if (options.defaults) {
                  object.blockHash = "";
                  object.sender = "";
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.seqNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.seqNum = options.longs === String ? "0" : 0;
                  object.sig = "";
                  object.sigAlgorithm = "";
                  object.shardId = "";
                  if (options.bytes === String)
                      object.extraBytes = "";
                  else {
                      object.extraBytes = [];
                      if (options.bytes !== Array)
                          object.extraBytes = $util.newBuffer(object.extraBytes);
                  }
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.version = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.timestamp = options.longs === String ? "0" : 0;
                  if (options.bytes === String)
                      object.headerExtraBytes = "";
                  else {
                      object.headerExtraBytes = [];
                      if (options.bytes !== Array)
                          object.headerExtraBytes = $util.newBuffer(object.headerExtraBytes);
                  }
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.blockNumber = options.longs === String ? "0" : 0;
                  object.preStateHash = "";
                  object.postStateHash = "";
                  if (options.bytes === String)
                      object.bodyExtraBytes = "";
                  else {
                      object.bodyExtraBytes = [];
                      if (options.bytes !== Array)
                          object.bodyExtraBytes = $util.newBuffer(object.bodyExtraBytes);
                  }
                  object.blockSize = "";
                  object.deployCount = 0;
                  object.faultTolerance = 0;
              }
              if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                  object.blockHash = message.blockHash;
              if (message.sender != null && message.hasOwnProperty("sender"))
                  object.sender = message.sender;
              if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                  if (typeof message.seqNum === "number")
                      object.seqNum = options.longs === String ? String(message.seqNum) : message.seqNum;
                  else
                      object.seqNum = options.longs === String ? $util.Long.prototype.toString.call(message.seqNum) : options.longs === Number ? new $util.LongBits(message.seqNum.low >>> 0, message.seqNum.high >>> 0).toNumber() : message.seqNum;
              if (message.sig != null && message.hasOwnProperty("sig"))
                  object.sig = message.sig;
              if (message.sigAlgorithm != null && message.hasOwnProperty("sigAlgorithm"))
                  object.sigAlgorithm = message.sigAlgorithm;
              if (message.shardId != null && message.hasOwnProperty("shardId"))
                  object.shardId = message.shardId;
              if (message.extraBytes != null && message.hasOwnProperty("extraBytes"))
                  object.extraBytes = options.bytes === String ? $util.base64.encode(message.extraBytes, 0, message.extraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.extraBytes) : message.extraBytes;
              if (message.version != null && message.hasOwnProperty("version"))
                  if (typeof message.version === "number")
                      object.version = options.longs === String ? String(message.version) : message.version;
                  else
                      object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
              if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                  if (typeof message.timestamp === "number")
                      object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                  else
                      object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
              if (message.headerExtraBytes != null && message.hasOwnProperty("headerExtraBytes"))
                  object.headerExtraBytes = options.bytes === String ? $util.base64.encode(message.headerExtraBytes, 0, message.headerExtraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.headerExtraBytes) : message.headerExtraBytes;
              if (message.parentsHashList && message.parentsHashList.length) {
                  object.parentsHashList = [];
                  for (var j = 0; j < message.parentsHashList.length; ++j)
                      object.parentsHashList[j] = message.parentsHashList[j];
              }
              if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                  if (typeof message.blockNumber === "number")
                      object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                  else
                      object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
              if (message.preStateHash != null && message.hasOwnProperty("preStateHash"))
                  object.preStateHash = message.preStateHash;
              if (message.postStateHash != null && message.hasOwnProperty("postStateHash"))
                  object.postStateHash = message.postStateHash;
              if (message.bodyExtraBytes != null && message.hasOwnProperty("bodyExtraBytes"))
                  object.bodyExtraBytes = options.bytes === String ? $util.base64.encode(message.bodyExtraBytes, 0, message.bodyExtraBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bodyExtraBytes) : message.bodyExtraBytes;
              if (message.bonds && message.bonds.length) {
                  object.bonds = [];
                  for (var j = 0; j < message.bonds.length; ++j)
                      object.bonds[j] = $root.casper.BondInfo.toObject(message.bonds[j], options);
              }
              if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                  object.blockSize = message.blockSize;
              if (message.deployCount != null && message.hasOwnProperty("deployCount"))
                  object.deployCount = message.deployCount;
              if (message.faultTolerance != null && message.hasOwnProperty("faultTolerance"))
                  object.faultTolerance = options.json && !isFinite(message.faultTolerance) ? String(message.faultTolerance) : message.faultTolerance;
              if (message.justifications && message.justifications.length) {
                  object.justifications = [];
                  for (var j = 0; j < message.justifications.length; ++j)
                      object.justifications[j] = $root.casper.JustificationInfo.toObject(message.justifications[j], options);
              }
              return object;
          };

          /**
           * Converts this LightBlockInfo to JSON.
           * @function toJSON
           * @memberof casper.LightBlockInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          LightBlockInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return LightBlockInfo;
      })();

      casper.BlockInfo = (function() {

          /**
           * Properties of a BlockInfo.
           * @memberof casper
           * @interface IBlockInfo
           * @property {casper.ILightBlockInfo|null} [blockInfo] BlockInfo blockInfo
           * @property {Array.<casper.IDeployInfo>|null} [deploys] BlockInfo deploys
           */

          /**
           * Constructs a new BlockInfo.
           * @memberof casper
           * @classdesc Represents a BlockInfo.
           * @implements IBlockInfo
           * @constructor
           * @param {casper.IBlockInfo=} [properties] Properties to set
           */
          function BlockInfo(properties) {
              this.deploys = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockInfo blockInfo.
           * @member {casper.ILightBlockInfo|null|undefined} blockInfo
           * @memberof casper.BlockInfo
           * @instance
           */
          BlockInfo.prototype.blockInfo = null;

          /**
           * BlockInfo deploys.
           * @member {Array.<casper.IDeployInfo>} deploys
           * @memberof casper.BlockInfo
           * @instance
           */
          BlockInfo.prototype.deploys = $util.emptyArray;

          /**
           * Creates a new BlockInfo instance using the specified properties.
           * @function create
           * @memberof casper.BlockInfo
           * @static
           * @param {casper.IBlockInfo=} [properties] Properties to set
           * @returns {casper.BlockInfo} BlockInfo instance
           */
          BlockInfo.create = function create(properties) {
              return new BlockInfo(properties);
          };

          /**
           * Encodes the specified BlockInfo message. Does not implicitly {@link casper.BlockInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockInfo
           * @static
           * @param {casper.IBlockInfo} message BlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                  $root.casper.LightBlockInfo.encode(message.blockInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.deploys != null && message.deploys.length)
                  for (var i = 0; i < message.deploys.length; ++i)
                      $root.casper.DeployInfo.encode(message.deploys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified BlockInfo message, length delimited. Does not implicitly {@link casper.BlockInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockInfo
           * @static
           * @param {casper.IBlockInfo} message BlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockInfo} BlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.blockInfo = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.deploys && message.deploys.length))
                          message.deploys = [];
                      message.deploys.push($root.casper.DeployInfo.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockInfo} BlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockInfo message.
           * @function verify
           * @memberof casper.BlockInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                  var error = $root.casper.LightBlockInfo.verify(message.blockInfo);
                  if (error)
                      return "blockInfo." + error;
              }
              if (message.deploys != null && message.hasOwnProperty("deploys")) {
                  if (!Array.isArray(message.deploys))
                      return "deploys: array expected";
                  for (var i = 0; i < message.deploys.length; ++i) {
                      var error = $root.casper.DeployInfo.verify(message.deploys[i]);
                      if (error)
                          return "deploys." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a BlockInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockInfo} BlockInfo
           */
          BlockInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockInfo)
                  return object;
              var message = new $root.casper.BlockInfo();
              if (object.blockInfo != null) {
                  if (typeof object.blockInfo !== "object")
                      throw TypeError(".casper.BlockInfo.blockInfo: object expected");
                  message.blockInfo = $root.casper.LightBlockInfo.fromObject(object.blockInfo);
              }
              if (object.deploys) {
                  if (!Array.isArray(object.deploys))
                      throw TypeError(".casper.BlockInfo.deploys: array expected");
                  message.deploys = [];
                  for (var i = 0; i < object.deploys.length; ++i) {
                      if (typeof object.deploys[i] !== "object")
                          throw TypeError(".casper.BlockInfo.deploys: object expected");
                      message.deploys[i] = $root.casper.DeployInfo.fromObject(object.deploys[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a BlockInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockInfo
           * @static
           * @param {casper.BlockInfo} message BlockInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.deploys = [];
              if (options.defaults)
                  object.blockInfo = null;
              if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                  object.blockInfo = $root.casper.LightBlockInfo.toObject(message.blockInfo, options);
              if (message.deploys && message.deploys.length) {
                  object.deploys = [];
                  for (var j = 0; j < message.deploys.length; ++j)
                      object.deploys[j] = $root.casper.DeployInfo.toObject(message.deploys[j], options);
              }
              return object;
          };

          /**
           * Converts this BlockInfo to JSON.
           * @function toJSON
           * @memberof casper.BlockInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockInfo;
      })();

      casper.DataWithBlockInfo = (function() {

          /**
           * Properties of a DataWithBlockInfo.
           * @memberof casper
           * @interface IDataWithBlockInfo
           * @property {Array.<IPar>|null} [postBlockData] DataWithBlockInfo postBlockData
           * @property {casper.ILightBlockInfo|null} [block] DataWithBlockInfo block
           */

          /**
           * Constructs a new DataWithBlockInfo.
           * @memberof casper
           * @classdesc Represents a DataWithBlockInfo.
           * @implements IDataWithBlockInfo
           * @constructor
           * @param {casper.IDataWithBlockInfo=} [properties] Properties to set
           */
          function DataWithBlockInfo(properties) {
              this.postBlockData = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * DataWithBlockInfo postBlockData.
           * @member {Array.<IPar>} postBlockData
           * @memberof casper.DataWithBlockInfo
           * @instance
           */
          DataWithBlockInfo.prototype.postBlockData = $util.emptyArray;

          /**
           * DataWithBlockInfo block.
           * @member {casper.ILightBlockInfo|null|undefined} block
           * @memberof casper.DataWithBlockInfo
           * @instance
           */
          DataWithBlockInfo.prototype.block = null;

          /**
           * Creates a new DataWithBlockInfo instance using the specified properties.
           * @function create
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {casper.IDataWithBlockInfo=} [properties] Properties to set
           * @returns {casper.DataWithBlockInfo} DataWithBlockInfo instance
           */
          DataWithBlockInfo.create = function create(properties) {
              return new DataWithBlockInfo(properties);
          };

          /**
           * Encodes the specified DataWithBlockInfo message. Does not implicitly {@link casper.DataWithBlockInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {casper.IDataWithBlockInfo} message DataWithBlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DataWithBlockInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.postBlockData != null && message.postBlockData.length)
                  for (var i = 0; i < message.postBlockData.length; ++i)
                      $root.Par.encode(message.postBlockData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.block != null && message.hasOwnProperty("block"))
                  $root.casper.LightBlockInfo.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified DataWithBlockInfo message, length delimited. Does not implicitly {@link casper.DataWithBlockInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {casper.IDataWithBlockInfo} message DataWithBlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DataWithBlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DataWithBlockInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.DataWithBlockInfo} DataWithBlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DataWithBlockInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DataWithBlockInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.postBlockData && message.postBlockData.length))
                          message.postBlockData = [];
                      message.postBlockData.push($root.Par.decode(reader, reader.uint32()));
                      break;
                  case 2:
                      message.block = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a DataWithBlockInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.DataWithBlockInfo} DataWithBlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DataWithBlockInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DataWithBlockInfo message.
           * @function verify
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DataWithBlockInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.postBlockData != null && message.hasOwnProperty("postBlockData")) {
                  if (!Array.isArray(message.postBlockData))
                      return "postBlockData: array expected";
                  for (var i = 0; i < message.postBlockData.length; ++i) {
                      var error = $root.Par.verify(message.postBlockData[i]);
                      if (error)
                          return "postBlockData." + error;
                  }
              }
              if (message.block != null && message.hasOwnProperty("block")) {
                  var error = $root.casper.LightBlockInfo.verify(message.block);
                  if (error)
                      return "block." + error;
              }
              return null;
          };

          /**
           * Creates a DataWithBlockInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.DataWithBlockInfo} DataWithBlockInfo
           */
          DataWithBlockInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.DataWithBlockInfo)
                  return object;
              var message = new $root.casper.DataWithBlockInfo();
              if (object.postBlockData) {
                  if (!Array.isArray(object.postBlockData))
                      throw TypeError(".casper.DataWithBlockInfo.postBlockData: array expected");
                  message.postBlockData = [];
                  for (var i = 0; i < object.postBlockData.length; ++i) {
                      if (typeof object.postBlockData[i] !== "object")
                          throw TypeError(".casper.DataWithBlockInfo.postBlockData: object expected");
                      message.postBlockData[i] = $root.Par.fromObject(object.postBlockData[i]);
                  }
              }
              if (object.block != null) {
                  if (typeof object.block !== "object")
                      throw TypeError(".casper.DataWithBlockInfo.block: object expected");
                  message.block = $root.casper.LightBlockInfo.fromObject(object.block);
              }
              return message;
          };

          /**
           * Creates a plain object from a DataWithBlockInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.DataWithBlockInfo
           * @static
           * @param {casper.DataWithBlockInfo} message DataWithBlockInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DataWithBlockInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.postBlockData = [];
              if (options.defaults)
                  object.block = null;
              if (message.postBlockData && message.postBlockData.length) {
                  object.postBlockData = [];
                  for (var j = 0; j < message.postBlockData.length; ++j)
                      object.postBlockData[j] = $root.Par.toObject(message.postBlockData[j], options);
              }
              if (message.block != null && message.hasOwnProperty("block"))
                  object.block = $root.casper.LightBlockInfo.toObject(message.block, options);
              return object;
          };

          /**
           * Converts this DataWithBlockInfo to JSON.
           * @function toJSON
           * @memberof casper.DataWithBlockInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DataWithBlockInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return DataWithBlockInfo;
      })();

      casper.ContinuationsWithBlockInfo = (function() {

          /**
           * Properties of a ContinuationsWithBlockInfo.
           * @memberof casper
           * @interface IContinuationsWithBlockInfo
           * @property {Array.<casper.IWaitingContinuationInfo>|null} [postBlockContinuations] ContinuationsWithBlockInfo postBlockContinuations
           * @property {casper.ILightBlockInfo|null} [block] ContinuationsWithBlockInfo block
           */

          /**
           * Constructs a new ContinuationsWithBlockInfo.
           * @memberof casper
           * @classdesc Represents a ContinuationsWithBlockInfo.
           * @implements IContinuationsWithBlockInfo
           * @constructor
           * @param {casper.IContinuationsWithBlockInfo=} [properties] Properties to set
           */
          function ContinuationsWithBlockInfo(properties) {
              this.postBlockContinuations = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ContinuationsWithBlockInfo postBlockContinuations.
           * @member {Array.<casper.IWaitingContinuationInfo>} postBlockContinuations
           * @memberof casper.ContinuationsWithBlockInfo
           * @instance
           */
          ContinuationsWithBlockInfo.prototype.postBlockContinuations = $util.emptyArray;

          /**
           * ContinuationsWithBlockInfo block.
           * @member {casper.ILightBlockInfo|null|undefined} block
           * @memberof casper.ContinuationsWithBlockInfo
           * @instance
           */
          ContinuationsWithBlockInfo.prototype.block = null;

          /**
           * Creates a new ContinuationsWithBlockInfo instance using the specified properties.
           * @function create
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {casper.IContinuationsWithBlockInfo=} [properties] Properties to set
           * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo instance
           */
          ContinuationsWithBlockInfo.create = function create(properties) {
              return new ContinuationsWithBlockInfo(properties);
          };

          /**
           * Encodes the specified ContinuationsWithBlockInfo message. Does not implicitly {@link casper.ContinuationsWithBlockInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {casper.IContinuationsWithBlockInfo} message ContinuationsWithBlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ContinuationsWithBlockInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.postBlockContinuations != null && message.postBlockContinuations.length)
                  for (var i = 0; i < message.postBlockContinuations.length; ++i)
                      $root.casper.WaitingContinuationInfo.encode(message.postBlockContinuations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.block != null && message.hasOwnProperty("block"))
                  $root.casper.LightBlockInfo.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ContinuationsWithBlockInfo message, length delimited. Does not implicitly {@link casper.ContinuationsWithBlockInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {casper.IContinuationsWithBlockInfo} message ContinuationsWithBlockInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ContinuationsWithBlockInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ContinuationsWithBlockInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ContinuationsWithBlockInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ContinuationsWithBlockInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.postBlockContinuations && message.postBlockContinuations.length))
                          message.postBlockContinuations = [];
                      message.postBlockContinuations.push($root.casper.WaitingContinuationInfo.decode(reader, reader.uint32()));
                      break;
                  case 2:
                      message.block = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ContinuationsWithBlockInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ContinuationsWithBlockInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ContinuationsWithBlockInfo message.
           * @function verify
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ContinuationsWithBlockInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.postBlockContinuations != null && message.hasOwnProperty("postBlockContinuations")) {
                  if (!Array.isArray(message.postBlockContinuations))
                      return "postBlockContinuations: array expected";
                  for (var i = 0; i < message.postBlockContinuations.length; ++i) {
                      var error = $root.casper.WaitingContinuationInfo.verify(message.postBlockContinuations[i]);
                      if (error)
                          return "postBlockContinuations." + error;
                  }
              }
              if (message.block != null && message.hasOwnProperty("block")) {
                  var error = $root.casper.LightBlockInfo.verify(message.block);
                  if (error)
                      return "block." + error;
              }
              return null;
          };

          /**
           * Creates a ContinuationsWithBlockInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ContinuationsWithBlockInfo} ContinuationsWithBlockInfo
           */
          ContinuationsWithBlockInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ContinuationsWithBlockInfo)
                  return object;
              var message = new $root.casper.ContinuationsWithBlockInfo();
              if (object.postBlockContinuations) {
                  if (!Array.isArray(object.postBlockContinuations))
                      throw TypeError(".casper.ContinuationsWithBlockInfo.postBlockContinuations: array expected");
                  message.postBlockContinuations = [];
                  for (var i = 0; i < object.postBlockContinuations.length; ++i) {
                      if (typeof object.postBlockContinuations[i] !== "object")
                          throw TypeError(".casper.ContinuationsWithBlockInfo.postBlockContinuations: object expected");
                      message.postBlockContinuations[i] = $root.casper.WaitingContinuationInfo.fromObject(object.postBlockContinuations[i]);
                  }
              }
              if (object.block != null) {
                  if (typeof object.block !== "object")
                      throw TypeError(".casper.ContinuationsWithBlockInfo.block: object expected");
                  message.block = $root.casper.LightBlockInfo.fromObject(object.block);
              }
              return message;
          };

          /**
           * Creates a plain object from a ContinuationsWithBlockInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ContinuationsWithBlockInfo
           * @static
           * @param {casper.ContinuationsWithBlockInfo} message ContinuationsWithBlockInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ContinuationsWithBlockInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.postBlockContinuations = [];
              if (options.defaults)
                  object.block = null;
              if (message.postBlockContinuations && message.postBlockContinuations.length) {
                  object.postBlockContinuations = [];
                  for (var j = 0; j < message.postBlockContinuations.length; ++j)
                      object.postBlockContinuations[j] = $root.casper.WaitingContinuationInfo.toObject(message.postBlockContinuations[j], options);
              }
              if (message.block != null && message.hasOwnProperty("block"))
                  object.block = $root.casper.LightBlockInfo.toObject(message.block, options);
              return object;
          };

          /**
           * Converts this ContinuationsWithBlockInfo to JSON.
           * @function toJSON
           * @memberof casper.ContinuationsWithBlockInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ContinuationsWithBlockInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ContinuationsWithBlockInfo;
      })();

      casper.WaitingContinuationInfo = (function() {

          /**
           * Properties of a WaitingContinuationInfo.
           * @memberof casper
           * @interface IWaitingContinuationInfo
           * @property {Array.<IBindPattern>|null} [postBlockPatterns] WaitingContinuationInfo postBlockPatterns
           * @property {IPar|null} [postBlockContinuation] WaitingContinuationInfo postBlockContinuation
           */

          /**
           * Constructs a new WaitingContinuationInfo.
           * @memberof casper
           * @classdesc Represents a WaitingContinuationInfo.
           * @implements IWaitingContinuationInfo
           * @constructor
           * @param {casper.IWaitingContinuationInfo=} [properties] Properties to set
           */
          function WaitingContinuationInfo(properties) {
              this.postBlockPatterns = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * WaitingContinuationInfo postBlockPatterns.
           * @member {Array.<IBindPattern>} postBlockPatterns
           * @memberof casper.WaitingContinuationInfo
           * @instance
           */
          WaitingContinuationInfo.prototype.postBlockPatterns = $util.emptyArray;

          /**
           * WaitingContinuationInfo postBlockContinuation.
           * @member {IPar|null|undefined} postBlockContinuation
           * @memberof casper.WaitingContinuationInfo
           * @instance
           */
          WaitingContinuationInfo.prototype.postBlockContinuation = null;

          /**
           * Creates a new WaitingContinuationInfo instance using the specified properties.
           * @function create
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {casper.IWaitingContinuationInfo=} [properties] Properties to set
           * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo instance
           */
          WaitingContinuationInfo.create = function create(properties) {
              return new WaitingContinuationInfo(properties);
          };

          /**
           * Encodes the specified WaitingContinuationInfo message. Does not implicitly {@link casper.WaitingContinuationInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {casper.IWaitingContinuationInfo} message WaitingContinuationInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          WaitingContinuationInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.postBlockPatterns != null && message.postBlockPatterns.length)
                  for (var i = 0; i < message.postBlockPatterns.length; ++i)
                      $root.BindPattern.encode(message.postBlockPatterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.postBlockContinuation != null && message.hasOwnProperty("postBlockContinuation"))
                  $root.Par.encode(message.postBlockContinuation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified WaitingContinuationInfo message, length delimited. Does not implicitly {@link casper.WaitingContinuationInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {casper.IWaitingContinuationInfo} message WaitingContinuationInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          WaitingContinuationInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a WaitingContinuationInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          WaitingContinuationInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.WaitingContinuationInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.postBlockPatterns && message.postBlockPatterns.length))
                          message.postBlockPatterns = [];
                      message.postBlockPatterns.push($root.BindPattern.decode(reader, reader.uint32()));
                      break;
                  case 2:
                      message.postBlockContinuation = $root.Par.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a WaitingContinuationInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          WaitingContinuationInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a WaitingContinuationInfo message.
           * @function verify
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          WaitingContinuationInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.postBlockPatterns != null && message.hasOwnProperty("postBlockPatterns")) {
                  if (!Array.isArray(message.postBlockPatterns))
                      return "postBlockPatterns: array expected";
                  for (var i = 0; i < message.postBlockPatterns.length; ++i) {
                      var error = $root.BindPattern.verify(message.postBlockPatterns[i]);
                      if (error)
                          return "postBlockPatterns." + error;
                  }
              }
              if (message.postBlockContinuation != null && message.hasOwnProperty("postBlockContinuation")) {
                  var error = $root.Par.verify(message.postBlockContinuation);
                  if (error)
                      return "postBlockContinuation." + error;
              }
              return null;
          };

          /**
           * Creates a WaitingContinuationInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.WaitingContinuationInfo} WaitingContinuationInfo
           */
          WaitingContinuationInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.WaitingContinuationInfo)
                  return object;
              var message = new $root.casper.WaitingContinuationInfo();
              if (object.postBlockPatterns) {
                  if (!Array.isArray(object.postBlockPatterns))
                      throw TypeError(".casper.WaitingContinuationInfo.postBlockPatterns: array expected");
                  message.postBlockPatterns = [];
                  for (var i = 0; i < object.postBlockPatterns.length; ++i) {
                      if (typeof object.postBlockPatterns[i] !== "object")
                          throw TypeError(".casper.WaitingContinuationInfo.postBlockPatterns: object expected");
                      message.postBlockPatterns[i] = $root.BindPattern.fromObject(object.postBlockPatterns[i]);
                  }
              }
              if (object.postBlockContinuation != null) {
                  if (typeof object.postBlockContinuation !== "object")
                      throw TypeError(".casper.WaitingContinuationInfo.postBlockContinuation: object expected");
                  message.postBlockContinuation = $root.Par.fromObject(object.postBlockContinuation);
              }
              return message;
          };

          /**
           * Creates a plain object from a WaitingContinuationInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.WaitingContinuationInfo
           * @static
           * @param {casper.WaitingContinuationInfo} message WaitingContinuationInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          WaitingContinuationInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.postBlockPatterns = [];
              if (options.defaults)
                  object.postBlockContinuation = null;
              if (message.postBlockPatterns && message.postBlockPatterns.length) {
                  object.postBlockPatterns = [];
                  for (var j = 0; j < message.postBlockPatterns.length; ++j)
                      object.postBlockPatterns[j] = $root.BindPattern.toObject(message.postBlockPatterns[j], options);
              }
              if (message.postBlockContinuation != null && message.hasOwnProperty("postBlockContinuation"))
                  object.postBlockContinuation = $root.Par.toObject(message.postBlockContinuation, options);
              return object;
          };

          /**
           * Converts this WaitingContinuationInfo to JSON.
           * @function toJSON
           * @memberof casper.WaitingContinuationInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          WaitingContinuationInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return WaitingContinuationInfo;
      })();

      casper.ReportProduceProto = (function() {

          /**
           * Properties of a ReportProduceProto.
           * @memberof casper
           * @interface IReportProduceProto
           * @property {IPar|null} [channel] ReportProduceProto channel
           * @property {IListParWithRandom|null} [data] ReportProduceProto data
           */

          /**
           * Constructs a new ReportProduceProto.
           * @memberof casper
           * @classdesc Represents a ReportProduceProto.
           * @implements IReportProduceProto
           * @constructor
           * @param {casper.IReportProduceProto=} [properties] Properties to set
           */
          function ReportProduceProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ReportProduceProto channel.
           * @member {IPar|null|undefined} channel
           * @memberof casper.ReportProduceProto
           * @instance
           */
          ReportProduceProto.prototype.channel = null;

          /**
           * ReportProduceProto data.
           * @member {IListParWithRandom|null|undefined} data
           * @memberof casper.ReportProduceProto
           * @instance
           */
          ReportProduceProto.prototype.data = null;

          /**
           * Creates a new ReportProduceProto instance using the specified properties.
           * @function create
           * @memberof casper.ReportProduceProto
           * @static
           * @param {casper.IReportProduceProto=} [properties] Properties to set
           * @returns {casper.ReportProduceProto} ReportProduceProto instance
           */
          ReportProduceProto.create = function create(properties) {
              return new ReportProduceProto(properties);
          };

          /**
           * Encodes the specified ReportProduceProto message. Does not implicitly {@link casper.ReportProduceProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ReportProduceProto
           * @static
           * @param {casper.IReportProduceProto} message ReportProduceProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportProduceProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.channel != null && message.hasOwnProperty("channel"))
                  $root.Par.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.data != null && message.hasOwnProperty("data"))
                  $root.ListParWithRandom.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ReportProduceProto message, length delimited. Does not implicitly {@link casper.ReportProduceProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ReportProduceProto
           * @static
           * @param {casper.IReportProduceProto} message ReportProduceProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportProduceProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ReportProduceProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ReportProduceProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ReportProduceProto} ReportProduceProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportProduceProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ReportProduceProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.channel = $root.Par.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.data = $root.ListParWithRandom.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ReportProduceProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ReportProduceProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ReportProduceProto} ReportProduceProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportProduceProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ReportProduceProto message.
           * @function verify
           * @memberof casper.ReportProduceProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ReportProduceProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.channel != null && message.hasOwnProperty("channel")) {
                  var error = $root.Par.verify(message.channel);
                  if (error)
                      return "channel." + error;
              }
              if (message.data != null && message.hasOwnProperty("data")) {
                  var error = $root.ListParWithRandom.verify(message.data);
                  if (error)
                      return "data." + error;
              }
              return null;
          };

          /**
           * Creates a ReportProduceProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ReportProduceProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ReportProduceProto} ReportProduceProto
           */
          ReportProduceProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ReportProduceProto)
                  return object;
              var message = new $root.casper.ReportProduceProto();
              if (object.channel != null) {
                  if (typeof object.channel !== "object")
                      throw TypeError(".casper.ReportProduceProto.channel: object expected");
                  message.channel = $root.Par.fromObject(object.channel);
              }
              if (object.data != null) {
                  if (typeof object.data !== "object")
                      throw TypeError(".casper.ReportProduceProto.data: object expected");
                  message.data = $root.ListParWithRandom.fromObject(object.data);
              }
              return message;
          };

          /**
           * Creates a plain object from a ReportProduceProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ReportProduceProto
           * @static
           * @param {casper.ReportProduceProto} message ReportProduceProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ReportProduceProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.channel = null;
                  object.data = null;
              }
              if (message.channel != null && message.hasOwnProperty("channel"))
                  object.channel = $root.Par.toObject(message.channel, options);
              if (message.data != null && message.hasOwnProperty("data"))
                  object.data = $root.ListParWithRandom.toObject(message.data, options);
              return object;
          };

          /**
           * Converts this ReportProduceProto to JSON.
           * @function toJSON
           * @memberof casper.ReportProduceProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ReportProduceProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ReportProduceProto;
      })();

      casper.ReportConsumeProto = (function() {

          /**
           * Properties of a ReportConsumeProto.
           * @memberof casper
           * @interface IReportConsumeProto
           * @property {Array.<IPar>|null} [channels] ReportConsumeProto channels
           * @property {Array.<IBindPattern>|null} [patterns] ReportConsumeProto patterns
           * @property {Array.<casper.IPeekProto>|null} [peeks] ReportConsumeProto peeks
           */

          /**
           * Constructs a new ReportConsumeProto.
           * @memberof casper
           * @classdesc Represents a ReportConsumeProto.
           * @implements IReportConsumeProto
           * @constructor
           * @param {casper.IReportConsumeProto=} [properties] Properties to set
           */
          function ReportConsumeProto(properties) {
              this.channels = [];
              this.patterns = [];
              this.peeks = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ReportConsumeProto channels.
           * @member {Array.<IPar>} channels
           * @memberof casper.ReportConsumeProto
           * @instance
           */
          ReportConsumeProto.prototype.channels = $util.emptyArray;

          /**
           * ReportConsumeProto patterns.
           * @member {Array.<IBindPattern>} patterns
           * @memberof casper.ReportConsumeProto
           * @instance
           */
          ReportConsumeProto.prototype.patterns = $util.emptyArray;

          /**
           * ReportConsumeProto peeks.
           * @member {Array.<casper.IPeekProto>} peeks
           * @memberof casper.ReportConsumeProto
           * @instance
           */
          ReportConsumeProto.prototype.peeks = $util.emptyArray;

          /**
           * Creates a new ReportConsumeProto instance using the specified properties.
           * @function create
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {casper.IReportConsumeProto=} [properties] Properties to set
           * @returns {casper.ReportConsumeProto} ReportConsumeProto instance
           */
          ReportConsumeProto.create = function create(properties) {
              return new ReportConsumeProto(properties);
          };

          /**
           * Encodes the specified ReportConsumeProto message. Does not implicitly {@link casper.ReportConsumeProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {casper.IReportConsumeProto} message ReportConsumeProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportConsumeProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.channels != null && message.channels.length)
                  for (var i = 0; i < message.channels.length; ++i)
                      $root.Par.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.patterns != null && message.patterns.length)
                  for (var i = 0; i < message.patterns.length; ++i)
                      $root.BindPattern.encode(message.patterns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.peeks != null && message.peeks.length)
                  for (var i = 0; i < message.peeks.length; ++i)
                      $root.casper.PeekProto.encode(message.peeks[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ReportConsumeProto message, length delimited. Does not implicitly {@link casper.ReportConsumeProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {casper.IReportConsumeProto} message ReportConsumeProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportConsumeProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ReportConsumeProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ReportConsumeProto} ReportConsumeProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportConsumeProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ReportConsumeProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.channels && message.channels.length))
                          message.channels = [];
                      message.channels.push($root.Par.decode(reader, reader.uint32()));
                      break;
                  case 2:
                      if (!(message.patterns && message.patterns.length))
                          message.patterns = [];
                      message.patterns.push($root.BindPattern.decode(reader, reader.uint32()));
                      break;
                  case 4:
                      if (!(message.peeks && message.peeks.length))
                          message.peeks = [];
                      message.peeks.push($root.casper.PeekProto.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ReportConsumeProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ReportConsumeProto} ReportConsumeProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportConsumeProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ReportConsumeProto message.
           * @function verify
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ReportConsumeProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.channels != null && message.hasOwnProperty("channels")) {
                  if (!Array.isArray(message.channels))
                      return "channels: array expected";
                  for (var i = 0; i < message.channels.length; ++i) {
                      var error = $root.Par.verify(message.channels[i]);
                      if (error)
                          return "channels." + error;
                  }
              }
              if (message.patterns != null && message.hasOwnProperty("patterns")) {
                  if (!Array.isArray(message.patterns))
                      return "patterns: array expected";
                  for (var i = 0; i < message.patterns.length; ++i) {
                      var error = $root.BindPattern.verify(message.patterns[i]);
                      if (error)
                          return "patterns." + error;
                  }
              }
              if (message.peeks != null && message.hasOwnProperty("peeks")) {
                  if (!Array.isArray(message.peeks))
                      return "peeks: array expected";
                  for (var i = 0; i < message.peeks.length; ++i) {
                      var error = $root.casper.PeekProto.verify(message.peeks[i]);
                      if (error)
                          return "peeks." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a ReportConsumeProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ReportConsumeProto} ReportConsumeProto
           */
          ReportConsumeProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ReportConsumeProto)
                  return object;
              var message = new $root.casper.ReportConsumeProto();
              if (object.channels) {
                  if (!Array.isArray(object.channels))
                      throw TypeError(".casper.ReportConsumeProto.channels: array expected");
                  message.channels = [];
                  for (var i = 0; i < object.channels.length; ++i) {
                      if (typeof object.channels[i] !== "object")
                          throw TypeError(".casper.ReportConsumeProto.channels: object expected");
                      message.channels[i] = $root.Par.fromObject(object.channels[i]);
                  }
              }
              if (object.patterns) {
                  if (!Array.isArray(object.patterns))
                      throw TypeError(".casper.ReportConsumeProto.patterns: array expected");
                  message.patterns = [];
                  for (var i = 0; i < object.patterns.length; ++i) {
                      if (typeof object.patterns[i] !== "object")
                          throw TypeError(".casper.ReportConsumeProto.patterns: object expected");
                      message.patterns[i] = $root.BindPattern.fromObject(object.patterns[i]);
                  }
              }
              if (object.peeks) {
                  if (!Array.isArray(object.peeks))
                      throw TypeError(".casper.ReportConsumeProto.peeks: array expected");
                  message.peeks = [];
                  for (var i = 0; i < object.peeks.length; ++i) {
                      if (typeof object.peeks[i] !== "object")
                          throw TypeError(".casper.ReportConsumeProto.peeks: object expected");
                      message.peeks[i] = $root.casper.PeekProto.fromObject(object.peeks[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a ReportConsumeProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ReportConsumeProto
           * @static
           * @param {casper.ReportConsumeProto} message ReportConsumeProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ReportConsumeProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object.channels = [];
                  object.patterns = [];
                  object.peeks = [];
              }
              if (message.channels && message.channels.length) {
                  object.channels = [];
                  for (var j = 0; j < message.channels.length; ++j)
                      object.channels[j] = $root.Par.toObject(message.channels[j], options);
              }
              if (message.patterns && message.patterns.length) {
                  object.patterns = [];
                  for (var j = 0; j < message.patterns.length; ++j)
                      object.patterns[j] = $root.BindPattern.toObject(message.patterns[j], options);
              }
              if (message.peeks && message.peeks.length) {
                  object.peeks = [];
                  for (var j = 0; j < message.peeks.length; ++j)
                      object.peeks[j] = $root.casper.PeekProto.toObject(message.peeks[j], options);
              }
              return object;
          };

          /**
           * Converts this ReportConsumeProto to JSON.
           * @function toJSON
           * @memberof casper.ReportConsumeProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ReportConsumeProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ReportConsumeProto;
      })();

      casper.ReportCommProto = (function() {

          /**
           * Properties of a ReportCommProto.
           * @memberof casper
           * @interface IReportCommProto
           * @property {casper.IReportConsumeProto|null} [consume] ReportCommProto consume
           * @property {Array.<casper.IReportProduceProto>|null} [produces] ReportCommProto produces
           */

          /**
           * Constructs a new ReportCommProto.
           * @memberof casper
           * @classdesc Represents a ReportCommProto.
           * @implements IReportCommProto
           * @constructor
           * @param {casper.IReportCommProto=} [properties] Properties to set
           */
          function ReportCommProto(properties) {
              this.produces = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ReportCommProto consume.
           * @member {casper.IReportConsumeProto|null|undefined} consume
           * @memberof casper.ReportCommProto
           * @instance
           */
          ReportCommProto.prototype.consume = null;

          /**
           * ReportCommProto produces.
           * @member {Array.<casper.IReportProduceProto>} produces
           * @memberof casper.ReportCommProto
           * @instance
           */
          ReportCommProto.prototype.produces = $util.emptyArray;

          /**
           * Creates a new ReportCommProto instance using the specified properties.
           * @function create
           * @memberof casper.ReportCommProto
           * @static
           * @param {casper.IReportCommProto=} [properties] Properties to set
           * @returns {casper.ReportCommProto} ReportCommProto instance
           */
          ReportCommProto.create = function create(properties) {
              return new ReportCommProto(properties);
          };

          /**
           * Encodes the specified ReportCommProto message. Does not implicitly {@link casper.ReportCommProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ReportCommProto
           * @static
           * @param {casper.IReportCommProto} message ReportCommProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportCommProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.consume != null && message.hasOwnProperty("consume"))
                  $root.casper.ReportConsumeProto.encode(message.consume, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.produces != null && message.produces.length)
                  for (var i = 0; i < message.produces.length; ++i)
                      $root.casper.ReportProduceProto.encode(message.produces[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ReportCommProto message, length delimited. Does not implicitly {@link casper.ReportCommProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ReportCommProto
           * @static
           * @param {casper.IReportCommProto} message ReportCommProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportCommProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ReportCommProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ReportCommProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ReportCommProto} ReportCommProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportCommProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ReportCommProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.consume = $root.casper.ReportConsumeProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.produces && message.produces.length))
                          message.produces = [];
                      message.produces.push($root.casper.ReportProduceProto.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ReportCommProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ReportCommProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ReportCommProto} ReportCommProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportCommProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ReportCommProto message.
           * @function verify
           * @memberof casper.ReportCommProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ReportCommProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.consume != null && message.hasOwnProperty("consume")) {
                  var error = $root.casper.ReportConsumeProto.verify(message.consume);
                  if (error)
                      return "consume." + error;
              }
              if (message.produces != null && message.hasOwnProperty("produces")) {
                  if (!Array.isArray(message.produces))
                      return "produces: array expected";
                  for (var i = 0; i < message.produces.length; ++i) {
                      var error = $root.casper.ReportProduceProto.verify(message.produces[i]);
                      if (error)
                          return "produces." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a ReportCommProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ReportCommProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ReportCommProto} ReportCommProto
           */
          ReportCommProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ReportCommProto)
                  return object;
              var message = new $root.casper.ReportCommProto();
              if (object.consume != null) {
                  if (typeof object.consume !== "object")
                      throw TypeError(".casper.ReportCommProto.consume: object expected");
                  message.consume = $root.casper.ReportConsumeProto.fromObject(object.consume);
              }
              if (object.produces) {
                  if (!Array.isArray(object.produces))
                      throw TypeError(".casper.ReportCommProto.produces: array expected");
                  message.produces = [];
                  for (var i = 0; i < object.produces.length; ++i) {
                      if (typeof object.produces[i] !== "object")
                          throw TypeError(".casper.ReportCommProto.produces: object expected");
                      message.produces[i] = $root.casper.ReportProduceProto.fromObject(object.produces[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a ReportCommProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ReportCommProto
           * @static
           * @param {casper.ReportCommProto} message ReportCommProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ReportCommProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.produces = [];
              if (options.defaults)
                  object.consume = null;
              if (message.consume != null && message.hasOwnProperty("consume"))
                  object.consume = $root.casper.ReportConsumeProto.toObject(message.consume, options);
              if (message.produces && message.produces.length) {
                  object.produces = [];
                  for (var j = 0; j < message.produces.length; ++j)
                      object.produces[j] = $root.casper.ReportProduceProto.toObject(message.produces[j], options);
              }
              return object;
          };

          /**
           * Converts this ReportCommProto to JSON.
           * @function toJSON
           * @memberof casper.ReportCommProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ReportCommProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ReportCommProto;
      })();

      casper.ReportProto = (function() {

          /**
           * Properties of a ReportProto.
           * @memberof casper
           * @interface IReportProto
           * @property {casper.IReportProduceProto|null} [produce] ReportProto produce
           * @property {casper.IReportConsumeProto|null} [consume] ReportProto consume
           * @property {casper.IReportCommProto|null} [comm] ReportProto comm
           */

          /**
           * Constructs a new ReportProto.
           * @memberof casper
           * @classdesc Represents a ReportProto.
           * @implements IReportProto
           * @constructor
           * @param {casper.IReportProto=} [properties] Properties to set
           */
          function ReportProto(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ReportProto produce.
           * @member {casper.IReportProduceProto|null|undefined} produce
           * @memberof casper.ReportProto
           * @instance
           */
          ReportProto.prototype.produce = null;

          /**
           * ReportProto consume.
           * @member {casper.IReportConsumeProto|null|undefined} consume
           * @memberof casper.ReportProto
           * @instance
           */
          ReportProto.prototype.consume = null;

          /**
           * ReportProto comm.
           * @member {casper.IReportCommProto|null|undefined} comm
           * @memberof casper.ReportProto
           * @instance
           */
          ReportProto.prototype.comm = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * ReportProto report.
           * @member {"produce"|"consume"|"comm"|undefined} report
           * @memberof casper.ReportProto
           * @instance
           */
          Object.defineProperty(ReportProto.prototype, "report", {
              get: $util.oneOfGetter($oneOfFields = ["produce", "consume", "comm"]),
              set: $util.oneOfSetter($oneOfFields)
          });

          /**
           * Creates a new ReportProto instance using the specified properties.
           * @function create
           * @memberof casper.ReportProto
           * @static
           * @param {casper.IReportProto=} [properties] Properties to set
           * @returns {casper.ReportProto} ReportProto instance
           */
          ReportProto.create = function create(properties) {
              return new ReportProto(properties);
          };

          /**
           * Encodes the specified ReportProto message. Does not implicitly {@link casper.ReportProto.verify|verify} messages.
           * @function encode
           * @memberof casper.ReportProto
           * @static
           * @param {casper.IReportProto} message ReportProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportProto.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.produce != null && message.hasOwnProperty("produce"))
                  $root.casper.ReportProduceProto.encode(message.produce, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.consume != null && message.hasOwnProperty("consume"))
                  $root.casper.ReportConsumeProto.encode(message.consume, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.comm != null && message.hasOwnProperty("comm"))
                  $root.casper.ReportCommProto.encode(message.comm, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified ReportProto message, length delimited. Does not implicitly {@link casper.ReportProto.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.ReportProto
           * @static
           * @param {casper.IReportProto} message ReportProto message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ReportProto.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ReportProto message from the specified reader or buffer.
           * @function decode
           * @memberof casper.ReportProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.ReportProto} ReportProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportProto.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.ReportProto();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.produce = $root.casper.ReportProduceProto.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.consume = $root.casper.ReportConsumeProto.decode(reader, reader.uint32());
                      break;
                  case 3:
                      message.comm = $root.casper.ReportCommProto.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ReportProto message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.ReportProto
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.ReportProto} ReportProto
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ReportProto.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ReportProto message.
           * @function verify
           * @memberof casper.ReportProto
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ReportProto.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              var properties = {};
              if (message.produce != null && message.hasOwnProperty("produce")) {
                  properties.report = 1;
                  {
                      var error = $root.casper.ReportProduceProto.verify(message.produce);
                      if (error)
                          return "produce." + error;
                  }
              }
              if (message.consume != null && message.hasOwnProperty("consume")) {
                  if (properties.report === 1)
                      return "report: multiple values";
                  properties.report = 1;
                  {
                      var error = $root.casper.ReportConsumeProto.verify(message.consume);
                      if (error)
                          return "consume." + error;
                  }
              }
              if (message.comm != null && message.hasOwnProperty("comm")) {
                  if (properties.report === 1)
                      return "report: multiple values";
                  properties.report = 1;
                  {
                      var error = $root.casper.ReportCommProto.verify(message.comm);
                      if (error)
                          return "comm." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a ReportProto message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.ReportProto
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.ReportProto} ReportProto
           */
          ReportProto.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.ReportProto)
                  return object;
              var message = new $root.casper.ReportProto();
              if (object.produce != null) {
                  if (typeof object.produce !== "object")
                      throw TypeError(".casper.ReportProto.produce: object expected");
                  message.produce = $root.casper.ReportProduceProto.fromObject(object.produce);
              }
              if (object.consume != null) {
                  if (typeof object.consume !== "object")
                      throw TypeError(".casper.ReportProto.consume: object expected");
                  message.consume = $root.casper.ReportConsumeProto.fromObject(object.consume);
              }
              if (object.comm != null) {
                  if (typeof object.comm !== "object")
                      throw TypeError(".casper.ReportProto.comm: object expected");
                  message.comm = $root.casper.ReportCommProto.fromObject(object.comm);
              }
              return message;
          };

          /**
           * Creates a plain object from a ReportProto message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.ReportProto
           * @static
           * @param {casper.ReportProto} message ReportProto
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ReportProto.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (message.produce != null && message.hasOwnProperty("produce")) {
                  object.produce = $root.casper.ReportProduceProto.toObject(message.produce, options);
                  if (options.oneofs)
                      object.report = "produce";
              }
              if (message.consume != null && message.hasOwnProperty("consume")) {
                  object.consume = $root.casper.ReportConsumeProto.toObject(message.consume, options);
                  if (options.oneofs)
                      object.report = "consume";
              }
              if (message.comm != null && message.hasOwnProperty("comm")) {
                  object.comm = $root.casper.ReportCommProto.toObject(message.comm, options);
                  if (options.oneofs)
                      object.report = "comm";
              }
              return object;
          };

          /**
           * Converts this ReportProto to JSON.
           * @function toJSON
           * @memberof casper.ReportProto
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ReportProto.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ReportProto;
      })();

      casper.SingleReport = (function() {

          /**
           * Properties of a SingleReport.
           * @memberof casper
           * @interface ISingleReport
           * @property {Array.<casper.IReportProto>|null} [events] SingleReport events
           */

          /**
           * Constructs a new SingleReport.
           * @memberof casper
           * @classdesc Represents a SingleReport.
           * @implements ISingleReport
           * @constructor
           * @param {casper.ISingleReport=} [properties] Properties to set
           */
          function SingleReport(properties) {
              this.events = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * SingleReport events.
           * @member {Array.<casper.IReportProto>} events
           * @memberof casper.SingleReport
           * @instance
           */
          SingleReport.prototype.events = $util.emptyArray;

          /**
           * Creates a new SingleReport instance using the specified properties.
           * @function create
           * @memberof casper.SingleReport
           * @static
           * @param {casper.ISingleReport=} [properties] Properties to set
           * @returns {casper.SingleReport} SingleReport instance
           */
          SingleReport.create = function create(properties) {
              return new SingleReport(properties);
          };

          /**
           * Encodes the specified SingleReport message. Does not implicitly {@link casper.SingleReport.verify|verify} messages.
           * @function encode
           * @memberof casper.SingleReport
           * @static
           * @param {casper.ISingleReport} message SingleReport message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SingleReport.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.events != null && message.events.length)
                  for (var i = 0; i < message.events.length; ++i)
                      $root.casper.ReportProto.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified SingleReport message, length delimited. Does not implicitly {@link casper.SingleReport.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.SingleReport
           * @static
           * @param {casper.ISingleReport} message SingleReport message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SingleReport.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SingleReport message from the specified reader or buffer.
           * @function decode
           * @memberof casper.SingleReport
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.SingleReport} SingleReport
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SingleReport.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.SingleReport();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.events && message.events.length))
                          message.events = [];
                      message.events.push($root.casper.ReportProto.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a SingleReport message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.SingleReport
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.SingleReport} SingleReport
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SingleReport.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SingleReport message.
           * @function verify
           * @memberof casper.SingleReport
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SingleReport.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.events != null && message.hasOwnProperty("events")) {
                  if (!Array.isArray(message.events))
                      return "events: array expected";
                  for (var i = 0; i < message.events.length; ++i) {
                      var error = $root.casper.ReportProto.verify(message.events[i]);
                      if (error)
                          return "events." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a SingleReport message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.SingleReport
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.SingleReport} SingleReport
           */
          SingleReport.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.SingleReport)
                  return object;
              var message = new $root.casper.SingleReport();
              if (object.events) {
                  if (!Array.isArray(object.events))
                      throw TypeError(".casper.SingleReport.events: array expected");
                  message.events = [];
                  for (var i = 0; i < object.events.length; ++i) {
                      if (typeof object.events[i] !== "object")
                          throw TypeError(".casper.SingleReport.events: object expected");
                      message.events[i] = $root.casper.ReportProto.fromObject(object.events[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a SingleReport message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.SingleReport
           * @static
           * @param {casper.SingleReport} message SingleReport
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SingleReport.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.events = [];
              if (message.events && message.events.length) {
                  object.events = [];
                  for (var j = 0; j < message.events.length; ++j)
                      object.events[j] = $root.casper.ReportProto.toObject(message.events[j], options);
              }
              return object;
          };

          /**
           * Converts this SingleReport to JSON.
           * @function toJSON
           * @memberof casper.SingleReport
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SingleReport.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return SingleReport;
      })();

      casper.DeployInfoWithEventData = (function() {

          /**
           * Properties of a DeployInfoWithEventData.
           * @memberof casper
           * @interface IDeployInfoWithEventData
           * @property {casper.IDeployInfo|null} [deployInfo] DeployInfoWithEventData deployInfo
           * @property {Array.<casper.ISingleReport>|null} [report] DeployInfoWithEventData report
           */

          /**
           * Constructs a new DeployInfoWithEventData.
           * @memberof casper
           * @classdesc Represents a DeployInfoWithEventData.
           * @implements IDeployInfoWithEventData
           * @constructor
           * @param {casper.IDeployInfoWithEventData=} [properties] Properties to set
           */
          function DeployInfoWithEventData(properties) {
              this.report = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * DeployInfoWithEventData deployInfo.
           * @member {casper.IDeployInfo|null|undefined} deployInfo
           * @memberof casper.DeployInfoWithEventData
           * @instance
           */
          DeployInfoWithEventData.prototype.deployInfo = null;

          /**
           * DeployInfoWithEventData report.
           * @member {Array.<casper.ISingleReport>} report
           * @memberof casper.DeployInfoWithEventData
           * @instance
           */
          DeployInfoWithEventData.prototype.report = $util.emptyArray;

          /**
           * Creates a new DeployInfoWithEventData instance using the specified properties.
           * @function create
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {casper.IDeployInfoWithEventData=} [properties] Properties to set
           * @returns {casper.DeployInfoWithEventData} DeployInfoWithEventData instance
           */
          DeployInfoWithEventData.create = function create(properties) {
              return new DeployInfoWithEventData(properties);
          };

          /**
           * Encodes the specified DeployInfoWithEventData message. Does not implicitly {@link casper.DeployInfoWithEventData.verify|verify} messages.
           * @function encode
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {casper.IDeployInfoWithEventData} message DeployInfoWithEventData message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DeployInfoWithEventData.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.deployInfo != null && message.hasOwnProperty("deployInfo"))
                  $root.casper.DeployInfo.encode(message.deployInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.report != null && message.report.length)
                  for (var i = 0; i < message.report.length; ++i)
                      $root.casper.SingleReport.encode(message.report[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified DeployInfoWithEventData message, length delimited. Does not implicitly {@link casper.DeployInfoWithEventData.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {casper.IDeployInfoWithEventData} message DeployInfoWithEventData message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DeployInfoWithEventData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DeployInfoWithEventData message from the specified reader or buffer.
           * @function decode
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.DeployInfoWithEventData} DeployInfoWithEventData
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DeployInfoWithEventData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.DeployInfoWithEventData();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.deployInfo = $root.casper.DeployInfo.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.report && message.report.length))
                          message.report = [];
                      message.report.push($root.casper.SingleReport.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a DeployInfoWithEventData message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.DeployInfoWithEventData} DeployInfoWithEventData
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DeployInfoWithEventData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DeployInfoWithEventData message.
           * @function verify
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DeployInfoWithEventData.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.deployInfo != null && message.hasOwnProperty("deployInfo")) {
                  var error = $root.casper.DeployInfo.verify(message.deployInfo);
                  if (error)
                      return "deployInfo." + error;
              }
              if (message.report != null && message.hasOwnProperty("report")) {
                  if (!Array.isArray(message.report))
                      return "report: array expected";
                  for (var i = 0; i < message.report.length; ++i) {
                      var error = $root.casper.SingleReport.verify(message.report[i]);
                      if (error)
                          return "report." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a DeployInfoWithEventData message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.DeployInfoWithEventData} DeployInfoWithEventData
           */
          DeployInfoWithEventData.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.DeployInfoWithEventData)
                  return object;
              var message = new $root.casper.DeployInfoWithEventData();
              if (object.deployInfo != null) {
                  if (typeof object.deployInfo !== "object")
                      throw TypeError(".casper.DeployInfoWithEventData.deployInfo: object expected");
                  message.deployInfo = $root.casper.DeployInfo.fromObject(object.deployInfo);
              }
              if (object.report) {
                  if (!Array.isArray(object.report))
                      throw TypeError(".casper.DeployInfoWithEventData.report: array expected");
                  message.report = [];
                  for (var i = 0; i < object.report.length; ++i) {
                      if (typeof object.report[i] !== "object")
                          throw TypeError(".casper.DeployInfoWithEventData.report: object expected");
                      message.report[i] = $root.casper.SingleReport.fromObject(object.report[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a DeployInfoWithEventData message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.DeployInfoWithEventData
           * @static
           * @param {casper.DeployInfoWithEventData} message DeployInfoWithEventData
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DeployInfoWithEventData.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.report = [];
              if (options.defaults)
                  object.deployInfo = null;
              if (message.deployInfo != null && message.hasOwnProperty("deployInfo"))
                  object.deployInfo = $root.casper.DeployInfo.toObject(message.deployInfo, options);
              if (message.report && message.report.length) {
                  object.report = [];
                  for (var j = 0; j < message.report.length; ++j)
                      object.report[j] = $root.casper.SingleReport.toObject(message.report[j], options);
              }
              return object;
          };

          /**
           * Converts this DeployInfoWithEventData to JSON.
           * @function toJSON
           * @memberof casper.DeployInfoWithEventData
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DeployInfoWithEventData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return DeployInfoWithEventData;
      })();

      casper.BlockEventInfo = (function() {

          /**
           * Properties of a BlockEventInfo.
           * @memberof casper
           * @interface IBlockEventInfo
           * @property {casper.ILightBlockInfo|null} [blockInfo] BlockEventInfo blockInfo
           * @property {Array.<casper.IDeployInfoWithEventData>|null} [deploys] BlockEventInfo deploys
           */

          /**
           * Constructs a new BlockEventInfo.
           * @memberof casper
           * @classdesc Represents a BlockEventInfo.
           * @implements IBlockEventInfo
           * @constructor
           * @param {casper.IBlockEventInfo=} [properties] Properties to set
           */
          function BlockEventInfo(properties) {
              this.deploys = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * BlockEventInfo blockInfo.
           * @member {casper.ILightBlockInfo|null|undefined} blockInfo
           * @memberof casper.BlockEventInfo
           * @instance
           */
          BlockEventInfo.prototype.blockInfo = null;

          /**
           * BlockEventInfo deploys.
           * @member {Array.<casper.IDeployInfoWithEventData>} deploys
           * @memberof casper.BlockEventInfo
           * @instance
           */
          BlockEventInfo.prototype.deploys = $util.emptyArray;

          /**
           * Creates a new BlockEventInfo instance using the specified properties.
           * @function create
           * @memberof casper.BlockEventInfo
           * @static
           * @param {casper.IBlockEventInfo=} [properties] Properties to set
           * @returns {casper.BlockEventInfo} BlockEventInfo instance
           */
          BlockEventInfo.create = function create(properties) {
              return new BlockEventInfo(properties);
          };

          /**
           * Encodes the specified BlockEventInfo message. Does not implicitly {@link casper.BlockEventInfo.verify|verify} messages.
           * @function encode
           * @memberof casper.BlockEventInfo
           * @static
           * @param {casper.IBlockEventInfo} message BlockEventInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockEventInfo.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                  $root.casper.LightBlockInfo.encode(message.blockInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.deploys != null && message.deploys.length)
                  for (var i = 0; i < message.deploys.length; ++i)
                      $root.casper.DeployInfoWithEventData.encode(message.deploys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified BlockEventInfo message, length delimited. Does not implicitly {@link casper.BlockEventInfo.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.BlockEventInfo
           * @static
           * @param {casper.IBlockEventInfo} message BlockEventInfo message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          BlockEventInfo.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a BlockEventInfo message from the specified reader or buffer.
           * @function decode
           * @memberof casper.BlockEventInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.BlockEventInfo} BlockEventInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockEventInfo.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.BlockEventInfo();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.blockInfo = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                      break;
                  case 2:
                      if (!(message.deploys && message.deploys.length))
                          message.deploys = [];
                      message.deploys.push($root.casper.DeployInfoWithEventData.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a BlockEventInfo message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.BlockEventInfo
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.BlockEventInfo} BlockEventInfo
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          BlockEventInfo.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a BlockEventInfo message.
           * @function verify
           * @memberof casper.BlockEventInfo
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          BlockEventInfo.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                  var error = $root.casper.LightBlockInfo.verify(message.blockInfo);
                  if (error)
                      return "blockInfo." + error;
              }
              if (message.deploys != null && message.hasOwnProperty("deploys")) {
                  if (!Array.isArray(message.deploys))
                      return "deploys: array expected";
                  for (var i = 0; i < message.deploys.length; ++i) {
                      var error = $root.casper.DeployInfoWithEventData.verify(message.deploys[i]);
                      if (error)
                          return "deploys." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a BlockEventInfo message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.BlockEventInfo
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.BlockEventInfo} BlockEventInfo
           */
          BlockEventInfo.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.BlockEventInfo)
                  return object;
              var message = new $root.casper.BlockEventInfo();
              if (object.blockInfo != null) {
                  if (typeof object.blockInfo !== "object")
                      throw TypeError(".casper.BlockEventInfo.blockInfo: object expected");
                  message.blockInfo = $root.casper.LightBlockInfo.fromObject(object.blockInfo);
              }
              if (object.deploys) {
                  if (!Array.isArray(object.deploys))
                      throw TypeError(".casper.BlockEventInfo.deploys: array expected");
                  message.deploys = [];
                  for (var i = 0; i < object.deploys.length; ++i) {
                      if (typeof object.deploys[i] !== "object")
                          throw TypeError(".casper.BlockEventInfo.deploys: object expected");
                      message.deploys[i] = $root.casper.DeployInfoWithEventData.fromObject(object.deploys[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a BlockEventInfo message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.BlockEventInfo
           * @static
           * @param {casper.BlockEventInfo} message BlockEventInfo
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          BlockEventInfo.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.deploys = [];
              if (options.defaults)
                  object.blockInfo = null;
              if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                  object.blockInfo = $root.casper.LightBlockInfo.toObject(message.blockInfo, options);
              if (message.deploys && message.deploys.length) {
                  object.deploys = [];
                  for (var j = 0; j < message.deploys.length; ++j)
                      object.deploys[j] = $root.casper.DeployInfoWithEventData.toObject(message.deploys[j], options);
              }
              return object;
          };

          /**
           * Converts this BlockEventInfo to JSON.
           * @function toJSON
           * @memberof casper.BlockEventInfo
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          BlockEventInfo.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return BlockEventInfo;
      })();

      casper.v1 = (function() {

          /**
           * Namespace v1.
           * @memberof casper
           * @namespace
           */
          var v1 = {};

          v1.DeployService = (function() {

              /**
               * Constructs a new DeployService service.
               * @memberof casper.v1
               * @classdesc Represents a DeployService
               * @extends $protobuf.rpc.Service
               * @constructor
               * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
               * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
               * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
               */
              function DeployService(rpcImpl, requestDelimited, responseDelimited) {
                  minimal$1.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
              }

              (DeployService.prototype = Object.create(minimal$1.rpc.Service.prototype)).constructor = DeployService;

              /**
               * Creates new DeployService service using the specified rpc implementation.
               * @function create
               * @memberof casper.v1.DeployService
               * @static
               * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
               * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
               * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
               * @returns {DeployService} RPC service. Useful where requests and/or responses are streamed.
               */
              DeployService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
              };

              /**
               * Callback as used by {@link casper.v1.DeployService#doDeploy}.
               * @memberof casper.v1.DeployService
               * @typedef doDeployCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.DeployResponse} [response] DeployResponse
               */

              /**
               * Calls doDeploy.
               * @function doDeploy
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IDeployDataProto} request DeployDataProto message or plain object
               * @param {casper.v1.DeployService.doDeployCallback} callback Node-style callback called with the error, if any, and DeployResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.doDeploy = function doDeploy(request, callback) {
                  return this.rpcCall(doDeploy, $root.casper.DeployDataProto, $root.casper.v1.DeployResponse, request, callback);
              }, "name", { value: "doDeploy" });

              /**
               * Calls doDeploy.
               * @function doDeploy
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IDeployDataProto} request DeployDataProto message or plain object
               * @returns {Promise<casper.v1.DeployResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#getBlock}.
               * @memberof casper.v1.DeployService
               * @typedef getBlockCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.BlockResponse} [response] BlockResponse
               */

              /**
               * Calls getBlock.
               * @function getBlock
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlockQuery} request BlockQuery message or plain object
               * @param {casper.v1.DeployService.getBlockCallback} callback Node-style callback called with the error, if any, and BlockResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.getBlock = function getBlock(request, callback) {
                  return this.rpcCall(getBlock, $root.casper.BlockQuery, $root.casper.v1.BlockResponse, request, callback);
              }, "name", { value: "getBlock" });

              /**
               * Calls getBlock.
               * @function getBlock
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlockQuery} request BlockQuery message or plain object
               * @returns {Promise<casper.v1.BlockResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#visualizeDag}.
               * @memberof casper.v1.DeployService
               * @typedef visualizeDagCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.VisualizeBlocksResponse} [response] VisualizeBlocksResponse
               */

              /**
               * Calls visualizeDag.
               * @function visualizeDag
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IVisualizeDagQuery} request VisualizeDagQuery message or plain object
               * @param {casper.v1.DeployService.visualizeDagCallback} callback Node-style callback called with the error, if any, and VisualizeBlocksResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.visualizeDag = function visualizeDag(request, callback) {
                  return this.rpcCall(visualizeDag, $root.casper.VisualizeDagQuery, $root.casper.v1.VisualizeBlocksResponse, request, callback);
              }, "name", { value: "visualizeDag" });

              /**
               * Calls visualizeDag.
               * @function visualizeDag
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IVisualizeDagQuery} request VisualizeDagQuery message or plain object
               * @returns {Promise<casper.v1.VisualizeBlocksResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#machineVerifiableDag}.
               * @memberof casper.v1.DeployService
               * @typedef machineVerifiableDagCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.MachineVerifyResponse} [response] MachineVerifyResponse
               */

              /**
               * Calls machineVerifiableDag.
               * @function machineVerifiableDag
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IMachineVerifyQuery} request MachineVerifyQuery message or plain object
               * @param {casper.v1.DeployService.machineVerifiableDagCallback} callback Node-style callback called with the error, if any, and MachineVerifyResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.machineVerifiableDag = function machineVerifiableDag(request, callback) {
                  return this.rpcCall(machineVerifiableDag, $root.casper.MachineVerifyQuery, $root.casper.v1.MachineVerifyResponse, request, callback);
              }, "name", { value: "machineVerifiableDag" });

              /**
               * Calls machineVerifiableDag.
               * @function machineVerifiableDag
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IMachineVerifyQuery} request MachineVerifyQuery message or plain object
               * @returns {Promise<casper.v1.MachineVerifyResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#showMainChain}.
               * @memberof casper.v1.DeployService
               * @typedef showMainChainCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.BlockInfoResponse} [response] BlockInfoResponse
               */

              /**
               * Calls showMainChain.
               * @function showMainChain
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
               * @param {casper.v1.DeployService.showMainChainCallback} callback Node-style callback called with the error, if any, and BlockInfoResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.showMainChain = function showMainChain(request, callback) {
                  return this.rpcCall(showMainChain, $root.casper.BlocksQuery, $root.casper.v1.BlockInfoResponse, request, callback);
              }, "name", { value: "showMainChain" });

              /**
               * Calls showMainChain.
               * @function showMainChain
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
               * @returns {Promise<casper.v1.BlockInfoResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#getBlocks}.
               * @memberof casper.v1.DeployService
               * @typedef getBlocksCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.BlockInfoResponse} [response] BlockInfoResponse
               */

              /**
               * Calls getBlocks.
               * @function getBlocks
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
               * @param {casper.v1.DeployService.getBlocksCallback} callback Node-style callback called with the error, if any, and BlockInfoResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.getBlocks = function getBlocks(request, callback) {
                  return this.rpcCall(getBlocks, $root.casper.BlocksQuery, $root.casper.v1.BlockInfoResponse, request, callback);
              }, "name", { value: "getBlocks" });

              /**
               * Calls getBlocks.
               * @function getBlocks
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlocksQuery} request BlocksQuery message or plain object
               * @returns {Promise<casper.v1.BlockInfoResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#listenForDataAtName}.
               * @memberof casper.v1.DeployService
               * @typedef listenForDataAtNameCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.ListeningNameDataResponse} [response] ListeningNameDataResponse
               */

              /**
               * Calls listenForDataAtName.
               * @function listenForDataAtName
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IDataAtNameQuery} request DataAtNameQuery message or plain object
               * @param {casper.v1.DeployService.listenForDataAtNameCallback} callback Node-style callback called with the error, if any, and ListeningNameDataResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.listenForDataAtName = function listenForDataAtName(request, callback) {
                  return this.rpcCall(listenForDataAtName, $root.casper.DataAtNameQuery, $root.casper.v1.ListeningNameDataResponse, request, callback);
              }, "name", { value: "listenForDataAtName" });

              /**
               * Calls listenForDataAtName.
               * @function listenForDataAtName
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IDataAtNameQuery} request DataAtNameQuery message or plain object
               * @returns {Promise<casper.v1.ListeningNameDataResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#listenForContinuationAtName}.
               * @memberof casper.v1.DeployService
               * @typedef listenForContinuationAtNameCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.ContinuationAtNameResponse} [response] ContinuationAtNameResponse
               */

              /**
               * Calls listenForContinuationAtName.
               * @function listenForContinuationAtName
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IContinuationAtNameQuery} request ContinuationAtNameQuery message or plain object
               * @param {casper.v1.DeployService.listenForContinuationAtNameCallback} callback Node-style callback called with the error, if any, and ContinuationAtNameResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.listenForContinuationAtName = function listenForContinuationAtName(request, callback) {
                  return this.rpcCall(listenForContinuationAtName, $root.casper.ContinuationAtNameQuery, $root.casper.v1.ContinuationAtNameResponse, request, callback);
              }, "name", { value: "listenForContinuationAtName" });

              /**
               * Calls listenForContinuationAtName.
               * @function listenForContinuationAtName
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IContinuationAtNameQuery} request ContinuationAtNameQuery message or plain object
               * @returns {Promise<casper.v1.ContinuationAtNameResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#findDeploy}.
               * @memberof casper.v1.DeployService
               * @typedef findDeployCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.FindDeployResponse} [response] FindDeployResponse
               */

              /**
               * Calls findDeploy.
               * @function findDeploy
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IFindDeployQuery} request FindDeployQuery message or plain object
               * @param {casper.v1.DeployService.findDeployCallback} callback Node-style callback called with the error, if any, and FindDeployResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.findDeploy = function findDeploy(request, callback) {
                  return this.rpcCall(findDeploy, $root.casper.FindDeployQuery, $root.casper.v1.FindDeployResponse, request, callback);
              }, "name", { value: "findDeploy" });

              /**
               * Calls findDeploy.
               * @function findDeploy
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IFindDeployQuery} request FindDeployQuery message or plain object
               * @returns {Promise<casper.v1.FindDeployResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#previewPrivateNames}.
               * @memberof casper.v1.DeployService
               * @typedef previewPrivateNamesCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.PrivateNamePreviewResponse} [response] PrivateNamePreviewResponse
               */

              /**
               * Calls previewPrivateNames.
               * @function previewPrivateNames
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IPrivateNamePreviewQuery} request PrivateNamePreviewQuery message or plain object
               * @param {casper.v1.DeployService.previewPrivateNamesCallback} callback Node-style callback called with the error, if any, and PrivateNamePreviewResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.previewPrivateNames = function previewPrivateNames(request, callback) {
                  return this.rpcCall(previewPrivateNames, $root.casper.PrivateNamePreviewQuery, $root.casper.v1.PrivateNamePreviewResponse, request, callback);
              }, "name", { value: "previewPrivateNames" });

              /**
               * Calls previewPrivateNames.
               * @function previewPrivateNames
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IPrivateNamePreviewQuery} request PrivateNamePreviewQuery message or plain object
               * @returns {Promise<casper.v1.PrivateNamePreviewResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#lastFinalizedBlock}.
               * @memberof casper.v1.DeployService
               * @typedef lastFinalizedBlockCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.LastFinalizedBlockResponse} [response] LastFinalizedBlockResponse
               */

              /**
               * Calls lastFinalizedBlock.
               * @function lastFinalizedBlock
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.ILastFinalizedBlockQuery} request LastFinalizedBlockQuery message or plain object
               * @param {casper.v1.DeployService.lastFinalizedBlockCallback} callback Node-style callback called with the error, if any, and LastFinalizedBlockResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.lastFinalizedBlock = function lastFinalizedBlock(request, callback) {
                  return this.rpcCall(lastFinalizedBlock, $root.casper.LastFinalizedBlockQuery, $root.casper.v1.LastFinalizedBlockResponse, request, callback);
              }, "name", { value: "lastFinalizedBlock" });

              /**
               * Calls lastFinalizedBlock.
               * @function lastFinalizedBlock
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.ILastFinalizedBlockQuery} request LastFinalizedBlockQuery message or plain object
               * @returns {Promise<casper.v1.LastFinalizedBlockResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#isFinalized}.
               * @memberof casper.v1.DeployService
               * @typedef isFinalizedCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.IsFinalizedResponse} [response] IsFinalizedResponse
               */

              /**
               * Calls isFinalized.
               * @function isFinalized
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IIsFinalizedQuery} request IsFinalizedQuery message or plain object
               * @param {casper.v1.DeployService.isFinalizedCallback} callback Node-style callback called with the error, if any, and IsFinalizedResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.isFinalized = function isFinalized(request, callback) {
                  return this.rpcCall(isFinalized, $root.casper.IsFinalizedQuery, $root.casper.v1.IsFinalizedResponse, request, callback);
              }, "name", { value: "isFinalized" });

              /**
               * Calls isFinalized.
               * @function isFinalized
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IIsFinalizedQuery} request IsFinalizedQuery message or plain object
               * @returns {Promise<casper.v1.IsFinalizedResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#bondStatus}.
               * @memberof casper.v1.DeployService
               * @typedef bondStatusCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.BondStatusResponse} [response] BondStatusResponse
               */

              /**
               * Calls bondStatus.
               * @function bondStatus
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBondStatusQuery} request BondStatusQuery message or plain object
               * @param {casper.v1.DeployService.bondStatusCallback} callback Node-style callback called with the error, if any, and BondStatusResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.bondStatus = function bondStatus(request, callback) {
                  return this.rpcCall(bondStatus, $root.casper.BondStatusQuery, $root.casper.v1.BondStatusResponse, request, callback);
              }, "name", { value: "bondStatus" });

              /**
               * Calls bondStatus.
               * @function bondStatus
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBondStatusQuery} request BondStatusQuery message or plain object
               * @returns {Promise<casper.v1.BondStatusResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#exploratoryDeploy}.
               * @memberof casper.v1.DeployService
               * @typedef exploratoryDeployCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.ExploratoryDeployResponse} [response] ExploratoryDeployResponse
               */

              /**
               * Calls exploratoryDeploy.
               * @function exploratoryDeploy
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IExploratoryDeployQuery} request ExploratoryDeployQuery message or plain object
               * @param {casper.v1.DeployService.exploratoryDeployCallback} callback Node-style callback called with the error, if any, and ExploratoryDeployResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.exploratoryDeploy = function exploratoryDeploy(request, callback) {
                  return this.rpcCall(exploratoryDeploy, $root.casper.ExploratoryDeployQuery, $root.casper.v1.ExploratoryDeployResponse, request, callback);
              }, "name", { value: "exploratoryDeploy" });

              /**
               * Calls exploratoryDeploy.
               * @function exploratoryDeploy
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IExploratoryDeployQuery} request ExploratoryDeployQuery message or plain object
               * @returns {Promise<casper.v1.ExploratoryDeployResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#getBlocksByHeights}.
               * @memberof casper.v1.DeployService
               * @typedef getBlocksByHeightsCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.BlockInfoResponse} [response] BlockInfoResponse
               */

              /**
               * Calls getBlocksByHeights.
               * @function getBlocksByHeights
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlocksQueryByHeight} request BlocksQueryByHeight message or plain object
               * @param {casper.v1.DeployService.getBlocksByHeightsCallback} callback Node-style callback called with the error, if any, and BlockInfoResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.getBlocksByHeights = function getBlocksByHeights(request, callback) {
                  return this.rpcCall(getBlocksByHeights, $root.casper.BlocksQueryByHeight, $root.casper.v1.BlockInfoResponse, request, callback);
              }, "name", { value: "getBlocksByHeights" });

              /**
               * Calls getBlocksByHeights.
               * @function getBlocksByHeights
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlocksQueryByHeight} request BlocksQueryByHeight message or plain object
               * @returns {Promise<casper.v1.BlockInfoResponse>} Promise
               * @variation 2
               */

              /**
               * Callback as used by {@link casper.v1.DeployService#getEventByHash}.
               * @memberof casper.v1.DeployService
               * @typedef getEventByHashCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.EventInfoResponse} [response] EventInfoResponse
               */

              /**
               * Calls getEventByHash.
               * @function getEventByHash
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlockQuery} request BlockQuery message or plain object
               * @param {casper.v1.DeployService.getEventByHashCallback} callback Node-style callback called with the error, if any, and EventInfoResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(DeployService.prototype.getEventByHash = function getEventByHash(request, callback) {
                  return this.rpcCall(getEventByHash, $root.casper.BlockQuery, $root.casper.v1.EventInfoResponse, request, callback);
              }, "name", { value: "getEventByHash" });

              /**
               * Calls getEventByHash.
               * @function getEventByHash
               * @memberof casper.v1.DeployService
               * @instance
               * @param {casper.IBlockQuery} request BlockQuery message or plain object
               * @returns {Promise<casper.v1.EventInfoResponse>} Promise
               * @variation 2
               */

              return DeployService;
          })();

          v1.EventInfoResponse = (function() {

              /**
               * Properties of an EventInfoResponse.
               * @memberof casper.v1
               * @interface IEventInfoResponse
               * @property {IServiceError|null} [error] EventInfoResponse error
               * @property {casper.IBlockEventInfo|null} [result] EventInfoResponse result
               */

              /**
               * Constructs a new EventInfoResponse.
               * @memberof casper.v1
               * @classdesc Represents an EventInfoResponse.
               * @implements IEventInfoResponse
               * @constructor
               * @param {casper.v1.IEventInfoResponse=} [properties] Properties to set
               */
              function EventInfoResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * EventInfoResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.EventInfoResponse
               * @instance
               */
              EventInfoResponse.prototype.error = null;

              /**
               * EventInfoResponse result.
               * @member {casper.IBlockEventInfo|null|undefined} result
               * @memberof casper.v1.EventInfoResponse
               * @instance
               */
              EventInfoResponse.prototype.result = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * EventInfoResponse message.
               * @member {"error"|"result"|undefined} message
               * @memberof casper.v1.EventInfoResponse
               * @instance
               */
              Object.defineProperty(EventInfoResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "result"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new EventInfoResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {casper.v1.IEventInfoResponse=} [properties] Properties to set
               * @returns {casper.v1.EventInfoResponse} EventInfoResponse instance
               */
              EventInfoResponse.create = function create(properties) {
                  return new EventInfoResponse(properties);
              };

              /**
               * Encodes the specified EventInfoResponse message. Does not implicitly {@link casper.v1.EventInfoResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {casper.v1.IEventInfoResponse} message EventInfoResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EventInfoResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.result != null && message.hasOwnProperty("result"))
                      $root.casper.BlockEventInfo.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified EventInfoResponse message, length delimited. Does not implicitly {@link casper.v1.EventInfoResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {casper.v1.IEventInfoResponse} message EventInfoResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EventInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an EventInfoResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.EventInfoResponse} EventInfoResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EventInfoResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.EventInfoResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.result = $root.casper.BlockEventInfo.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an EventInfoResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.EventInfoResponse} EventInfoResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EventInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an EventInfoResponse message.
               * @function verify
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              EventInfoResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.BlockEventInfo.verify(message.result);
                          if (error)
                              return "result." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates an EventInfoResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.EventInfoResponse} EventInfoResponse
               */
              EventInfoResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.EventInfoResponse)
                      return object;
                  var message = new $root.casper.v1.EventInfoResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.EventInfoResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.result != null) {
                      if (typeof object.result !== "object")
                          throw TypeError(".casper.v1.EventInfoResponse.result: object expected");
                      message.result = $root.casper.BlockEventInfo.fromObject(object.result);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an EventInfoResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.EventInfoResponse
               * @static
               * @param {casper.v1.EventInfoResponse} message EventInfoResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              EventInfoResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      object.result = $root.casper.BlockEventInfo.toObject(message.result, options);
                      if (options.oneofs)
                          object.message = "result";
                  }
                  return object;
              };

              /**
               * Converts this EventInfoResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.EventInfoResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              EventInfoResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return EventInfoResponse;
          })();

          v1.ExploratoryDeployResponse = (function() {

              /**
               * Properties of an ExploratoryDeployResponse.
               * @memberof casper.v1
               * @interface IExploratoryDeployResponse
               * @property {IServiceError|null} [error] ExploratoryDeployResponse error
               * @property {casper.IDataWithBlockInfo|null} [result] ExploratoryDeployResponse result
               */

              /**
               * Constructs a new ExploratoryDeployResponse.
               * @memberof casper.v1
               * @classdesc Represents an ExploratoryDeployResponse.
               * @implements IExploratoryDeployResponse
               * @constructor
               * @param {casper.v1.IExploratoryDeployResponse=} [properties] Properties to set
               */
              function ExploratoryDeployResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ExploratoryDeployResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.ExploratoryDeployResponse
               * @instance
               */
              ExploratoryDeployResponse.prototype.error = null;

              /**
               * ExploratoryDeployResponse result.
               * @member {casper.IDataWithBlockInfo|null|undefined} result
               * @memberof casper.v1.ExploratoryDeployResponse
               * @instance
               */
              ExploratoryDeployResponse.prototype.result = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * ExploratoryDeployResponse message.
               * @member {"error"|"result"|undefined} message
               * @memberof casper.v1.ExploratoryDeployResponse
               * @instance
               */
              Object.defineProperty(ExploratoryDeployResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "result"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new ExploratoryDeployResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {casper.v1.IExploratoryDeployResponse=} [properties] Properties to set
               * @returns {casper.v1.ExploratoryDeployResponse} ExploratoryDeployResponse instance
               */
              ExploratoryDeployResponse.create = function create(properties) {
                  return new ExploratoryDeployResponse(properties);
              };

              /**
               * Encodes the specified ExploratoryDeployResponse message. Does not implicitly {@link casper.v1.ExploratoryDeployResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {casper.v1.IExploratoryDeployResponse} message ExploratoryDeployResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ExploratoryDeployResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.result != null && message.hasOwnProperty("result"))
                      $root.casper.DataWithBlockInfo.encode(message.result, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified ExploratoryDeployResponse message, length delimited. Does not implicitly {@link casper.v1.ExploratoryDeployResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {casper.v1.IExploratoryDeployResponse} message ExploratoryDeployResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ExploratoryDeployResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an ExploratoryDeployResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.ExploratoryDeployResponse} ExploratoryDeployResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ExploratoryDeployResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ExploratoryDeployResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.result = $root.casper.DataWithBlockInfo.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an ExploratoryDeployResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.ExploratoryDeployResponse} ExploratoryDeployResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ExploratoryDeployResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an ExploratoryDeployResponse message.
               * @function verify
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ExploratoryDeployResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.DataWithBlockInfo.verify(message.result);
                          if (error)
                              return "result." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates an ExploratoryDeployResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.ExploratoryDeployResponse} ExploratoryDeployResponse
               */
              ExploratoryDeployResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.ExploratoryDeployResponse)
                      return object;
                  var message = new $root.casper.v1.ExploratoryDeployResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.ExploratoryDeployResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.result != null) {
                      if (typeof object.result !== "object")
                          throw TypeError(".casper.v1.ExploratoryDeployResponse.result: object expected");
                      message.result = $root.casper.DataWithBlockInfo.fromObject(object.result);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an ExploratoryDeployResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.ExploratoryDeployResponse
               * @static
               * @param {casper.v1.ExploratoryDeployResponse} message ExploratoryDeployResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ExploratoryDeployResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      object.result = $root.casper.DataWithBlockInfo.toObject(message.result, options);
                      if (options.oneofs)
                          object.message = "result";
                  }
                  return object;
              };

              /**
               * Converts this ExploratoryDeployResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.ExploratoryDeployResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ExploratoryDeployResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ExploratoryDeployResponse;
          })();

          v1.DeployResponse = (function() {

              /**
               * Properties of a DeployResponse.
               * @memberof casper.v1
               * @interface IDeployResponse
               * @property {IServiceError|null} [error] DeployResponse error
               * @property {string|null} [result] DeployResponse result
               */

              /**
               * Constructs a new DeployResponse.
               * @memberof casper.v1
               * @classdesc Represents a DeployResponse.
               * @implements IDeployResponse
               * @constructor
               * @param {casper.v1.IDeployResponse=} [properties] Properties to set
               */
              function DeployResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * DeployResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.DeployResponse
               * @instance
               */
              DeployResponse.prototype.error = null;

              /**
               * DeployResponse result.
               * @member {string} result
               * @memberof casper.v1.DeployResponse
               * @instance
               */
              DeployResponse.prototype.result = "";

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * DeployResponse message.
               * @member {"error"|"result"|undefined} message
               * @memberof casper.v1.DeployResponse
               * @instance
               */
              Object.defineProperty(DeployResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "result"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new DeployResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {casper.v1.IDeployResponse=} [properties] Properties to set
               * @returns {casper.v1.DeployResponse} DeployResponse instance
               */
              DeployResponse.create = function create(properties) {
                  return new DeployResponse(properties);
              };

              /**
               * Encodes the specified DeployResponse message. Does not implicitly {@link casper.v1.DeployResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {casper.v1.IDeployResponse} message DeployResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              DeployResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.result != null && message.hasOwnProperty("result"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
                  return writer;
              };

              /**
               * Encodes the specified DeployResponse message, length delimited. Does not implicitly {@link casper.v1.DeployResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {casper.v1.IDeployResponse} message DeployResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              DeployResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a DeployResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.DeployResponse} DeployResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              DeployResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.DeployResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.result = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a DeployResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.DeployResponse} DeployResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              DeployResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a DeployResponse message.
               * @function verify
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              DeployResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      if (!$util.isString(message.result))
                          return "result: string expected";
                  }
                  return null;
              };

              /**
               * Creates a DeployResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.DeployResponse} DeployResponse
               */
              DeployResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.DeployResponse)
                      return object;
                  var message = new $root.casper.v1.DeployResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.DeployResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.result != null)
                      message.result = String(object.result);
                  return message;
              };

              /**
               * Creates a plain object from a DeployResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.DeployResponse
               * @static
               * @param {casper.v1.DeployResponse} message DeployResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              DeployResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      object.result = message.result;
                      if (options.oneofs)
                          object.message = "result";
                  }
                  return object;
              };

              /**
               * Converts this DeployResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.DeployResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              DeployResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return DeployResponse;
          })();

          v1.BlockResponse = (function() {

              /**
               * Properties of a BlockResponse.
               * @memberof casper.v1
               * @interface IBlockResponse
               * @property {IServiceError|null} [error] BlockResponse error
               * @property {casper.IBlockInfo|null} [blockInfo] BlockResponse blockInfo
               */

              /**
               * Constructs a new BlockResponse.
               * @memberof casper.v1
               * @classdesc Represents a BlockResponse.
               * @implements IBlockResponse
               * @constructor
               * @param {casper.v1.IBlockResponse=} [properties] Properties to set
               */
              function BlockResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * BlockResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.BlockResponse
               * @instance
               */
              BlockResponse.prototype.error = null;

              /**
               * BlockResponse blockInfo.
               * @member {casper.IBlockInfo|null|undefined} blockInfo
               * @memberof casper.v1.BlockResponse
               * @instance
               */
              BlockResponse.prototype.blockInfo = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * BlockResponse message.
               * @member {"error"|"blockInfo"|undefined} message
               * @memberof casper.v1.BlockResponse
               * @instance
               */
              Object.defineProperty(BlockResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new BlockResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {casper.v1.IBlockResponse=} [properties] Properties to set
               * @returns {casper.v1.BlockResponse} BlockResponse instance
               */
              BlockResponse.create = function create(properties) {
                  return new BlockResponse(properties);
              };

              /**
               * Encodes the specified BlockResponse message. Does not implicitly {@link casper.v1.BlockResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {casper.v1.IBlockResponse} message BlockResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              BlockResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                      $root.casper.BlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified BlockResponse message, length delimited. Does not implicitly {@link casper.v1.BlockResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {casper.v1.IBlockResponse} message BlockResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              BlockResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a BlockResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.BlockResponse} BlockResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              BlockResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.BlockResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.blockInfo = $root.casper.BlockInfo.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a BlockResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.BlockResponse} BlockResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              BlockResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a BlockResponse message.
               * @function verify
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              BlockResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.BlockInfo.verify(message.blockInfo);
                          if (error)
                              return "blockInfo." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a BlockResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.BlockResponse} BlockResponse
               */
              BlockResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.BlockResponse)
                      return object;
                  var message = new $root.casper.v1.BlockResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.BlockResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.blockInfo != null) {
                      if (typeof object.blockInfo !== "object")
                          throw TypeError(".casper.v1.BlockResponse.blockInfo: object expected");
                      message.blockInfo = $root.casper.BlockInfo.fromObject(object.blockInfo);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a BlockResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.BlockResponse
               * @static
               * @param {casper.v1.BlockResponse} message BlockResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              BlockResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      object.blockInfo = $root.casper.BlockInfo.toObject(message.blockInfo, options);
                      if (options.oneofs)
                          object.message = "blockInfo";
                  }
                  return object;
              };

              /**
               * Converts this BlockResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.BlockResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              BlockResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return BlockResponse;
          })();

          v1.VisualizeBlocksResponse = (function() {

              /**
               * Properties of a VisualizeBlocksResponse.
               * @memberof casper.v1
               * @interface IVisualizeBlocksResponse
               * @property {IServiceError|null} [error] VisualizeBlocksResponse error
               * @property {string|null} [content] VisualizeBlocksResponse content
               */

              /**
               * Constructs a new VisualizeBlocksResponse.
               * @memberof casper.v1
               * @classdesc Represents a VisualizeBlocksResponse.
               * @implements IVisualizeBlocksResponse
               * @constructor
               * @param {casper.v1.IVisualizeBlocksResponse=} [properties] Properties to set
               */
              function VisualizeBlocksResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * VisualizeBlocksResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.VisualizeBlocksResponse
               * @instance
               */
              VisualizeBlocksResponse.prototype.error = null;

              /**
               * VisualizeBlocksResponse content.
               * @member {string} content
               * @memberof casper.v1.VisualizeBlocksResponse
               * @instance
               */
              VisualizeBlocksResponse.prototype.content = "";

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * VisualizeBlocksResponse message.
               * @member {"error"|"content"|undefined} message
               * @memberof casper.v1.VisualizeBlocksResponse
               * @instance
               */
              Object.defineProperty(VisualizeBlocksResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "content"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new VisualizeBlocksResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {casper.v1.IVisualizeBlocksResponse=} [properties] Properties to set
               * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse instance
               */
              VisualizeBlocksResponse.create = function create(properties) {
                  return new VisualizeBlocksResponse(properties);
              };

              /**
               * Encodes the specified VisualizeBlocksResponse message. Does not implicitly {@link casper.v1.VisualizeBlocksResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {casper.v1.IVisualizeBlocksResponse} message VisualizeBlocksResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              VisualizeBlocksResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.content != null && message.hasOwnProperty("content"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                  return writer;
              };

              /**
               * Encodes the specified VisualizeBlocksResponse message, length delimited. Does not implicitly {@link casper.v1.VisualizeBlocksResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {casper.v1.IVisualizeBlocksResponse} message VisualizeBlocksResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              VisualizeBlocksResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a VisualizeBlocksResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              VisualizeBlocksResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.VisualizeBlocksResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.content = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a VisualizeBlocksResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              VisualizeBlocksResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a VisualizeBlocksResponse message.
               * @function verify
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              VisualizeBlocksResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.content != null && message.hasOwnProperty("content")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      if (!$util.isString(message.content))
                          return "content: string expected";
                  }
                  return null;
              };

              /**
               * Creates a VisualizeBlocksResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.VisualizeBlocksResponse} VisualizeBlocksResponse
               */
              VisualizeBlocksResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.VisualizeBlocksResponse)
                      return object;
                  var message = new $root.casper.v1.VisualizeBlocksResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.VisualizeBlocksResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.content != null)
                      message.content = String(object.content);
                  return message;
              };

              /**
               * Creates a plain object from a VisualizeBlocksResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.VisualizeBlocksResponse
               * @static
               * @param {casper.v1.VisualizeBlocksResponse} message VisualizeBlocksResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              VisualizeBlocksResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.content != null && message.hasOwnProperty("content")) {
                      object.content = message.content;
                      if (options.oneofs)
                          object.message = "content";
                  }
                  return object;
              };

              /**
               * Converts this VisualizeBlocksResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.VisualizeBlocksResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              VisualizeBlocksResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return VisualizeBlocksResponse;
          })();

          v1.MachineVerifyResponse = (function() {

              /**
               * Properties of a MachineVerifyResponse.
               * @memberof casper.v1
               * @interface IMachineVerifyResponse
               * @property {IServiceError|null} [error] MachineVerifyResponse error
               * @property {string|null} [content] MachineVerifyResponse content
               */

              /**
               * Constructs a new MachineVerifyResponse.
               * @memberof casper.v1
               * @classdesc Represents a MachineVerifyResponse.
               * @implements IMachineVerifyResponse
               * @constructor
               * @param {casper.v1.IMachineVerifyResponse=} [properties] Properties to set
               */
              function MachineVerifyResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * MachineVerifyResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.MachineVerifyResponse
               * @instance
               */
              MachineVerifyResponse.prototype.error = null;

              /**
               * MachineVerifyResponse content.
               * @member {string} content
               * @memberof casper.v1.MachineVerifyResponse
               * @instance
               */
              MachineVerifyResponse.prototype.content = "";

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * MachineVerifyResponse message.
               * @member {"error"|"content"|undefined} message
               * @memberof casper.v1.MachineVerifyResponse
               * @instance
               */
              Object.defineProperty(MachineVerifyResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "content"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new MachineVerifyResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {casper.v1.IMachineVerifyResponse=} [properties] Properties to set
               * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse instance
               */
              MachineVerifyResponse.create = function create(properties) {
                  return new MachineVerifyResponse(properties);
              };

              /**
               * Encodes the specified MachineVerifyResponse message. Does not implicitly {@link casper.v1.MachineVerifyResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {casper.v1.IMachineVerifyResponse} message MachineVerifyResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MachineVerifyResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.content != null && message.hasOwnProperty("content"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
                  return writer;
              };

              /**
               * Encodes the specified MachineVerifyResponse message, length delimited. Does not implicitly {@link casper.v1.MachineVerifyResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {casper.v1.IMachineVerifyResponse} message MachineVerifyResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MachineVerifyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a MachineVerifyResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MachineVerifyResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.MachineVerifyResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.content = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a MachineVerifyResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MachineVerifyResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a MachineVerifyResponse message.
               * @function verify
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              MachineVerifyResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.content != null && message.hasOwnProperty("content")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      if (!$util.isString(message.content))
                          return "content: string expected";
                  }
                  return null;
              };

              /**
               * Creates a MachineVerifyResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.MachineVerifyResponse} MachineVerifyResponse
               */
              MachineVerifyResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.MachineVerifyResponse)
                      return object;
                  var message = new $root.casper.v1.MachineVerifyResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.MachineVerifyResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.content != null)
                      message.content = String(object.content);
                  return message;
              };

              /**
               * Creates a plain object from a MachineVerifyResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.MachineVerifyResponse
               * @static
               * @param {casper.v1.MachineVerifyResponse} message MachineVerifyResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              MachineVerifyResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.content != null && message.hasOwnProperty("content")) {
                      object.content = message.content;
                      if (options.oneofs)
                          object.message = "content";
                  }
                  return object;
              };

              /**
               * Converts this MachineVerifyResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.MachineVerifyResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              MachineVerifyResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return MachineVerifyResponse;
          })();

          v1.BlockInfoResponse = (function() {

              /**
               * Properties of a BlockInfoResponse.
               * @memberof casper.v1
               * @interface IBlockInfoResponse
               * @property {IServiceError|null} [error] BlockInfoResponse error
               * @property {casper.ILightBlockInfo|null} [blockInfo] BlockInfoResponse blockInfo
               */

              /**
               * Constructs a new BlockInfoResponse.
               * @memberof casper.v1
               * @classdesc Represents a BlockInfoResponse.
               * @implements IBlockInfoResponse
               * @constructor
               * @param {casper.v1.IBlockInfoResponse=} [properties] Properties to set
               */
              function BlockInfoResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * BlockInfoResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.BlockInfoResponse
               * @instance
               */
              BlockInfoResponse.prototype.error = null;

              /**
               * BlockInfoResponse blockInfo.
               * @member {casper.ILightBlockInfo|null|undefined} blockInfo
               * @memberof casper.v1.BlockInfoResponse
               * @instance
               */
              BlockInfoResponse.prototype.blockInfo = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * BlockInfoResponse message.
               * @member {"error"|"blockInfo"|undefined} message
               * @memberof casper.v1.BlockInfoResponse
               * @instance
               */
              Object.defineProperty(BlockInfoResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new BlockInfoResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {casper.v1.IBlockInfoResponse=} [properties] Properties to set
               * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse instance
               */
              BlockInfoResponse.create = function create(properties) {
                  return new BlockInfoResponse(properties);
              };

              /**
               * Encodes the specified BlockInfoResponse message. Does not implicitly {@link casper.v1.BlockInfoResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {casper.v1.IBlockInfoResponse} message BlockInfoResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              BlockInfoResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                      $root.casper.LightBlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified BlockInfoResponse message, length delimited. Does not implicitly {@link casper.v1.BlockInfoResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {casper.v1.IBlockInfoResponse} message BlockInfoResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              BlockInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a BlockInfoResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              BlockInfoResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.BlockInfoResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.blockInfo = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a BlockInfoResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              BlockInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a BlockInfoResponse message.
               * @function verify
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              BlockInfoResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.LightBlockInfo.verify(message.blockInfo);
                          if (error)
                              return "blockInfo." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a BlockInfoResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.BlockInfoResponse} BlockInfoResponse
               */
              BlockInfoResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.BlockInfoResponse)
                      return object;
                  var message = new $root.casper.v1.BlockInfoResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.BlockInfoResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.blockInfo != null) {
                      if (typeof object.blockInfo !== "object")
                          throw TypeError(".casper.v1.BlockInfoResponse.blockInfo: object expected");
                      message.blockInfo = $root.casper.LightBlockInfo.fromObject(object.blockInfo);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a BlockInfoResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.BlockInfoResponse
               * @static
               * @param {casper.v1.BlockInfoResponse} message BlockInfoResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              BlockInfoResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      object.blockInfo = $root.casper.LightBlockInfo.toObject(message.blockInfo, options);
                      if (options.oneofs)
                          object.message = "blockInfo";
                  }
                  return object;
              };

              /**
               * Converts this BlockInfoResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.BlockInfoResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              BlockInfoResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return BlockInfoResponse;
          })();

          v1.ListeningNameDataResponse = (function() {

              /**
               * Properties of a ListeningNameDataResponse.
               * @memberof casper.v1
               * @interface IListeningNameDataResponse
               * @property {IServiceError|null} [error] ListeningNameDataResponse error
               * @property {casper.v1.IListeningNameDataPayload|null} [payload] ListeningNameDataResponse payload
               */

              /**
               * Constructs a new ListeningNameDataResponse.
               * @memberof casper.v1
               * @classdesc Represents a ListeningNameDataResponse.
               * @implements IListeningNameDataResponse
               * @constructor
               * @param {casper.v1.IListeningNameDataResponse=} [properties] Properties to set
               */
              function ListeningNameDataResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ListeningNameDataResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.ListeningNameDataResponse
               * @instance
               */
              ListeningNameDataResponse.prototype.error = null;

              /**
               * ListeningNameDataResponse payload.
               * @member {casper.v1.IListeningNameDataPayload|null|undefined} payload
               * @memberof casper.v1.ListeningNameDataResponse
               * @instance
               */
              ListeningNameDataResponse.prototype.payload = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * ListeningNameDataResponse message.
               * @member {"error"|"payload"|undefined} message
               * @memberof casper.v1.ListeningNameDataResponse
               * @instance
               */
              Object.defineProperty(ListeningNameDataResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "payload"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new ListeningNameDataResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {casper.v1.IListeningNameDataResponse=} [properties] Properties to set
               * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse instance
               */
              ListeningNameDataResponse.create = function create(properties) {
                  return new ListeningNameDataResponse(properties);
              };

              /**
               * Encodes the specified ListeningNameDataResponse message. Does not implicitly {@link casper.v1.ListeningNameDataResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {casper.v1.IListeningNameDataResponse} message ListeningNameDataResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ListeningNameDataResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.payload != null && message.hasOwnProperty("payload"))
                      $root.casper.v1.ListeningNameDataPayload.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified ListeningNameDataResponse message, length delimited. Does not implicitly {@link casper.v1.ListeningNameDataResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {casper.v1.IListeningNameDataResponse} message ListeningNameDataResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ListeningNameDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ListeningNameDataResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ListeningNameDataResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ListeningNameDataResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.payload = $root.casper.v1.ListeningNameDataPayload.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ListeningNameDataResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ListeningNameDataResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ListeningNameDataResponse message.
               * @function verify
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ListeningNameDataResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.payload != null && message.hasOwnProperty("payload")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.v1.ListeningNameDataPayload.verify(message.payload);
                          if (error)
                              return "payload." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a ListeningNameDataResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.ListeningNameDataResponse} ListeningNameDataResponse
               */
              ListeningNameDataResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.ListeningNameDataResponse)
                      return object;
                  var message = new $root.casper.v1.ListeningNameDataResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.ListeningNameDataResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.payload != null) {
                      if (typeof object.payload !== "object")
                          throw TypeError(".casper.v1.ListeningNameDataResponse.payload: object expected");
                      message.payload = $root.casper.v1.ListeningNameDataPayload.fromObject(object.payload);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a ListeningNameDataResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.ListeningNameDataResponse
               * @static
               * @param {casper.v1.ListeningNameDataResponse} message ListeningNameDataResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ListeningNameDataResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.payload != null && message.hasOwnProperty("payload")) {
                      object.payload = $root.casper.v1.ListeningNameDataPayload.toObject(message.payload, options);
                      if (options.oneofs)
                          object.message = "payload";
                  }
                  return object;
              };

              /**
               * Converts this ListeningNameDataResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.ListeningNameDataResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ListeningNameDataResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ListeningNameDataResponse;
          })();

          v1.ListeningNameDataPayload = (function() {

              /**
               * Properties of a ListeningNameDataPayload.
               * @memberof casper.v1
               * @interface IListeningNameDataPayload
               * @property {Array.<casper.IDataWithBlockInfo>|null} [blockInfo] ListeningNameDataPayload blockInfo
               * @property {number|null} [length] ListeningNameDataPayload length
               */

              /**
               * Constructs a new ListeningNameDataPayload.
               * @memberof casper.v1
               * @classdesc Represents a ListeningNameDataPayload.
               * @implements IListeningNameDataPayload
               * @constructor
               * @param {casper.v1.IListeningNameDataPayload=} [properties] Properties to set
               */
              function ListeningNameDataPayload(properties) {
                  this.blockInfo = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ListeningNameDataPayload blockInfo.
               * @member {Array.<casper.IDataWithBlockInfo>} blockInfo
               * @memberof casper.v1.ListeningNameDataPayload
               * @instance
               */
              ListeningNameDataPayload.prototype.blockInfo = $util.emptyArray;

              /**
               * ListeningNameDataPayload length.
               * @member {number} length
               * @memberof casper.v1.ListeningNameDataPayload
               * @instance
               */
              ListeningNameDataPayload.prototype.length = 0;

              /**
               * Creates a new ListeningNameDataPayload instance using the specified properties.
               * @function create
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {casper.v1.IListeningNameDataPayload=} [properties] Properties to set
               * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload instance
               */
              ListeningNameDataPayload.create = function create(properties) {
                  return new ListeningNameDataPayload(properties);
              };

              /**
               * Encodes the specified ListeningNameDataPayload message. Does not implicitly {@link casper.v1.ListeningNameDataPayload.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {casper.v1.IListeningNameDataPayload} message ListeningNameDataPayload message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ListeningNameDataPayload.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.blockInfo != null && message.blockInfo.length)
                      for (var i = 0; i < message.blockInfo.length; ++i)
                          $root.casper.DataWithBlockInfo.encode(message.blockInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.length != null && message.hasOwnProperty("length"))
                      writer.uint32(/* id 2, wireType 0 =*/16).int32(message.length);
                  return writer;
              };

              /**
               * Encodes the specified ListeningNameDataPayload message, length delimited. Does not implicitly {@link casper.v1.ListeningNameDataPayload.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {casper.v1.IListeningNameDataPayload} message ListeningNameDataPayload message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ListeningNameDataPayload.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ListeningNameDataPayload message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ListeningNameDataPayload.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ListeningNameDataPayload();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          if (!(message.blockInfo && message.blockInfo.length))
                              message.blockInfo = [];
                          message.blockInfo.push($root.casper.DataWithBlockInfo.decode(reader, reader.uint32()));
                          break;
                      case 2:
                          message.length = reader.int32();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ListeningNameDataPayload message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ListeningNameDataPayload.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ListeningNameDataPayload message.
               * @function verify
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ListeningNameDataPayload.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      if (!Array.isArray(message.blockInfo))
                          return "blockInfo: array expected";
                      for (var i = 0; i < message.blockInfo.length; ++i) {
                          var error = $root.casper.DataWithBlockInfo.verify(message.blockInfo[i]);
                          if (error)
                              return "blockInfo." + error;
                      }
                  }
                  if (message.length != null && message.hasOwnProperty("length"))
                      if (!$util.isInteger(message.length))
                          return "length: integer expected";
                  return null;
              };

              /**
               * Creates a ListeningNameDataPayload message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.ListeningNameDataPayload} ListeningNameDataPayload
               */
              ListeningNameDataPayload.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.ListeningNameDataPayload)
                      return object;
                  var message = new $root.casper.v1.ListeningNameDataPayload();
                  if (object.blockInfo) {
                      if (!Array.isArray(object.blockInfo))
                          throw TypeError(".casper.v1.ListeningNameDataPayload.blockInfo: array expected");
                      message.blockInfo = [];
                      for (var i = 0; i < object.blockInfo.length; ++i) {
                          if (typeof object.blockInfo[i] !== "object")
                              throw TypeError(".casper.v1.ListeningNameDataPayload.blockInfo: object expected");
                          message.blockInfo[i] = $root.casper.DataWithBlockInfo.fromObject(object.blockInfo[i]);
                      }
                  }
                  if (object.length != null)
                      message.length = object.length | 0;
                  return message;
              };

              /**
               * Creates a plain object from a ListeningNameDataPayload message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.ListeningNameDataPayload
               * @static
               * @param {casper.v1.ListeningNameDataPayload} message ListeningNameDataPayload
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ListeningNameDataPayload.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.blockInfo = [];
                  if (options.defaults)
                      object.length = 0;
                  if (message.blockInfo && message.blockInfo.length) {
                      object.blockInfo = [];
                      for (var j = 0; j < message.blockInfo.length; ++j)
                          object.blockInfo[j] = $root.casper.DataWithBlockInfo.toObject(message.blockInfo[j], options);
                  }
                  if (message.length != null && message.hasOwnProperty("length"))
                      object.length = message.length;
                  return object;
              };

              /**
               * Converts this ListeningNameDataPayload to JSON.
               * @function toJSON
               * @memberof casper.v1.ListeningNameDataPayload
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ListeningNameDataPayload.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ListeningNameDataPayload;
          })();

          v1.ContinuationAtNameResponse = (function() {

              /**
               * Properties of a ContinuationAtNameResponse.
               * @memberof casper.v1
               * @interface IContinuationAtNameResponse
               * @property {IServiceError|null} [error] ContinuationAtNameResponse error
               * @property {casper.v1.IContinuationAtNamePayload|null} [payload] ContinuationAtNameResponse payload
               */

              /**
               * Constructs a new ContinuationAtNameResponse.
               * @memberof casper.v1
               * @classdesc Represents a ContinuationAtNameResponse.
               * @implements IContinuationAtNameResponse
               * @constructor
               * @param {casper.v1.IContinuationAtNameResponse=} [properties] Properties to set
               */
              function ContinuationAtNameResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ContinuationAtNameResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.ContinuationAtNameResponse
               * @instance
               */
              ContinuationAtNameResponse.prototype.error = null;

              /**
               * ContinuationAtNameResponse payload.
               * @member {casper.v1.IContinuationAtNamePayload|null|undefined} payload
               * @memberof casper.v1.ContinuationAtNameResponse
               * @instance
               */
              ContinuationAtNameResponse.prototype.payload = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * ContinuationAtNameResponse message.
               * @member {"error"|"payload"|undefined} message
               * @memberof casper.v1.ContinuationAtNameResponse
               * @instance
               */
              Object.defineProperty(ContinuationAtNameResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "payload"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new ContinuationAtNameResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {casper.v1.IContinuationAtNameResponse=} [properties] Properties to set
               * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse instance
               */
              ContinuationAtNameResponse.create = function create(properties) {
                  return new ContinuationAtNameResponse(properties);
              };

              /**
               * Encodes the specified ContinuationAtNameResponse message. Does not implicitly {@link casper.v1.ContinuationAtNameResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {casper.v1.IContinuationAtNameResponse} message ContinuationAtNameResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ContinuationAtNameResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.payload != null && message.hasOwnProperty("payload"))
                      $root.casper.v1.ContinuationAtNamePayload.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified ContinuationAtNameResponse message, length delimited. Does not implicitly {@link casper.v1.ContinuationAtNameResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {casper.v1.IContinuationAtNameResponse} message ContinuationAtNameResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ContinuationAtNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ContinuationAtNameResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ContinuationAtNameResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ContinuationAtNameResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.payload = $root.casper.v1.ContinuationAtNamePayload.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ContinuationAtNameResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ContinuationAtNameResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ContinuationAtNameResponse message.
               * @function verify
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ContinuationAtNameResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.payload != null && message.hasOwnProperty("payload")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.v1.ContinuationAtNamePayload.verify(message.payload);
                          if (error)
                              return "payload." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a ContinuationAtNameResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.ContinuationAtNameResponse} ContinuationAtNameResponse
               */
              ContinuationAtNameResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.ContinuationAtNameResponse)
                      return object;
                  var message = new $root.casper.v1.ContinuationAtNameResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.ContinuationAtNameResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.payload != null) {
                      if (typeof object.payload !== "object")
                          throw TypeError(".casper.v1.ContinuationAtNameResponse.payload: object expected");
                      message.payload = $root.casper.v1.ContinuationAtNamePayload.fromObject(object.payload);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a ContinuationAtNameResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.ContinuationAtNameResponse
               * @static
               * @param {casper.v1.ContinuationAtNameResponse} message ContinuationAtNameResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ContinuationAtNameResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.payload != null && message.hasOwnProperty("payload")) {
                      object.payload = $root.casper.v1.ContinuationAtNamePayload.toObject(message.payload, options);
                      if (options.oneofs)
                          object.message = "payload";
                  }
                  return object;
              };

              /**
               * Converts this ContinuationAtNameResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.ContinuationAtNameResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ContinuationAtNameResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ContinuationAtNameResponse;
          })();

          v1.ContinuationAtNamePayload = (function() {

              /**
               * Properties of a ContinuationAtNamePayload.
               * @memberof casper.v1
               * @interface IContinuationAtNamePayload
               * @property {Array.<casper.IContinuationsWithBlockInfo>|null} [blockResults] ContinuationAtNamePayload blockResults
               * @property {number|null} [length] ContinuationAtNamePayload length
               */

              /**
               * Constructs a new ContinuationAtNamePayload.
               * @memberof casper.v1
               * @classdesc Represents a ContinuationAtNamePayload.
               * @implements IContinuationAtNamePayload
               * @constructor
               * @param {casper.v1.IContinuationAtNamePayload=} [properties] Properties to set
               */
              function ContinuationAtNamePayload(properties) {
                  this.blockResults = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ContinuationAtNamePayload blockResults.
               * @member {Array.<casper.IContinuationsWithBlockInfo>} blockResults
               * @memberof casper.v1.ContinuationAtNamePayload
               * @instance
               */
              ContinuationAtNamePayload.prototype.blockResults = $util.emptyArray;

              /**
               * ContinuationAtNamePayload length.
               * @member {number} length
               * @memberof casper.v1.ContinuationAtNamePayload
               * @instance
               */
              ContinuationAtNamePayload.prototype.length = 0;

              /**
               * Creates a new ContinuationAtNamePayload instance using the specified properties.
               * @function create
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {casper.v1.IContinuationAtNamePayload=} [properties] Properties to set
               * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload instance
               */
              ContinuationAtNamePayload.create = function create(properties) {
                  return new ContinuationAtNamePayload(properties);
              };

              /**
               * Encodes the specified ContinuationAtNamePayload message. Does not implicitly {@link casper.v1.ContinuationAtNamePayload.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {casper.v1.IContinuationAtNamePayload} message ContinuationAtNamePayload message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ContinuationAtNamePayload.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.blockResults != null && message.blockResults.length)
                      for (var i = 0; i < message.blockResults.length; ++i)
                          $root.casper.ContinuationsWithBlockInfo.encode(message.blockResults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.length != null && message.hasOwnProperty("length"))
                      writer.uint32(/* id 2, wireType 0 =*/16).int32(message.length);
                  return writer;
              };

              /**
               * Encodes the specified ContinuationAtNamePayload message, length delimited. Does not implicitly {@link casper.v1.ContinuationAtNamePayload.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {casper.v1.IContinuationAtNamePayload} message ContinuationAtNamePayload message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ContinuationAtNamePayload.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ContinuationAtNamePayload message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ContinuationAtNamePayload.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ContinuationAtNamePayload();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          if (!(message.blockResults && message.blockResults.length))
                              message.blockResults = [];
                          message.blockResults.push($root.casper.ContinuationsWithBlockInfo.decode(reader, reader.uint32()));
                          break;
                      case 2:
                          message.length = reader.int32();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ContinuationAtNamePayload message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ContinuationAtNamePayload.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ContinuationAtNamePayload message.
               * @function verify
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ContinuationAtNamePayload.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.blockResults != null && message.hasOwnProperty("blockResults")) {
                      if (!Array.isArray(message.blockResults))
                          return "blockResults: array expected";
                      for (var i = 0; i < message.blockResults.length; ++i) {
                          var error = $root.casper.ContinuationsWithBlockInfo.verify(message.blockResults[i]);
                          if (error)
                              return "blockResults." + error;
                      }
                  }
                  if (message.length != null && message.hasOwnProperty("length"))
                      if (!$util.isInteger(message.length))
                          return "length: integer expected";
                  return null;
              };

              /**
               * Creates a ContinuationAtNamePayload message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.ContinuationAtNamePayload} ContinuationAtNamePayload
               */
              ContinuationAtNamePayload.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.ContinuationAtNamePayload)
                      return object;
                  var message = new $root.casper.v1.ContinuationAtNamePayload();
                  if (object.blockResults) {
                      if (!Array.isArray(object.blockResults))
                          throw TypeError(".casper.v1.ContinuationAtNamePayload.blockResults: array expected");
                      message.blockResults = [];
                      for (var i = 0; i < object.blockResults.length; ++i) {
                          if (typeof object.blockResults[i] !== "object")
                              throw TypeError(".casper.v1.ContinuationAtNamePayload.blockResults: object expected");
                          message.blockResults[i] = $root.casper.ContinuationsWithBlockInfo.fromObject(object.blockResults[i]);
                      }
                  }
                  if (object.length != null)
                      message.length = object.length | 0;
                  return message;
              };

              /**
               * Creates a plain object from a ContinuationAtNamePayload message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.ContinuationAtNamePayload
               * @static
               * @param {casper.v1.ContinuationAtNamePayload} message ContinuationAtNamePayload
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ContinuationAtNamePayload.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.blockResults = [];
                  if (options.defaults)
                      object.length = 0;
                  if (message.blockResults && message.blockResults.length) {
                      object.blockResults = [];
                      for (var j = 0; j < message.blockResults.length; ++j)
                          object.blockResults[j] = $root.casper.ContinuationsWithBlockInfo.toObject(message.blockResults[j], options);
                  }
                  if (message.length != null && message.hasOwnProperty("length"))
                      object.length = message.length;
                  return object;
              };

              /**
               * Converts this ContinuationAtNamePayload to JSON.
               * @function toJSON
               * @memberof casper.v1.ContinuationAtNamePayload
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ContinuationAtNamePayload.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ContinuationAtNamePayload;
          })();

          v1.FindDeployResponse = (function() {

              /**
               * Properties of a FindDeployResponse.
               * @memberof casper.v1
               * @interface IFindDeployResponse
               * @property {IServiceError|null} [error] FindDeployResponse error
               * @property {casper.ILightBlockInfo|null} [blockInfo] FindDeployResponse blockInfo
               */

              /**
               * Constructs a new FindDeployResponse.
               * @memberof casper.v1
               * @classdesc Represents a FindDeployResponse.
               * @implements IFindDeployResponse
               * @constructor
               * @param {casper.v1.IFindDeployResponse=} [properties] Properties to set
               */
              function FindDeployResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * FindDeployResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.FindDeployResponse
               * @instance
               */
              FindDeployResponse.prototype.error = null;

              /**
               * FindDeployResponse blockInfo.
               * @member {casper.ILightBlockInfo|null|undefined} blockInfo
               * @memberof casper.v1.FindDeployResponse
               * @instance
               */
              FindDeployResponse.prototype.blockInfo = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * FindDeployResponse message.
               * @member {"error"|"blockInfo"|undefined} message
               * @memberof casper.v1.FindDeployResponse
               * @instance
               */
              Object.defineProperty(FindDeployResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new FindDeployResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {casper.v1.IFindDeployResponse=} [properties] Properties to set
               * @returns {casper.v1.FindDeployResponse} FindDeployResponse instance
               */
              FindDeployResponse.create = function create(properties) {
                  return new FindDeployResponse(properties);
              };

              /**
               * Encodes the specified FindDeployResponse message. Does not implicitly {@link casper.v1.FindDeployResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {casper.v1.IFindDeployResponse} message FindDeployResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FindDeployResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                      $root.casper.LightBlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified FindDeployResponse message, length delimited. Does not implicitly {@link casper.v1.FindDeployResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {casper.v1.IFindDeployResponse} message FindDeployResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FindDeployResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a FindDeployResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.FindDeployResponse} FindDeployResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FindDeployResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.FindDeployResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.blockInfo = $root.casper.LightBlockInfo.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a FindDeployResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.FindDeployResponse} FindDeployResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FindDeployResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a FindDeployResponse message.
               * @function verify
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              FindDeployResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.LightBlockInfo.verify(message.blockInfo);
                          if (error)
                              return "blockInfo." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a FindDeployResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.FindDeployResponse} FindDeployResponse
               */
              FindDeployResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.FindDeployResponse)
                      return object;
                  var message = new $root.casper.v1.FindDeployResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.FindDeployResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.blockInfo != null) {
                      if (typeof object.blockInfo !== "object")
                          throw TypeError(".casper.v1.FindDeployResponse.blockInfo: object expected");
                      message.blockInfo = $root.casper.LightBlockInfo.fromObject(object.blockInfo);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a FindDeployResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.FindDeployResponse
               * @static
               * @param {casper.v1.FindDeployResponse} message FindDeployResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              FindDeployResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      object.blockInfo = $root.casper.LightBlockInfo.toObject(message.blockInfo, options);
                      if (options.oneofs)
                          object.message = "blockInfo";
                  }
                  return object;
              };

              /**
               * Converts this FindDeployResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.FindDeployResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              FindDeployResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return FindDeployResponse;
          })();

          v1.PrivateNamePreviewResponse = (function() {

              /**
               * Properties of a PrivateNamePreviewResponse.
               * @memberof casper.v1
               * @interface IPrivateNamePreviewResponse
               * @property {IServiceError|null} [error] PrivateNamePreviewResponse error
               * @property {casper.v1.IPrivateNamePreviewPayload|null} [payload] PrivateNamePreviewResponse payload
               */

              /**
               * Constructs a new PrivateNamePreviewResponse.
               * @memberof casper.v1
               * @classdesc Represents a PrivateNamePreviewResponse.
               * @implements IPrivateNamePreviewResponse
               * @constructor
               * @param {casper.v1.IPrivateNamePreviewResponse=} [properties] Properties to set
               */
              function PrivateNamePreviewResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * PrivateNamePreviewResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @instance
               */
              PrivateNamePreviewResponse.prototype.error = null;

              /**
               * PrivateNamePreviewResponse payload.
               * @member {casper.v1.IPrivateNamePreviewPayload|null|undefined} payload
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @instance
               */
              PrivateNamePreviewResponse.prototype.payload = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * PrivateNamePreviewResponse message.
               * @member {"error"|"payload"|undefined} message
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @instance
               */
              Object.defineProperty(PrivateNamePreviewResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "payload"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new PrivateNamePreviewResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {casper.v1.IPrivateNamePreviewResponse=} [properties] Properties to set
               * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse instance
               */
              PrivateNamePreviewResponse.create = function create(properties) {
                  return new PrivateNamePreviewResponse(properties);
              };

              /**
               * Encodes the specified PrivateNamePreviewResponse message. Does not implicitly {@link casper.v1.PrivateNamePreviewResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {casper.v1.IPrivateNamePreviewResponse} message PrivateNamePreviewResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              PrivateNamePreviewResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.payload != null && message.hasOwnProperty("payload"))
                      $root.casper.v1.PrivateNamePreviewPayload.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified PrivateNamePreviewResponse message, length delimited. Does not implicitly {@link casper.v1.PrivateNamePreviewResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {casper.v1.IPrivateNamePreviewResponse} message PrivateNamePreviewResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              PrivateNamePreviewResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a PrivateNamePreviewResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              PrivateNamePreviewResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.PrivateNamePreviewResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.payload = $root.casper.v1.PrivateNamePreviewPayload.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a PrivateNamePreviewResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              PrivateNamePreviewResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a PrivateNamePreviewResponse message.
               * @function verify
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              PrivateNamePreviewResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.payload != null && message.hasOwnProperty("payload")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.v1.PrivateNamePreviewPayload.verify(message.payload);
                          if (error)
                              return "payload." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a PrivateNamePreviewResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.PrivateNamePreviewResponse} PrivateNamePreviewResponse
               */
              PrivateNamePreviewResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.PrivateNamePreviewResponse)
                      return object;
                  var message = new $root.casper.v1.PrivateNamePreviewResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.PrivateNamePreviewResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.payload != null) {
                      if (typeof object.payload !== "object")
                          throw TypeError(".casper.v1.PrivateNamePreviewResponse.payload: object expected");
                      message.payload = $root.casper.v1.PrivateNamePreviewPayload.fromObject(object.payload);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a PrivateNamePreviewResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @static
               * @param {casper.v1.PrivateNamePreviewResponse} message PrivateNamePreviewResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              PrivateNamePreviewResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.payload != null && message.hasOwnProperty("payload")) {
                      object.payload = $root.casper.v1.PrivateNamePreviewPayload.toObject(message.payload, options);
                      if (options.oneofs)
                          object.message = "payload";
                  }
                  return object;
              };

              /**
               * Converts this PrivateNamePreviewResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.PrivateNamePreviewResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              PrivateNamePreviewResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return PrivateNamePreviewResponse;
          })();

          v1.PrivateNamePreviewPayload = (function() {

              /**
               * Properties of a PrivateNamePreviewPayload.
               * @memberof casper.v1
               * @interface IPrivateNamePreviewPayload
               * @property {Array.<Uint8Array>|null} [ids] PrivateNamePreviewPayload ids
               */

              /**
               * Constructs a new PrivateNamePreviewPayload.
               * @memberof casper.v1
               * @classdesc Represents a PrivateNamePreviewPayload.
               * @implements IPrivateNamePreviewPayload
               * @constructor
               * @param {casper.v1.IPrivateNamePreviewPayload=} [properties] Properties to set
               */
              function PrivateNamePreviewPayload(properties) {
                  this.ids = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * PrivateNamePreviewPayload ids.
               * @member {Array.<Uint8Array>} ids
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @instance
               */
              PrivateNamePreviewPayload.prototype.ids = $util.emptyArray;

              /**
               * Creates a new PrivateNamePreviewPayload instance using the specified properties.
               * @function create
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {casper.v1.IPrivateNamePreviewPayload=} [properties] Properties to set
               * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload instance
               */
              PrivateNamePreviewPayload.create = function create(properties) {
                  return new PrivateNamePreviewPayload(properties);
              };

              /**
               * Encodes the specified PrivateNamePreviewPayload message. Does not implicitly {@link casper.v1.PrivateNamePreviewPayload.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {casper.v1.IPrivateNamePreviewPayload} message PrivateNamePreviewPayload message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              PrivateNamePreviewPayload.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.ids != null && message.ids.length)
                      for (var i = 0; i < message.ids.length; ++i)
                          writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ids[i]);
                  return writer;
              };

              /**
               * Encodes the specified PrivateNamePreviewPayload message, length delimited. Does not implicitly {@link casper.v1.PrivateNamePreviewPayload.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {casper.v1.IPrivateNamePreviewPayload} message PrivateNamePreviewPayload message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              PrivateNamePreviewPayload.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a PrivateNamePreviewPayload message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              PrivateNamePreviewPayload.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.PrivateNamePreviewPayload();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          if (!(message.ids && message.ids.length))
                              message.ids = [];
                          message.ids.push(reader.bytes());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a PrivateNamePreviewPayload message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              PrivateNamePreviewPayload.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a PrivateNamePreviewPayload message.
               * @function verify
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              PrivateNamePreviewPayload.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.ids != null && message.hasOwnProperty("ids")) {
                      if (!Array.isArray(message.ids))
                          return "ids: array expected";
                      for (var i = 0; i < message.ids.length; ++i)
                          if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                              return "ids: buffer[] expected";
                  }
                  return null;
              };

              /**
               * Creates a PrivateNamePreviewPayload message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.PrivateNamePreviewPayload} PrivateNamePreviewPayload
               */
              PrivateNamePreviewPayload.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.PrivateNamePreviewPayload)
                      return object;
                  var message = new $root.casper.v1.PrivateNamePreviewPayload();
                  if (object.ids) {
                      if (!Array.isArray(object.ids))
                          throw TypeError(".casper.v1.PrivateNamePreviewPayload.ids: array expected");
                      message.ids = [];
                      for (var i = 0; i < object.ids.length; ++i)
                          if (typeof object.ids[i] === "string")
                              $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                          else if (object.ids[i].length)
                              message.ids[i] = object.ids[i];
                  }
                  return message;
              };

              /**
               * Creates a plain object from a PrivateNamePreviewPayload message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @static
               * @param {casper.v1.PrivateNamePreviewPayload} message PrivateNamePreviewPayload
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              PrivateNamePreviewPayload.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.ids = [];
                  if (message.ids && message.ids.length) {
                      object.ids = [];
                      for (var j = 0; j < message.ids.length; ++j)
                          object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
                  }
                  return object;
              };

              /**
               * Converts this PrivateNamePreviewPayload to JSON.
               * @function toJSON
               * @memberof casper.v1.PrivateNamePreviewPayload
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              PrivateNamePreviewPayload.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return PrivateNamePreviewPayload;
          })();

          v1.LastFinalizedBlockResponse = (function() {

              /**
               * Properties of a LastFinalizedBlockResponse.
               * @memberof casper.v1
               * @interface ILastFinalizedBlockResponse
               * @property {IServiceError|null} [error] LastFinalizedBlockResponse error
               * @property {casper.IBlockInfo|null} [blockInfo] LastFinalizedBlockResponse blockInfo
               */

              /**
               * Constructs a new LastFinalizedBlockResponse.
               * @memberof casper.v1
               * @classdesc Represents a LastFinalizedBlockResponse.
               * @implements ILastFinalizedBlockResponse
               * @constructor
               * @param {casper.v1.ILastFinalizedBlockResponse=} [properties] Properties to set
               */
              function LastFinalizedBlockResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * LastFinalizedBlockResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @instance
               */
              LastFinalizedBlockResponse.prototype.error = null;

              /**
               * LastFinalizedBlockResponse blockInfo.
               * @member {casper.IBlockInfo|null|undefined} blockInfo
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @instance
               */
              LastFinalizedBlockResponse.prototype.blockInfo = null;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * LastFinalizedBlockResponse message.
               * @member {"error"|"blockInfo"|undefined} message
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @instance
               */
              Object.defineProperty(LastFinalizedBlockResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "blockInfo"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new LastFinalizedBlockResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {casper.v1.ILastFinalizedBlockResponse=} [properties] Properties to set
               * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse instance
               */
              LastFinalizedBlockResponse.create = function create(properties) {
                  return new LastFinalizedBlockResponse(properties);
              };

              /**
               * Encodes the specified LastFinalizedBlockResponse message. Does not implicitly {@link casper.v1.LastFinalizedBlockResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {casper.v1.ILastFinalizedBlockResponse} message LastFinalizedBlockResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              LastFinalizedBlockResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo"))
                      $root.casper.BlockInfo.encode(message.blockInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified LastFinalizedBlockResponse message, length delimited. Does not implicitly {@link casper.v1.LastFinalizedBlockResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {casper.v1.ILastFinalizedBlockResponse} message LastFinalizedBlockResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              LastFinalizedBlockResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a LastFinalizedBlockResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              LastFinalizedBlockResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.LastFinalizedBlockResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.blockInfo = $root.casper.BlockInfo.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a LastFinalizedBlockResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              LastFinalizedBlockResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a LastFinalizedBlockResponse message.
               * @function verify
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              LastFinalizedBlockResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      {
                          var error = $root.casper.BlockInfo.verify(message.blockInfo);
                          if (error)
                              return "blockInfo." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a LastFinalizedBlockResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.LastFinalizedBlockResponse} LastFinalizedBlockResponse
               */
              LastFinalizedBlockResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.LastFinalizedBlockResponse)
                      return object;
                  var message = new $root.casper.v1.LastFinalizedBlockResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.LastFinalizedBlockResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.blockInfo != null) {
                      if (typeof object.blockInfo !== "object")
                          throw TypeError(".casper.v1.LastFinalizedBlockResponse.blockInfo: object expected");
                      message.blockInfo = $root.casper.BlockInfo.fromObject(object.blockInfo);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a LastFinalizedBlockResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @static
               * @param {casper.v1.LastFinalizedBlockResponse} message LastFinalizedBlockResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              LastFinalizedBlockResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.blockInfo != null && message.hasOwnProperty("blockInfo")) {
                      object.blockInfo = $root.casper.BlockInfo.toObject(message.blockInfo, options);
                      if (options.oneofs)
                          object.message = "blockInfo";
                  }
                  return object;
              };

              /**
               * Converts this LastFinalizedBlockResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.LastFinalizedBlockResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              LastFinalizedBlockResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return LastFinalizedBlockResponse;
          })();

          v1.IsFinalizedResponse = (function() {

              /**
               * Properties of an IsFinalizedResponse.
               * @memberof casper.v1
               * @interface IIsFinalizedResponse
               * @property {IServiceError|null} [error] IsFinalizedResponse error
               * @property {boolean|null} [isFinalized] IsFinalizedResponse isFinalized
               */

              /**
               * Constructs a new IsFinalizedResponse.
               * @memberof casper.v1
               * @classdesc Represents an IsFinalizedResponse.
               * @implements IIsFinalizedResponse
               * @constructor
               * @param {casper.v1.IIsFinalizedResponse=} [properties] Properties to set
               */
              function IsFinalizedResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * IsFinalizedResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.IsFinalizedResponse
               * @instance
               */
              IsFinalizedResponse.prototype.error = null;

              /**
               * IsFinalizedResponse isFinalized.
               * @member {boolean} isFinalized
               * @memberof casper.v1.IsFinalizedResponse
               * @instance
               */
              IsFinalizedResponse.prototype.isFinalized = false;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * IsFinalizedResponse message.
               * @member {"error"|"isFinalized"|undefined} message
               * @memberof casper.v1.IsFinalizedResponse
               * @instance
               */
              Object.defineProperty(IsFinalizedResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "isFinalized"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new IsFinalizedResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {casper.v1.IIsFinalizedResponse=} [properties] Properties to set
               * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse instance
               */
              IsFinalizedResponse.create = function create(properties) {
                  return new IsFinalizedResponse(properties);
              };

              /**
               * Encodes the specified IsFinalizedResponse message. Does not implicitly {@link casper.v1.IsFinalizedResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {casper.v1.IIsFinalizedResponse} message IsFinalizedResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              IsFinalizedResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.isFinalized != null && message.hasOwnProperty("isFinalized"))
                      writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFinalized);
                  return writer;
              };

              /**
               * Encodes the specified IsFinalizedResponse message, length delimited. Does not implicitly {@link casper.v1.IsFinalizedResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {casper.v1.IIsFinalizedResponse} message IsFinalizedResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              IsFinalizedResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an IsFinalizedResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              IsFinalizedResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.IsFinalizedResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.isFinalized = reader.bool();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an IsFinalizedResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              IsFinalizedResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an IsFinalizedResponse message.
               * @function verify
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              IsFinalizedResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.isFinalized != null && message.hasOwnProperty("isFinalized")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      if (typeof message.isFinalized !== "boolean")
                          return "isFinalized: boolean expected";
                  }
                  return null;
              };

              /**
               * Creates an IsFinalizedResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.IsFinalizedResponse} IsFinalizedResponse
               */
              IsFinalizedResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.IsFinalizedResponse)
                      return object;
                  var message = new $root.casper.v1.IsFinalizedResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.IsFinalizedResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.isFinalized != null)
                      message.isFinalized = Boolean(object.isFinalized);
                  return message;
              };

              /**
               * Creates a plain object from an IsFinalizedResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.IsFinalizedResponse
               * @static
               * @param {casper.v1.IsFinalizedResponse} message IsFinalizedResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              IsFinalizedResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.isFinalized != null && message.hasOwnProperty("isFinalized")) {
                      object.isFinalized = message.isFinalized;
                      if (options.oneofs)
                          object.message = "isFinalized";
                  }
                  return object;
              };

              /**
               * Converts this IsFinalizedResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.IsFinalizedResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              IsFinalizedResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return IsFinalizedResponse;
          })();

          v1.BondStatusResponse = (function() {

              /**
               * Properties of a BondStatusResponse.
               * @memberof casper.v1
               * @interface IBondStatusResponse
               * @property {IServiceError|null} [error] BondStatusResponse error
               * @property {boolean|null} [isBonded] BondStatusResponse isBonded
               */

              /**
               * Constructs a new BondStatusResponse.
               * @memberof casper.v1
               * @classdesc Represents a BondStatusResponse.
               * @implements IBondStatusResponse
               * @constructor
               * @param {casper.v1.IBondStatusResponse=} [properties] Properties to set
               */
              function BondStatusResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * BondStatusResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.BondStatusResponse
               * @instance
               */
              BondStatusResponse.prototype.error = null;

              /**
               * BondStatusResponse isBonded.
               * @member {boolean} isBonded
               * @memberof casper.v1.BondStatusResponse
               * @instance
               */
              BondStatusResponse.prototype.isBonded = false;

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * BondStatusResponse message.
               * @member {"error"|"isBonded"|undefined} message
               * @memberof casper.v1.BondStatusResponse
               * @instance
               */
              Object.defineProperty(BondStatusResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "isBonded"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new BondStatusResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {casper.v1.IBondStatusResponse=} [properties] Properties to set
               * @returns {casper.v1.BondStatusResponse} BondStatusResponse instance
               */
              BondStatusResponse.create = function create(properties) {
                  return new BondStatusResponse(properties);
              };

              /**
               * Encodes the specified BondStatusResponse message. Does not implicitly {@link casper.v1.BondStatusResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {casper.v1.IBondStatusResponse} message BondStatusResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              BondStatusResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.isBonded != null && message.hasOwnProperty("isBonded"))
                      writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBonded);
                  return writer;
              };

              /**
               * Encodes the specified BondStatusResponse message, length delimited. Does not implicitly {@link casper.v1.BondStatusResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {casper.v1.IBondStatusResponse} message BondStatusResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              BondStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a BondStatusResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.BondStatusResponse} BondStatusResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              BondStatusResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.BondStatusResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.isBonded = reader.bool();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a BondStatusResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.BondStatusResponse} BondStatusResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              BondStatusResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a BondStatusResponse message.
               * @function verify
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              BondStatusResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.isBonded != null && message.hasOwnProperty("isBonded")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      if (typeof message.isBonded !== "boolean")
                          return "isBonded: boolean expected";
                  }
                  return null;
              };

              /**
               * Creates a BondStatusResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.BondStatusResponse} BondStatusResponse
               */
              BondStatusResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.BondStatusResponse)
                      return object;
                  var message = new $root.casper.v1.BondStatusResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.BondStatusResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.isBonded != null)
                      message.isBonded = Boolean(object.isBonded);
                  return message;
              };

              /**
               * Creates a plain object from a BondStatusResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.BondStatusResponse
               * @static
               * @param {casper.v1.BondStatusResponse} message BondStatusResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              BondStatusResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.isBonded != null && message.hasOwnProperty("isBonded")) {
                      object.isBonded = message.isBonded;
                      if (options.oneofs)
                          object.message = "isBonded";
                  }
                  return object;
              };

              /**
               * Converts this BondStatusResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.BondStatusResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              BondStatusResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return BondStatusResponse;
          })();

          v1.ProposeService = (function() {

              /**
               * Constructs a new ProposeService service.
               * @memberof casper.v1
               * @classdesc Represents a ProposeService
               * @extends $protobuf.rpc.Service
               * @constructor
               * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
               * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
               * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
               */
              function ProposeService(rpcImpl, requestDelimited, responseDelimited) {
                  minimal$1.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
              }

              (ProposeService.prototype = Object.create(minimal$1.rpc.Service.prototype)).constructor = ProposeService;

              /**
               * Creates new ProposeService service using the specified rpc implementation.
               * @function create
               * @memberof casper.v1.ProposeService
               * @static
               * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
               * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
               * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
               * @returns {ProposeService} RPC service. Useful where requests and/or responses are streamed.
               */
              ProposeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
              };

              /**
               * Callback as used by {@link casper.v1.ProposeService#propose}.
               * @memberof casper.v1.ProposeService
               * @typedef proposeCallback
               * @type {function}
               * @param {Error|null} error Error, if any
               * @param {casper.v1.ProposeResponse} [response] ProposeResponse
               */

              /**
               * Calls propose.
               * @function propose
               * @memberof casper.v1.ProposeService
               * @instance
               * @param {casper.IPrintUnmatchedSendsQuery} request PrintUnmatchedSendsQuery message or plain object
               * @param {casper.v1.ProposeService.proposeCallback} callback Node-style callback called with the error, if any, and ProposeResponse
               * @returns {undefined}
               * @variation 1
               */
              Object.defineProperty(ProposeService.prototype.propose = function propose(request, callback) {
                  return this.rpcCall(propose, $root.casper.PrintUnmatchedSendsQuery, $root.casper.v1.ProposeResponse, request, callback);
              }, "name", { value: "propose" });

              /**
               * Calls propose.
               * @function propose
               * @memberof casper.v1.ProposeService
               * @instance
               * @param {casper.IPrintUnmatchedSendsQuery} request PrintUnmatchedSendsQuery message or plain object
               * @returns {Promise<casper.v1.ProposeResponse>} Promise
               * @variation 2
               */

              return ProposeService;
          })();

          v1.ProposeResponse = (function() {

              /**
               * Properties of a ProposeResponse.
               * @memberof casper.v1
               * @interface IProposeResponse
               * @property {IServiceError|null} [error] ProposeResponse error
               * @property {string|null} [result] ProposeResponse result
               */

              /**
               * Constructs a new ProposeResponse.
               * @memberof casper.v1
               * @classdesc Represents a ProposeResponse.
               * @implements IProposeResponse
               * @constructor
               * @param {casper.v1.IProposeResponse=} [properties] Properties to set
               */
              function ProposeResponse(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ProposeResponse error.
               * @member {IServiceError|null|undefined} error
               * @memberof casper.v1.ProposeResponse
               * @instance
               */
              ProposeResponse.prototype.error = null;

              /**
               * ProposeResponse result.
               * @member {string} result
               * @memberof casper.v1.ProposeResponse
               * @instance
               */
              ProposeResponse.prototype.result = "";

              // OneOf field names bound to virtual getters and setters
              var $oneOfFields;

              /**
               * ProposeResponse message.
               * @member {"error"|"result"|undefined} message
               * @memberof casper.v1.ProposeResponse
               * @instance
               */
              Object.defineProperty(ProposeResponse.prototype, "message", {
                  get: $util.oneOfGetter($oneOfFields = ["error", "result"]),
                  set: $util.oneOfSetter($oneOfFields)
              });

              /**
               * Creates a new ProposeResponse instance using the specified properties.
               * @function create
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {casper.v1.IProposeResponse=} [properties] Properties to set
               * @returns {casper.v1.ProposeResponse} ProposeResponse instance
               */
              ProposeResponse.create = function create(properties) {
                  return new ProposeResponse(properties);
              };

              /**
               * Encodes the specified ProposeResponse message. Does not implicitly {@link casper.v1.ProposeResponse.verify|verify} messages.
               * @function encode
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {casper.v1.IProposeResponse} message ProposeResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ProposeResponse.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.error != null && message.hasOwnProperty("error"))
                      $root.ServiceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  if (message.result != null && message.hasOwnProperty("result"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.result);
                  return writer;
              };

              /**
               * Encodes the specified ProposeResponse message, length delimited. Does not implicitly {@link casper.v1.ProposeResponse.verify|verify} messages.
               * @function encodeDelimited
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {casper.v1.IProposeResponse} message ProposeResponse message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ProposeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ProposeResponse message from the specified reader or buffer.
               * @function decode
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {casper.v1.ProposeResponse} ProposeResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ProposeResponse.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.v1.ProposeResponse();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.error = $root.ServiceError.decode(reader, reader.uint32());
                          break;
                      case 2:
                          message.result = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ProposeResponse message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {casper.v1.ProposeResponse} ProposeResponse
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ProposeResponse.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ProposeResponse message.
               * @function verify
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ProposeResponse.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  var properties = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      properties.message = 1;
                      {
                          var error = $root.ServiceError.verify(message.error);
                          if (error)
                              return "error." + error;
                      }
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      if (properties.message === 1)
                          return "message: multiple values";
                      properties.message = 1;
                      if (!$util.isString(message.result))
                          return "result: string expected";
                  }
                  return null;
              };

              /**
               * Creates a ProposeResponse message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {casper.v1.ProposeResponse} ProposeResponse
               */
              ProposeResponse.fromObject = function fromObject(object) {
                  if (object instanceof $root.casper.v1.ProposeResponse)
                      return object;
                  var message = new $root.casper.v1.ProposeResponse();
                  if (object.error != null) {
                      if (typeof object.error !== "object")
                          throw TypeError(".casper.v1.ProposeResponse.error: object expected");
                      message.error = $root.ServiceError.fromObject(object.error);
                  }
                  if (object.result != null)
                      message.result = String(object.result);
                  return message;
              };

              /**
               * Creates a plain object from a ProposeResponse message. Also converts values to other types if specified.
               * @function toObject
               * @memberof casper.v1.ProposeResponse
               * @static
               * @param {casper.v1.ProposeResponse} message ProposeResponse
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ProposeResponse.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (message.error != null && message.hasOwnProperty("error")) {
                      object.error = $root.ServiceError.toObject(message.error, options);
                      if (options.oneofs)
                          object.message = "error";
                  }
                  if (message.result != null && message.hasOwnProperty("result")) {
                      object.result = message.result;
                      if (options.oneofs)
                          object.message = "result";
                  }
                  return object;
              };

              /**
               * Converts this ProposeResponse to JSON.
               * @function toJSON
               * @memberof casper.v1.ProposeResponse
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ProposeResponse.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ProposeResponse;
          })();

          return v1;
      })();

      casper.PrintUnmatchedSendsQuery = (function() {

          /**
           * Properties of a PrintUnmatchedSendsQuery.
           * @memberof casper
           * @interface IPrintUnmatchedSendsQuery
           * @property {boolean|null} [printUnmatchedSends] PrintUnmatchedSendsQuery printUnmatchedSends
           */

          /**
           * Constructs a new PrintUnmatchedSendsQuery.
           * @memberof casper
           * @classdesc Represents a PrintUnmatchedSendsQuery.
           * @implements IPrintUnmatchedSendsQuery
           * @constructor
           * @param {casper.IPrintUnmatchedSendsQuery=} [properties] Properties to set
           */
          function PrintUnmatchedSendsQuery(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * PrintUnmatchedSendsQuery printUnmatchedSends.
           * @member {boolean} printUnmatchedSends
           * @memberof casper.PrintUnmatchedSendsQuery
           * @instance
           */
          PrintUnmatchedSendsQuery.prototype.printUnmatchedSends = false;

          /**
           * Creates a new PrintUnmatchedSendsQuery instance using the specified properties.
           * @function create
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {casper.IPrintUnmatchedSendsQuery=} [properties] Properties to set
           * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery instance
           */
          PrintUnmatchedSendsQuery.create = function create(properties) {
              return new PrintUnmatchedSendsQuery(properties);
          };

          /**
           * Encodes the specified PrintUnmatchedSendsQuery message. Does not implicitly {@link casper.PrintUnmatchedSendsQuery.verify|verify} messages.
           * @function encode
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {casper.IPrintUnmatchedSendsQuery} message PrintUnmatchedSendsQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PrintUnmatchedSendsQuery.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.printUnmatchedSends != null && message.hasOwnProperty("printUnmatchedSends"))
                  writer.uint32(/* id 1, wireType 0 =*/8).bool(message.printUnmatchedSends);
              return writer;
          };

          /**
           * Encodes the specified PrintUnmatchedSendsQuery message, length delimited. Does not implicitly {@link casper.PrintUnmatchedSendsQuery.verify|verify} messages.
           * @function encodeDelimited
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {casper.IPrintUnmatchedSendsQuery} message PrintUnmatchedSendsQuery message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PrintUnmatchedSendsQuery.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PrintUnmatchedSendsQuery message from the specified reader or buffer.
           * @function decode
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PrintUnmatchedSendsQuery.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.casper.PrintUnmatchedSendsQuery();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.printUnmatchedSends = reader.bool();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a PrintUnmatchedSendsQuery message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PrintUnmatchedSendsQuery.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PrintUnmatchedSendsQuery message.
           * @function verify
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PrintUnmatchedSendsQuery.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.printUnmatchedSends != null && message.hasOwnProperty("printUnmatchedSends"))
                  if (typeof message.printUnmatchedSends !== "boolean")
                      return "printUnmatchedSends: boolean expected";
              return null;
          };

          /**
           * Creates a PrintUnmatchedSendsQuery message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {casper.PrintUnmatchedSendsQuery} PrintUnmatchedSendsQuery
           */
          PrintUnmatchedSendsQuery.fromObject = function fromObject(object) {
              if (object instanceof $root.casper.PrintUnmatchedSendsQuery)
                  return object;
              var message = new $root.casper.PrintUnmatchedSendsQuery();
              if (object.printUnmatchedSends != null)
                  message.printUnmatchedSends = Boolean(object.printUnmatchedSends);
              return message;
          };

          /**
           * Creates a plain object from a PrintUnmatchedSendsQuery message. Also converts values to other types if specified.
           * @function toObject
           * @memberof casper.PrintUnmatchedSendsQuery
           * @static
           * @param {casper.PrintUnmatchedSendsQuery} message PrintUnmatchedSendsQuery
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PrintUnmatchedSendsQuery.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.printUnmatchedSends = false;
              if (message.printUnmatchedSends != null && message.hasOwnProperty("printUnmatchedSends"))
                  object.printUnmatchedSends = message.printUnmatchedSends;
              return object;
          };

          /**
           * Converts this PrintUnmatchedSendsQuery to JSON.
           * @function toJSON
           * @memberof casper.PrintUnmatchedSendsQuery
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PrintUnmatchedSendsQuery.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return PrintUnmatchedSendsQuery;
      })();

      return casper;
  })();

  $root.scalapb = (function() {

      /**
       * Namespace scalapb.
       * @exports scalapb
       * @namespace
       */
      var scalapb = {};

      scalapb.ScalaPbOptions = (function() {

          /**
           * Properties of a ScalaPbOptions.
           * @memberof scalapb
           * @interface IScalaPbOptions
           * @property {string|null} [package_name] ScalaPbOptions package_name
           * @property {boolean|null} [flat_package] ScalaPbOptions flat_package
           * @property {Array.<string>|null} ["import"] ScalaPbOptions import
           * @property {Array.<string>|null} [preamble] ScalaPbOptions preamble
           * @property {boolean|null} [single_file] ScalaPbOptions single_file
           * @property {boolean|null} [no_primitive_wrappers] ScalaPbOptions no_primitive_wrappers
           * @property {boolean|null} [primitive_wrappers] ScalaPbOptions primitive_wrappers
           * @property {string|null} [collection_type] ScalaPbOptions collection_type
           * @property {boolean|null} [preserve_unknown_fields] ScalaPbOptions preserve_unknown_fields
           * @property {string|null} [object_name] ScalaPbOptions object_name
           * @property {scalapb.ScalaPbOptions.OptionsScope|null} [scope] ScalaPbOptions scope
           * @property {boolean|null} [lenses] ScalaPbOptions lenses
           * @property {boolean|null} [retain_source_code_info] ScalaPbOptions retain_source_code_info
           * @property {string|null} [map_type] ScalaPbOptions map_type
           * @property {boolean|null} [no_default_values_in_constructor] ScalaPbOptions no_default_values_in_constructor
           * @property {scalapb.ScalaPbOptions.EnumValueNaming|null} [enum_value_naming] ScalaPbOptions enum_value_naming
           * @property {boolean|null} [enum_strip_prefix] ScalaPbOptions enum_strip_prefix
           * @property {string|null} [bytes_type] ScalaPbOptions bytes_type
           * @property {boolean|null} [java_conversions] ScalaPbOptions java_conversions
           * @property {Array.<scalapb.ScalaPbOptions.IAuxMessageOptions>|null} [aux_message_options] ScalaPbOptions aux_message_options
           * @property {Array.<scalapb.ScalaPbOptions.IAuxFieldOptions>|null} [aux_field_options] ScalaPbOptions aux_field_options
           * @property {Array.<scalapb.ScalaPbOptions.IAuxEnumOptions>|null} [aux_enum_options] ScalaPbOptions aux_enum_options
           * @property {Array.<scalapb.ScalaPbOptions.IAuxEnumValueOptions>|null} [aux_enum_value_options] ScalaPbOptions aux_enum_value_options
           * @property {boolean|null} [test_only_no_java_conversions] ScalaPbOptions test_only_no_java_conversions
           */

          /**
           * Constructs a new ScalaPbOptions.
           * @memberof scalapb
           * @classdesc Represents a ScalaPbOptions.
           * @implements IScalaPbOptions
           * @constructor
           * @param {scalapb.IScalaPbOptions=} [properties] Properties to set
           */
          function ScalaPbOptions(properties) {
              this["import"] = [];
              this.preamble = [];
              this.aux_message_options = [];
              this.aux_field_options = [];
              this.aux_enum_options = [];
              this.aux_enum_value_options = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ScalaPbOptions package_name.
           * @member {string} package_name
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.package_name = "";

          /**
           * ScalaPbOptions flat_package.
           * @member {boolean} flat_package
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.flat_package = false;

          /**
           * ScalaPbOptions import.
           * @member {Array.<string>} import
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype["import"] = $util.emptyArray;

          /**
           * ScalaPbOptions preamble.
           * @member {Array.<string>} preamble
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.preamble = $util.emptyArray;

          /**
           * ScalaPbOptions single_file.
           * @member {boolean} single_file
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.single_file = false;

          /**
           * ScalaPbOptions no_primitive_wrappers.
           * @member {boolean} no_primitive_wrappers
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.no_primitive_wrappers = false;

          /**
           * ScalaPbOptions primitive_wrappers.
           * @member {boolean} primitive_wrappers
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.primitive_wrappers = false;

          /**
           * ScalaPbOptions collection_type.
           * @member {string} collection_type
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.collection_type = "";

          /**
           * ScalaPbOptions preserve_unknown_fields.
           * @member {boolean} preserve_unknown_fields
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.preserve_unknown_fields = true;

          /**
           * ScalaPbOptions object_name.
           * @member {string} object_name
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.object_name = "";

          /**
           * ScalaPbOptions scope.
           * @member {scalapb.ScalaPbOptions.OptionsScope} scope
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.scope = 0;

          /**
           * ScalaPbOptions lenses.
           * @member {boolean} lenses
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.lenses = true;

          /**
           * ScalaPbOptions retain_source_code_info.
           * @member {boolean} retain_source_code_info
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.retain_source_code_info = false;

          /**
           * ScalaPbOptions map_type.
           * @member {string} map_type
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.map_type = "";

          /**
           * ScalaPbOptions no_default_values_in_constructor.
           * @member {boolean} no_default_values_in_constructor
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.no_default_values_in_constructor = false;

          /**
           * ScalaPbOptions enum_value_naming.
           * @member {scalapb.ScalaPbOptions.EnumValueNaming} enum_value_naming
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.enum_value_naming = 0;

          /**
           * ScalaPbOptions enum_strip_prefix.
           * @member {boolean} enum_strip_prefix
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.enum_strip_prefix = false;

          /**
           * ScalaPbOptions bytes_type.
           * @member {string} bytes_type
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.bytes_type = "";

          /**
           * ScalaPbOptions java_conversions.
           * @member {boolean} java_conversions
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.java_conversions = false;

          /**
           * ScalaPbOptions aux_message_options.
           * @member {Array.<scalapb.ScalaPbOptions.IAuxMessageOptions>} aux_message_options
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.aux_message_options = $util.emptyArray;

          /**
           * ScalaPbOptions aux_field_options.
           * @member {Array.<scalapb.ScalaPbOptions.IAuxFieldOptions>} aux_field_options
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.aux_field_options = $util.emptyArray;

          /**
           * ScalaPbOptions aux_enum_options.
           * @member {Array.<scalapb.ScalaPbOptions.IAuxEnumOptions>} aux_enum_options
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.aux_enum_options = $util.emptyArray;

          /**
           * ScalaPbOptions aux_enum_value_options.
           * @member {Array.<scalapb.ScalaPbOptions.IAuxEnumValueOptions>} aux_enum_value_options
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.aux_enum_value_options = $util.emptyArray;

          /**
           * ScalaPbOptions test_only_no_java_conversions.
           * @member {boolean} test_only_no_java_conversions
           * @memberof scalapb.ScalaPbOptions
           * @instance
           */
          ScalaPbOptions.prototype.test_only_no_java_conversions = false;

          /**
           * Creates a new ScalaPbOptions instance using the specified properties.
           * @function create
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {scalapb.IScalaPbOptions=} [properties] Properties to set
           * @returns {scalapb.ScalaPbOptions} ScalaPbOptions instance
           */
          ScalaPbOptions.create = function create(properties) {
              return new ScalaPbOptions(properties);
          };

          /**
           * Encodes the specified ScalaPbOptions message. Does not implicitly {@link scalapb.ScalaPbOptions.verify|verify} messages.
           * @function encode
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {scalapb.IScalaPbOptions} message ScalaPbOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ScalaPbOptions.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.package_name != null && message.hasOwnProperty("package_name"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.package_name);
              if (message.flat_package != null && message.hasOwnProperty("flat_package"))
                  writer.uint32(/* id 2, wireType 0 =*/16).bool(message.flat_package);
              if (message["import"] != null && message["import"].length)
                  for (var i = 0; i < message["import"].length; ++i)
                      writer.uint32(/* id 3, wireType 2 =*/26).string(message["import"][i]);
              if (message.preamble != null && message.preamble.length)
                  for (var i = 0; i < message.preamble.length; ++i)
                      writer.uint32(/* id 4, wireType 2 =*/34).string(message.preamble[i]);
              if (message.single_file != null && message.hasOwnProperty("single_file"))
                  writer.uint32(/* id 5, wireType 0 =*/40).bool(message.single_file);
              if (message.primitive_wrappers != null && message.hasOwnProperty("primitive_wrappers"))
                  writer.uint32(/* id 6, wireType 0 =*/48).bool(message.primitive_wrappers);
              if (message.no_primitive_wrappers != null && message.hasOwnProperty("no_primitive_wrappers"))
                  writer.uint32(/* id 7, wireType 0 =*/56).bool(message.no_primitive_wrappers);
              if (message.collection_type != null && message.hasOwnProperty("collection_type"))
                  writer.uint32(/* id 8, wireType 2 =*/66).string(message.collection_type);
              if (message.preserve_unknown_fields != null && message.hasOwnProperty("preserve_unknown_fields"))
                  writer.uint32(/* id 9, wireType 0 =*/72).bool(message.preserve_unknown_fields);
              if (message.object_name != null && message.hasOwnProperty("object_name"))
                  writer.uint32(/* id 10, wireType 2 =*/82).string(message.object_name);
              if (message.scope != null && message.hasOwnProperty("scope"))
                  writer.uint32(/* id 11, wireType 0 =*/88).int32(message.scope);
              if (message.lenses != null && message.hasOwnProperty("lenses"))
                  writer.uint32(/* id 12, wireType 0 =*/96).bool(message.lenses);
              if (message.retain_source_code_info != null && message.hasOwnProperty("retain_source_code_info"))
                  writer.uint32(/* id 13, wireType 0 =*/104).bool(message.retain_source_code_info);
              if (message.map_type != null && message.hasOwnProperty("map_type"))
                  writer.uint32(/* id 14, wireType 2 =*/114).string(message.map_type);
              if (message.no_default_values_in_constructor != null && message.hasOwnProperty("no_default_values_in_constructor"))
                  writer.uint32(/* id 15, wireType 0 =*/120).bool(message.no_default_values_in_constructor);
              if (message.enum_value_naming != null && message.hasOwnProperty("enum_value_naming"))
                  writer.uint32(/* id 16, wireType 0 =*/128).int32(message.enum_value_naming);
              if (message.enum_strip_prefix != null && message.hasOwnProperty("enum_strip_prefix"))
                  writer.uint32(/* id 17, wireType 0 =*/136).bool(message.enum_strip_prefix);
              if (message.aux_message_options != null && message.aux_message_options.length)
                  for (var i = 0; i < message.aux_message_options.length; ++i)
                      $root.scalapb.ScalaPbOptions.AuxMessageOptions.encode(message.aux_message_options[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
              if (message.aux_field_options != null && message.aux_field_options.length)
                  for (var i = 0; i < message.aux_field_options.length; ++i)
                      $root.scalapb.ScalaPbOptions.AuxFieldOptions.encode(message.aux_field_options[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
              if (message.aux_enum_options != null && message.aux_enum_options.length)
                  for (var i = 0; i < message.aux_enum_options.length; ++i)
                      $root.scalapb.ScalaPbOptions.AuxEnumOptions.encode(message.aux_enum_options[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
              if (message.bytes_type != null && message.hasOwnProperty("bytes_type"))
                  writer.uint32(/* id 21, wireType 2 =*/170).string(message.bytes_type);
              if (message.aux_enum_value_options != null && message.aux_enum_value_options.length)
                  for (var i = 0; i < message.aux_enum_value_options.length; ++i)
                      $root.scalapb.ScalaPbOptions.AuxEnumValueOptions.encode(message.aux_enum_value_options[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
              if (message.java_conversions != null && message.hasOwnProperty("java_conversions"))
                  writer.uint32(/* id 23, wireType 0 =*/184).bool(message.java_conversions);
              if (message.test_only_no_java_conversions != null && message.hasOwnProperty("test_only_no_java_conversions"))
                  writer.uint32(/* id 1001, wireType 0 =*/8008).bool(message.test_only_no_java_conversions);
              return writer;
          };

          /**
           * Encodes the specified ScalaPbOptions message, length delimited. Does not implicitly {@link scalapb.ScalaPbOptions.verify|verify} messages.
           * @function encodeDelimited
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {scalapb.IScalaPbOptions} message ScalaPbOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ScalaPbOptions.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ScalaPbOptions message from the specified reader or buffer.
           * @function decode
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {scalapb.ScalaPbOptions} ScalaPbOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ScalaPbOptions.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.ScalaPbOptions();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.package_name = reader.string();
                      break;
                  case 2:
                      message.flat_package = reader.bool();
                      break;
                  case 3:
                      if (!(message["import"] && message["import"].length))
                          message["import"] = [];
                      message["import"].push(reader.string());
                      break;
                  case 4:
                      if (!(message.preamble && message.preamble.length))
                          message.preamble = [];
                      message.preamble.push(reader.string());
                      break;
                  case 5:
                      message.single_file = reader.bool();
                      break;
                  case 7:
                      message.no_primitive_wrappers = reader.bool();
                      break;
                  case 6:
                      message.primitive_wrappers = reader.bool();
                      break;
                  case 8:
                      message.collection_type = reader.string();
                      break;
                  case 9:
                      message.preserve_unknown_fields = reader.bool();
                      break;
                  case 10:
                      message.object_name = reader.string();
                      break;
                  case 11:
                      message.scope = reader.int32();
                      break;
                  case 12:
                      message.lenses = reader.bool();
                      break;
                  case 13:
                      message.retain_source_code_info = reader.bool();
                      break;
                  case 14:
                      message.map_type = reader.string();
                      break;
                  case 15:
                      message.no_default_values_in_constructor = reader.bool();
                      break;
                  case 16:
                      message.enum_value_naming = reader.int32();
                      break;
                  case 17:
                      message.enum_strip_prefix = reader.bool();
                      break;
                  case 21:
                      message.bytes_type = reader.string();
                      break;
                  case 23:
                      message.java_conversions = reader.bool();
                      break;
                  case 18:
                      if (!(message.aux_message_options && message.aux_message_options.length))
                          message.aux_message_options = [];
                      message.aux_message_options.push($root.scalapb.ScalaPbOptions.AuxMessageOptions.decode(reader, reader.uint32()));
                      break;
                  case 19:
                      if (!(message.aux_field_options && message.aux_field_options.length))
                          message.aux_field_options = [];
                      message.aux_field_options.push($root.scalapb.ScalaPbOptions.AuxFieldOptions.decode(reader, reader.uint32()));
                      break;
                  case 20:
                      if (!(message.aux_enum_options && message.aux_enum_options.length))
                          message.aux_enum_options = [];
                      message.aux_enum_options.push($root.scalapb.ScalaPbOptions.AuxEnumOptions.decode(reader, reader.uint32()));
                      break;
                  case 22:
                      if (!(message.aux_enum_value_options && message.aux_enum_value_options.length))
                          message.aux_enum_value_options = [];
                      message.aux_enum_value_options.push($root.scalapb.ScalaPbOptions.AuxEnumValueOptions.decode(reader, reader.uint32()));
                      break;
                  case 1001:
                      message.test_only_no_java_conversions = reader.bool();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ScalaPbOptions message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {scalapb.ScalaPbOptions} ScalaPbOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ScalaPbOptions.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ScalaPbOptions message.
           * @function verify
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ScalaPbOptions.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.package_name != null && message.hasOwnProperty("package_name"))
                  if (!$util.isString(message.package_name))
                      return "package_name: string expected";
              if (message.flat_package != null && message.hasOwnProperty("flat_package"))
                  if (typeof message.flat_package !== "boolean")
                      return "flat_package: boolean expected";
              if (message["import"] != null && message.hasOwnProperty("import")) {
                  if (!Array.isArray(message["import"]))
                      return "import: array expected";
                  for (var i = 0; i < message["import"].length; ++i)
                      if (!$util.isString(message["import"][i]))
                          return "import: string[] expected";
              }
              if (message.preamble != null && message.hasOwnProperty("preamble")) {
                  if (!Array.isArray(message.preamble))
                      return "preamble: array expected";
                  for (var i = 0; i < message.preamble.length; ++i)
                      if (!$util.isString(message.preamble[i]))
                          return "preamble: string[] expected";
              }
              if (message.single_file != null && message.hasOwnProperty("single_file"))
                  if (typeof message.single_file !== "boolean")
                      return "single_file: boolean expected";
              if (message.no_primitive_wrappers != null && message.hasOwnProperty("no_primitive_wrappers"))
                  if (typeof message.no_primitive_wrappers !== "boolean")
                      return "no_primitive_wrappers: boolean expected";
              if (message.primitive_wrappers != null && message.hasOwnProperty("primitive_wrappers"))
                  if (typeof message.primitive_wrappers !== "boolean")
                      return "primitive_wrappers: boolean expected";
              if (message.collection_type != null && message.hasOwnProperty("collection_type"))
                  if (!$util.isString(message.collection_type))
                      return "collection_type: string expected";
              if (message.preserve_unknown_fields != null && message.hasOwnProperty("preserve_unknown_fields"))
                  if (typeof message.preserve_unknown_fields !== "boolean")
                      return "preserve_unknown_fields: boolean expected";
              if (message.object_name != null && message.hasOwnProperty("object_name"))
                  if (!$util.isString(message.object_name))
                      return "object_name: string expected";
              if (message.scope != null && message.hasOwnProperty("scope"))
                  switch (message.scope) {
                  default:
                      return "scope: enum value expected";
                  case 0:
                  case 1:
                      break;
                  }
              if (message.lenses != null && message.hasOwnProperty("lenses"))
                  if (typeof message.lenses !== "boolean")
                      return "lenses: boolean expected";
              if (message.retain_source_code_info != null && message.hasOwnProperty("retain_source_code_info"))
                  if (typeof message.retain_source_code_info !== "boolean")
                      return "retain_source_code_info: boolean expected";
              if (message.map_type != null && message.hasOwnProperty("map_type"))
                  if (!$util.isString(message.map_type))
                      return "map_type: string expected";
              if (message.no_default_values_in_constructor != null && message.hasOwnProperty("no_default_values_in_constructor"))
                  if (typeof message.no_default_values_in_constructor !== "boolean")
                      return "no_default_values_in_constructor: boolean expected";
              if (message.enum_value_naming != null && message.hasOwnProperty("enum_value_naming"))
                  switch (message.enum_value_naming) {
                  default:
                      return "enum_value_naming: enum value expected";
                  case 0:
                  case 1:
                      break;
                  }
              if (message.enum_strip_prefix != null && message.hasOwnProperty("enum_strip_prefix"))
                  if (typeof message.enum_strip_prefix !== "boolean")
                      return "enum_strip_prefix: boolean expected";
              if (message.bytes_type != null && message.hasOwnProperty("bytes_type"))
                  if (!$util.isString(message.bytes_type))
                      return "bytes_type: string expected";
              if (message.java_conversions != null && message.hasOwnProperty("java_conversions"))
                  if (typeof message.java_conversions !== "boolean")
                      return "java_conversions: boolean expected";
              if (message.aux_message_options != null && message.hasOwnProperty("aux_message_options")) {
                  if (!Array.isArray(message.aux_message_options))
                      return "aux_message_options: array expected";
                  for (var i = 0; i < message.aux_message_options.length; ++i) {
                      var error = $root.scalapb.ScalaPbOptions.AuxMessageOptions.verify(message.aux_message_options[i]);
                      if (error)
                          return "aux_message_options." + error;
                  }
              }
              if (message.aux_field_options != null && message.hasOwnProperty("aux_field_options")) {
                  if (!Array.isArray(message.aux_field_options))
                      return "aux_field_options: array expected";
                  for (var i = 0; i < message.aux_field_options.length; ++i) {
                      var error = $root.scalapb.ScalaPbOptions.AuxFieldOptions.verify(message.aux_field_options[i]);
                      if (error)
                          return "aux_field_options." + error;
                  }
              }
              if (message.aux_enum_options != null && message.hasOwnProperty("aux_enum_options")) {
                  if (!Array.isArray(message.aux_enum_options))
                      return "aux_enum_options: array expected";
                  for (var i = 0; i < message.aux_enum_options.length; ++i) {
                      var error = $root.scalapb.ScalaPbOptions.AuxEnumOptions.verify(message.aux_enum_options[i]);
                      if (error)
                          return "aux_enum_options." + error;
                  }
              }
              if (message.aux_enum_value_options != null && message.hasOwnProperty("aux_enum_value_options")) {
                  if (!Array.isArray(message.aux_enum_value_options))
                      return "aux_enum_value_options: array expected";
                  for (var i = 0; i < message.aux_enum_value_options.length; ++i) {
                      var error = $root.scalapb.ScalaPbOptions.AuxEnumValueOptions.verify(message.aux_enum_value_options[i]);
                      if (error)
                          return "aux_enum_value_options." + error;
                  }
              }
              if (message.test_only_no_java_conversions != null && message.hasOwnProperty("test_only_no_java_conversions"))
                  if (typeof message.test_only_no_java_conversions !== "boolean")
                      return "test_only_no_java_conversions: boolean expected";
              return null;
          };

          /**
           * Creates a ScalaPbOptions message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {scalapb.ScalaPbOptions} ScalaPbOptions
           */
          ScalaPbOptions.fromObject = function fromObject(object) {
              if (object instanceof $root.scalapb.ScalaPbOptions)
                  return object;
              var message = new $root.scalapb.ScalaPbOptions();
              if (object.package_name != null)
                  message.package_name = String(object.package_name);
              if (object.flat_package != null)
                  message.flat_package = Boolean(object.flat_package);
              if (object["import"]) {
                  if (!Array.isArray(object["import"]))
                      throw TypeError(".scalapb.ScalaPbOptions.import: array expected");
                  message["import"] = [];
                  for (var i = 0; i < object["import"].length; ++i)
                      message["import"][i] = String(object["import"][i]);
              }
              if (object.preamble) {
                  if (!Array.isArray(object.preamble))
                      throw TypeError(".scalapb.ScalaPbOptions.preamble: array expected");
                  message.preamble = [];
                  for (var i = 0; i < object.preamble.length; ++i)
                      message.preamble[i] = String(object.preamble[i]);
              }
              if (object.single_file != null)
                  message.single_file = Boolean(object.single_file);
              if (object.no_primitive_wrappers != null)
                  message.no_primitive_wrappers = Boolean(object.no_primitive_wrappers);
              if (object.primitive_wrappers != null)
                  message.primitive_wrappers = Boolean(object.primitive_wrappers);
              if (object.collection_type != null)
                  message.collection_type = String(object.collection_type);
              if (object.preserve_unknown_fields != null)
                  message.preserve_unknown_fields = Boolean(object.preserve_unknown_fields);
              if (object.object_name != null)
                  message.object_name = String(object.object_name);
              switch (object.scope) {
              case "FILE":
              case 0:
                  message.scope = 0;
                  break;
              case "PACKAGE":
              case 1:
                  message.scope = 1;
                  break;
              }
              if (object.lenses != null)
                  message.lenses = Boolean(object.lenses);
              if (object.retain_source_code_info != null)
                  message.retain_source_code_info = Boolean(object.retain_source_code_info);
              if (object.map_type != null)
                  message.map_type = String(object.map_type);
              if (object.no_default_values_in_constructor != null)
                  message.no_default_values_in_constructor = Boolean(object.no_default_values_in_constructor);
              switch (object.enum_value_naming) {
              case "AS_IN_PROTO":
              case 0:
                  message.enum_value_naming = 0;
                  break;
              case "CAMEL_CASE":
              case 1:
                  message.enum_value_naming = 1;
                  break;
              }
              if (object.enum_strip_prefix != null)
                  message.enum_strip_prefix = Boolean(object.enum_strip_prefix);
              if (object.bytes_type != null)
                  message.bytes_type = String(object.bytes_type);
              if (object.java_conversions != null)
                  message.java_conversions = Boolean(object.java_conversions);
              if (object.aux_message_options) {
                  if (!Array.isArray(object.aux_message_options))
                      throw TypeError(".scalapb.ScalaPbOptions.aux_message_options: array expected");
                  message.aux_message_options = [];
                  for (var i = 0; i < object.aux_message_options.length; ++i) {
                      if (typeof object.aux_message_options[i] !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.aux_message_options: object expected");
                      message.aux_message_options[i] = $root.scalapb.ScalaPbOptions.AuxMessageOptions.fromObject(object.aux_message_options[i]);
                  }
              }
              if (object.aux_field_options) {
                  if (!Array.isArray(object.aux_field_options))
                      throw TypeError(".scalapb.ScalaPbOptions.aux_field_options: array expected");
                  message.aux_field_options = [];
                  for (var i = 0; i < object.aux_field_options.length; ++i) {
                      if (typeof object.aux_field_options[i] !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.aux_field_options: object expected");
                      message.aux_field_options[i] = $root.scalapb.ScalaPbOptions.AuxFieldOptions.fromObject(object.aux_field_options[i]);
                  }
              }
              if (object.aux_enum_options) {
                  if (!Array.isArray(object.aux_enum_options))
                      throw TypeError(".scalapb.ScalaPbOptions.aux_enum_options: array expected");
                  message.aux_enum_options = [];
                  for (var i = 0; i < object.aux_enum_options.length; ++i) {
                      if (typeof object.aux_enum_options[i] !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.aux_enum_options: object expected");
                      message.aux_enum_options[i] = $root.scalapb.ScalaPbOptions.AuxEnumOptions.fromObject(object.aux_enum_options[i]);
                  }
              }
              if (object.aux_enum_value_options) {
                  if (!Array.isArray(object.aux_enum_value_options))
                      throw TypeError(".scalapb.ScalaPbOptions.aux_enum_value_options: array expected");
                  message.aux_enum_value_options = [];
                  for (var i = 0; i < object.aux_enum_value_options.length; ++i) {
                      if (typeof object.aux_enum_value_options[i] !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.aux_enum_value_options: object expected");
                      message.aux_enum_value_options[i] = $root.scalapb.ScalaPbOptions.AuxEnumValueOptions.fromObject(object.aux_enum_value_options[i]);
                  }
              }
              if (object.test_only_no_java_conversions != null)
                  message.test_only_no_java_conversions = Boolean(object.test_only_no_java_conversions);
              return message;
          };

          /**
           * Creates a plain object from a ScalaPbOptions message. Also converts values to other types if specified.
           * @function toObject
           * @memberof scalapb.ScalaPbOptions
           * @static
           * @param {scalapb.ScalaPbOptions} message ScalaPbOptions
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ScalaPbOptions.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object["import"] = [];
                  object.preamble = [];
                  object.aux_message_options = [];
                  object.aux_field_options = [];
                  object.aux_enum_options = [];
                  object.aux_enum_value_options = [];
              }
              if (options.defaults) {
                  object.package_name = "";
                  object.flat_package = false;
                  object.single_file = false;
                  object.primitive_wrappers = false;
                  object.no_primitive_wrappers = false;
                  object.collection_type = "";
                  object.preserve_unknown_fields = true;
                  object.object_name = "";
                  object.scope = options.enums === String ? "FILE" : 0;
                  object.lenses = true;
                  object.retain_source_code_info = false;
                  object.map_type = "";
                  object.no_default_values_in_constructor = false;
                  object.enum_value_naming = options.enums === String ? "AS_IN_PROTO" : 0;
                  object.enum_strip_prefix = false;
                  object.bytes_type = "";
                  object.java_conversions = false;
                  object.test_only_no_java_conversions = false;
              }
              if (message.package_name != null && message.hasOwnProperty("package_name"))
                  object.package_name = message.package_name;
              if (message.flat_package != null && message.hasOwnProperty("flat_package"))
                  object.flat_package = message.flat_package;
              if (message["import"] && message["import"].length) {
                  object["import"] = [];
                  for (var j = 0; j < message["import"].length; ++j)
                      object["import"][j] = message["import"][j];
              }
              if (message.preamble && message.preamble.length) {
                  object.preamble = [];
                  for (var j = 0; j < message.preamble.length; ++j)
                      object.preamble[j] = message.preamble[j];
              }
              if (message.single_file != null && message.hasOwnProperty("single_file"))
                  object.single_file = message.single_file;
              if (message.primitive_wrappers != null && message.hasOwnProperty("primitive_wrappers"))
                  object.primitive_wrappers = message.primitive_wrappers;
              if (message.no_primitive_wrappers != null && message.hasOwnProperty("no_primitive_wrappers"))
                  object.no_primitive_wrappers = message.no_primitive_wrappers;
              if (message.collection_type != null && message.hasOwnProperty("collection_type"))
                  object.collection_type = message.collection_type;
              if (message.preserve_unknown_fields != null && message.hasOwnProperty("preserve_unknown_fields"))
                  object.preserve_unknown_fields = message.preserve_unknown_fields;
              if (message.object_name != null && message.hasOwnProperty("object_name"))
                  object.object_name = message.object_name;
              if (message.scope != null && message.hasOwnProperty("scope"))
                  object.scope = options.enums === String ? $root.scalapb.ScalaPbOptions.OptionsScope[message.scope] : message.scope;
              if (message.lenses != null && message.hasOwnProperty("lenses"))
                  object.lenses = message.lenses;
              if (message.retain_source_code_info != null && message.hasOwnProperty("retain_source_code_info"))
                  object.retain_source_code_info = message.retain_source_code_info;
              if (message.map_type != null && message.hasOwnProperty("map_type"))
                  object.map_type = message.map_type;
              if (message.no_default_values_in_constructor != null && message.hasOwnProperty("no_default_values_in_constructor"))
                  object.no_default_values_in_constructor = message.no_default_values_in_constructor;
              if (message.enum_value_naming != null && message.hasOwnProperty("enum_value_naming"))
                  object.enum_value_naming = options.enums === String ? $root.scalapb.ScalaPbOptions.EnumValueNaming[message.enum_value_naming] : message.enum_value_naming;
              if (message.enum_strip_prefix != null && message.hasOwnProperty("enum_strip_prefix"))
                  object.enum_strip_prefix = message.enum_strip_prefix;
              if (message.aux_message_options && message.aux_message_options.length) {
                  object.aux_message_options = [];
                  for (var j = 0; j < message.aux_message_options.length; ++j)
                      object.aux_message_options[j] = $root.scalapb.ScalaPbOptions.AuxMessageOptions.toObject(message.aux_message_options[j], options);
              }
              if (message.aux_field_options && message.aux_field_options.length) {
                  object.aux_field_options = [];
                  for (var j = 0; j < message.aux_field_options.length; ++j)
                      object.aux_field_options[j] = $root.scalapb.ScalaPbOptions.AuxFieldOptions.toObject(message.aux_field_options[j], options);
              }
              if (message.aux_enum_options && message.aux_enum_options.length) {
                  object.aux_enum_options = [];
                  for (var j = 0; j < message.aux_enum_options.length; ++j)
                      object.aux_enum_options[j] = $root.scalapb.ScalaPbOptions.AuxEnumOptions.toObject(message.aux_enum_options[j], options);
              }
              if (message.bytes_type != null && message.hasOwnProperty("bytes_type"))
                  object.bytes_type = message.bytes_type;
              if (message.aux_enum_value_options && message.aux_enum_value_options.length) {
                  object.aux_enum_value_options = [];
                  for (var j = 0; j < message.aux_enum_value_options.length; ++j)
                      object.aux_enum_value_options[j] = $root.scalapb.ScalaPbOptions.AuxEnumValueOptions.toObject(message.aux_enum_value_options[j], options);
              }
              if (message.java_conversions != null && message.hasOwnProperty("java_conversions"))
                  object.java_conversions = message.java_conversions;
              if (message.test_only_no_java_conversions != null && message.hasOwnProperty("test_only_no_java_conversions"))
                  object.test_only_no_java_conversions = message.test_only_no_java_conversions;
              return object;
          };

          /**
           * Converts this ScalaPbOptions to JSON.
           * @function toJSON
           * @memberof scalapb.ScalaPbOptions
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ScalaPbOptions.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          /**
           * OptionsScope enum.
           * @name scalapb.ScalaPbOptions.OptionsScope
           * @enum {string}
           * @property {number} FILE=0 FILE value
           * @property {number} PACKAGE=1 PACKAGE value
           */
          ScalaPbOptions.OptionsScope = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "FILE"] = 0;
              values[valuesById[1] = "PACKAGE"] = 1;
              return values;
          })();

          /**
           * EnumValueNaming enum.
           * @name scalapb.ScalaPbOptions.EnumValueNaming
           * @enum {string}
           * @property {number} AS_IN_PROTO=0 AS_IN_PROTO value
           * @property {number} CAMEL_CASE=1 CAMEL_CASE value
           */
          ScalaPbOptions.EnumValueNaming = (function() {
              var valuesById = {}, values = Object.create(valuesById);
              values[valuesById[0] = "AS_IN_PROTO"] = 0;
              values[valuesById[1] = "CAMEL_CASE"] = 1;
              return values;
          })();

          ScalaPbOptions.AuxMessageOptions = (function() {

              /**
               * Properties of an AuxMessageOptions.
               * @memberof scalapb.ScalaPbOptions
               * @interface IAuxMessageOptions
               * @property {string|null} [target] AuxMessageOptions target
               * @property {scalapb.IMessageOptions|null} [options] AuxMessageOptions options
               */

              /**
               * Constructs a new AuxMessageOptions.
               * @memberof scalapb.ScalaPbOptions
               * @classdesc Represents an AuxMessageOptions.
               * @implements IAuxMessageOptions
               * @constructor
               * @param {scalapb.ScalaPbOptions.IAuxMessageOptions=} [properties] Properties to set
               */
              function AuxMessageOptions(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * AuxMessageOptions target.
               * @member {string} target
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @instance
               */
              AuxMessageOptions.prototype.target = "";

              /**
               * AuxMessageOptions options.
               * @member {scalapb.IMessageOptions|null|undefined} options
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @instance
               */
              AuxMessageOptions.prototype.options = null;

              /**
               * Creates a new AuxMessageOptions instance using the specified properties.
               * @function create
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxMessageOptions=} [properties] Properties to set
               * @returns {scalapb.ScalaPbOptions.AuxMessageOptions} AuxMessageOptions instance
               */
              AuxMessageOptions.create = function create(properties) {
                  return new AuxMessageOptions(properties);
              };

              /**
               * Encodes the specified AuxMessageOptions message. Does not implicitly {@link scalapb.ScalaPbOptions.AuxMessageOptions.verify|verify} messages.
               * @function encode
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxMessageOptions} message AuxMessageOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxMessageOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.target != null && message.hasOwnProperty("target"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.target);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.scalapb.MessageOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified AuxMessageOptions message, length delimited. Does not implicitly {@link scalapb.ScalaPbOptions.AuxMessageOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxMessageOptions} message AuxMessageOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxMessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an AuxMessageOptions message from the specified reader or buffer.
               * @function decode
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {scalapb.ScalaPbOptions.AuxMessageOptions} AuxMessageOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxMessageOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.ScalaPbOptions.AuxMessageOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.target = reader.string();
                          break;
                      case 2:
                          message.options = $root.scalapb.MessageOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an AuxMessageOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {scalapb.ScalaPbOptions.AuxMessageOptions} AuxMessageOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxMessageOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an AuxMessageOptions message.
               * @function verify
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              AuxMessageOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.target != null && message.hasOwnProperty("target"))
                      if (!$util.isString(message.target))
                          return "target: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.scalapb.MessageOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an AuxMessageOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {scalapb.ScalaPbOptions.AuxMessageOptions} AuxMessageOptions
               */
              AuxMessageOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.scalapb.ScalaPbOptions.AuxMessageOptions)
                      return object;
                  var message = new $root.scalapb.ScalaPbOptions.AuxMessageOptions();
                  if (object.target != null)
                      message.target = String(object.target);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.AuxMessageOptions.options: object expected");
                      message.options = $root.scalapb.MessageOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an AuxMessageOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @static
               * @param {scalapb.ScalaPbOptions.AuxMessageOptions} message AuxMessageOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              AuxMessageOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.target = "";
                      object.options = null;
                  }
                  if (message.target != null && message.hasOwnProperty("target"))
                      object.target = message.target;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.scalapb.MessageOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this AuxMessageOptions to JSON.
               * @function toJSON
               * @memberof scalapb.ScalaPbOptions.AuxMessageOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              AuxMessageOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return AuxMessageOptions;
          })();

          ScalaPbOptions.AuxFieldOptions = (function() {

              /**
               * Properties of an AuxFieldOptions.
               * @memberof scalapb.ScalaPbOptions
               * @interface IAuxFieldOptions
               * @property {string|null} [target] AuxFieldOptions target
               * @property {scalapb.IFieldOptions|null} [options] AuxFieldOptions options
               */

              /**
               * Constructs a new AuxFieldOptions.
               * @memberof scalapb.ScalaPbOptions
               * @classdesc Represents an AuxFieldOptions.
               * @implements IAuxFieldOptions
               * @constructor
               * @param {scalapb.ScalaPbOptions.IAuxFieldOptions=} [properties] Properties to set
               */
              function AuxFieldOptions(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * AuxFieldOptions target.
               * @member {string} target
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @instance
               */
              AuxFieldOptions.prototype.target = "";

              /**
               * AuxFieldOptions options.
               * @member {scalapb.IFieldOptions|null|undefined} options
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @instance
               */
              AuxFieldOptions.prototype.options = null;

              /**
               * Creates a new AuxFieldOptions instance using the specified properties.
               * @function create
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxFieldOptions=} [properties] Properties to set
               * @returns {scalapb.ScalaPbOptions.AuxFieldOptions} AuxFieldOptions instance
               */
              AuxFieldOptions.create = function create(properties) {
                  return new AuxFieldOptions(properties);
              };

              /**
               * Encodes the specified AuxFieldOptions message. Does not implicitly {@link scalapb.ScalaPbOptions.AuxFieldOptions.verify|verify} messages.
               * @function encode
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxFieldOptions} message AuxFieldOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxFieldOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.target != null && message.hasOwnProperty("target"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.target);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.scalapb.FieldOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified AuxFieldOptions message, length delimited. Does not implicitly {@link scalapb.ScalaPbOptions.AuxFieldOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxFieldOptions} message AuxFieldOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxFieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an AuxFieldOptions message from the specified reader or buffer.
               * @function decode
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {scalapb.ScalaPbOptions.AuxFieldOptions} AuxFieldOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxFieldOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.ScalaPbOptions.AuxFieldOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.target = reader.string();
                          break;
                      case 2:
                          message.options = $root.scalapb.FieldOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an AuxFieldOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {scalapb.ScalaPbOptions.AuxFieldOptions} AuxFieldOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxFieldOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an AuxFieldOptions message.
               * @function verify
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              AuxFieldOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.target != null && message.hasOwnProperty("target"))
                      if (!$util.isString(message.target))
                          return "target: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.scalapb.FieldOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an AuxFieldOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {scalapb.ScalaPbOptions.AuxFieldOptions} AuxFieldOptions
               */
              AuxFieldOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.scalapb.ScalaPbOptions.AuxFieldOptions)
                      return object;
                  var message = new $root.scalapb.ScalaPbOptions.AuxFieldOptions();
                  if (object.target != null)
                      message.target = String(object.target);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.AuxFieldOptions.options: object expected");
                      message.options = $root.scalapb.FieldOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an AuxFieldOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @static
               * @param {scalapb.ScalaPbOptions.AuxFieldOptions} message AuxFieldOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              AuxFieldOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.target = "";
                      object.options = null;
                  }
                  if (message.target != null && message.hasOwnProperty("target"))
                      object.target = message.target;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.scalapb.FieldOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this AuxFieldOptions to JSON.
               * @function toJSON
               * @memberof scalapb.ScalaPbOptions.AuxFieldOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              AuxFieldOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return AuxFieldOptions;
          })();

          ScalaPbOptions.AuxEnumOptions = (function() {

              /**
               * Properties of an AuxEnumOptions.
               * @memberof scalapb.ScalaPbOptions
               * @interface IAuxEnumOptions
               * @property {string|null} [target] AuxEnumOptions target
               * @property {scalapb.IEnumOptions|null} [options] AuxEnumOptions options
               */

              /**
               * Constructs a new AuxEnumOptions.
               * @memberof scalapb.ScalaPbOptions
               * @classdesc Represents an AuxEnumOptions.
               * @implements IAuxEnumOptions
               * @constructor
               * @param {scalapb.ScalaPbOptions.IAuxEnumOptions=} [properties] Properties to set
               */
              function AuxEnumOptions(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * AuxEnumOptions target.
               * @member {string} target
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @instance
               */
              AuxEnumOptions.prototype.target = "";

              /**
               * AuxEnumOptions options.
               * @member {scalapb.IEnumOptions|null|undefined} options
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @instance
               */
              AuxEnumOptions.prototype.options = null;

              /**
               * Creates a new AuxEnumOptions instance using the specified properties.
               * @function create
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxEnumOptions=} [properties] Properties to set
               * @returns {scalapb.ScalaPbOptions.AuxEnumOptions} AuxEnumOptions instance
               */
              AuxEnumOptions.create = function create(properties) {
                  return new AuxEnumOptions(properties);
              };

              /**
               * Encodes the specified AuxEnumOptions message. Does not implicitly {@link scalapb.ScalaPbOptions.AuxEnumOptions.verify|verify} messages.
               * @function encode
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxEnumOptions} message AuxEnumOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxEnumOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.target != null && message.hasOwnProperty("target"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.target);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.scalapb.EnumOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified AuxEnumOptions message, length delimited. Does not implicitly {@link scalapb.ScalaPbOptions.AuxEnumOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxEnumOptions} message AuxEnumOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxEnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an AuxEnumOptions message from the specified reader or buffer.
               * @function decode
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {scalapb.ScalaPbOptions.AuxEnumOptions} AuxEnumOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxEnumOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.ScalaPbOptions.AuxEnumOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.target = reader.string();
                          break;
                      case 2:
                          message.options = $root.scalapb.EnumOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an AuxEnumOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {scalapb.ScalaPbOptions.AuxEnumOptions} AuxEnumOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxEnumOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an AuxEnumOptions message.
               * @function verify
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              AuxEnumOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.target != null && message.hasOwnProperty("target"))
                      if (!$util.isString(message.target))
                          return "target: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.scalapb.EnumOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an AuxEnumOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {scalapb.ScalaPbOptions.AuxEnumOptions} AuxEnumOptions
               */
              AuxEnumOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.scalapb.ScalaPbOptions.AuxEnumOptions)
                      return object;
                  var message = new $root.scalapb.ScalaPbOptions.AuxEnumOptions();
                  if (object.target != null)
                      message.target = String(object.target);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.AuxEnumOptions.options: object expected");
                      message.options = $root.scalapb.EnumOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an AuxEnumOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @static
               * @param {scalapb.ScalaPbOptions.AuxEnumOptions} message AuxEnumOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              AuxEnumOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.target = "";
                      object.options = null;
                  }
                  if (message.target != null && message.hasOwnProperty("target"))
                      object.target = message.target;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.scalapb.EnumOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this AuxEnumOptions to JSON.
               * @function toJSON
               * @memberof scalapb.ScalaPbOptions.AuxEnumOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              AuxEnumOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return AuxEnumOptions;
          })();

          ScalaPbOptions.AuxEnumValueOptions = (function() {

              /**
               * Properties of an AuxEnumValueOptions.
               * @memberof scalapb.ScalaPbOptions
               * @interface IAuxEnumValueOptions
               * @property {string|null} [target] AuxEnumValueOptions target
               * @property {scalapb.IEnumValueOptions|null} [options] AuxEnumValueOptions options
               */

              /**
               * Constructs a new AuxEnumValueOptions.
               * @memberof scalapb.ScalaPbOptions
               * @classdesc Represents an AuxEnumValueOptions.
               * @implements IAuxEnumValueOptions
               * @constructor
               * @param {scalapb.ScalaPbOptions.IAuxEnumValueOptions=} [properties] Properties to set
               */
              function AuxEnumValueOptions(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * AuxEnumValueOptions target.
               * @member {string} target
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @instance
               */
              AuxEnumValueOptions.prototype.target = "";

              /**
               * AuxEnumValueOptions options.
               * @member {scalapb.IEnumValueOptions|null|undefined} options
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @instance
               */
              AuxEnumValueOptions.prototype.options = null;

              /**
               * Creates a new AuxEnumValueOptions instance using the specified properties.
               * @function create
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxEnumValueOptions=} [properties] Properties to set
               * @returns {scalapb.ScalaPbOptions.AuxEnumValueOptions} AuxEnumValueOptions instance
               */
              AuxEnumValueOptions.create = function create(properties) {
                  return new AuxEnumValueOptions(properties);
              };

              /**
               * Encodes the specified AuxEnumValueOptions message. Does not implicitly {@link scalapb.ScalaPbOptions.AuxEnumValueOptions.verify|verify} messages.
               * @function encode
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxEnumValueOptions} message AuxEnumValueOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxEnumValueOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.target != null && message.hasOwnProperty("target"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.target);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.scalapb.EnumValueOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified AuxEnumValueOptions message, length delimited. Does not implicitly {@link scalapb.ScalaPbOptions.AuxEnumValueOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {scalapb.ScalaPbOptions.IAuxEnumValueOptions} message AuxEnumValueOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              AuxEnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an AuxEnumValueOptions message from the specified reader or buffer.
               * @function decode
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {scalapb.ScalaPbOptions.AuxEnumValueOptions} AuxEnumValueOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxEnumValueOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.ScalaPbOptions.AuxEnumValueOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.target = reader.string();
                          break;
                      case 2:
                          message.options = $root.scalapb.EnumValueOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an AuxEnumValueOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {scalapb.ScalaPbOptions.AuxEnumValueOptions} AuxEnumValueOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              AuxEnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an AuxEnumValueOptions message.
               * @function verify
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              AuxEnumValueOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.target != null && message.hasOwnProperty("target"))
                      if (!$util.isString(message.target))
                          return "target: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.scalapb.EnumValueOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an AuxEnumValueOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {scalapb.ScalaPbOptions.AuxEnumValueOptions} AuxEnumValueOptions
               */
              AuxEnumValueOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.scalapb.ScalaPbOptions.AuxEnumValueOptions)
                      return object;
                  var message = new $root.scalapb.ScalaPbOptions.AuxEnumValueOptions();
                  if (object.target != null)
                      message.target = String(object.target);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".scalapb.ScalaPbOptions.AuxEnumValueOptions.options: object expected");
                      message.options = $root.scalapb.EnumValueOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an AuxEnumValueOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @static
               * @param {scalapb.ScalaPbOptions.AuxEnumValueOptions} message AuxEnumValueOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              AuxEnumValueOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.target = "";
                      object.options = null;
                  }
                  if (message.target != null && message.hasOwnProperty("target"))
                      object.target = message.target;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.scalapb.EnumValueOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this AuxEnumValueOptions to JSON.
               * @function toJSON
               * @memberof scalapb.ScalaPbOptions.AuxEnumValueOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              AuxEnumValueOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return AuxEnumValueOptions;
          })();

          return ScalaPbOptions;
      })();

      scalapb.MessageOptions = (function() {

          /**
           * Properties of a MessageOptions.
           * @memberof scalapb
           * @interface IMessageOptions
           * @property {Array.<string>|null} ["extends"] MessageOptions extends
           * @property {Array.<string>|null} [companion_extends] MessageOptions companion_extends
           * @property {Array.<string>|null} [annotations] MessageOptions annotations
           * @property {string|null} [type] MessageOptions type
           * @property {Array.<string>|null} [companion_annotations] MessageOptions companion_annotations
           * @property {Array.<string>|null} [sealed_oneof_extends] MessageOptions sealed_oneof_extends
           * @property {boolean|null} [no_box] MessageOptions no_box
           * @property {Array.<string>|null} [unknown_fields_annotations] MessageOptions unknown_fields_annotations
           */

          /**
           * Constructs a new MessageOptions.
           * @memberof scalapb
           * @classdesc Represents a MessageOptions.
           * @implements IMessageOptions
           * @constructor
           * @param {scalapb.IMessageOptions=} [properties] Properties to set
           */
          function MessageOptions(properties) {
              this["extends"] = [];
              this.companion_extends = [];
              this.annotations = [];
              this.companion_annotations = [];
              this.sealed_oneof_extends = [];
              this.unknown_fields_annotations = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * MessageOptions extends.
           * @member {Array.<string>} extends
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype["extends"] = $util.emptyArray;

          /**
           * MessageOptions companion_extends.
           * @member {Array.<string>} companion_extends
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.companion_extends = $util.emptyArray;

          /**
           * MessageOptions annotations.
           * @member {Array.<string>} annotations
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.annotations = $util.emptyArray;

          /**
           * MessageOptions type.
           * @member {string} type
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.type = "";

          /**
           * MessageOptions companion_annotations.
           * @member {Array.<string>} companion_annotations
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.companion_annotations = $util.emptyArray;

          /**
           * MessageOptions sealed_oneof_extends.
           * @member {Array.<string>} sealed_oneof_extends
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.sealed_oneof_extends = $util.emptyArray;

          /**
           * MessageOptions no_box.
           * @member {boolean} no_box
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.no_box = false;

          /**
           * MessageOptions unknown_fields_annotations.
           * @member {Array.<string>} unknown_fields_annotations
           * @memberof scalapb.MessageOptions
           * @instance
           */
          MessageOptions.prototype.unknown_fields_annotations = $util.emptyArray;

          /**
           * Creates a new MessageOptions instance using the specified properties.
           * @function create
           * @memberof scalapb.MessageOptions
           * @static
           * @param {scalapb.IMessageOptions=} [properties] Properties to set
           * @returns {scalapb.MessageOptions} MessageOptions instance
           */
          MessageOptions.create = function create(properties) {
              return new MessageOptions(properties);
          };

          /**
           * Encodes the specified MessageOptions message. Does not implicitly {@link scalapb.MessageOptions.verify|verify} messages.
           * @function encode
           * @memberof scalapb.MessageOptions
           * @static
           * @param {scalapb.IMessageOptions} message MessageOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MessageOptions.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message["extends"] != null && message["extends"].length)
                  for (var i = 0; i < message["extends"].length; ++i)
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message["extends"][i]);
              if (message.companion_extends != null && message.companion_extends.length)
                  for (var i = 0; i < message.companion_extends.length; ++i)
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.companion_extends[i]);
              if (message.annotations != null && message.annotations.length)
                  for (var i = 0; i < message.annotations.length; ++i)
                      writer.uint32(/* id 3, wireType 2 =*/26).string(message.annotations[i]);
              if (message.type != null && message.hasOwnProperty("type"))
                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
              if (message.companion_annotations != null && message.companion_annotations.length)
                  for (var i = 0; i < message.companion_annotations.length; ++i)
                      writer.uint32(/* id 5, wireType 2 =*/42).string(message.companion_annotations[i]);
              if (message.sealed_oneof_extends != null && message.sealed_oneof_extends.length)
                  for (var i = 0; i < message.sealed_oneof_extends.length; ++i)
                      writer.uint32(/* id 6, wireType 2 =*/50).string(message.sealed_oneof_extends[i]);
              if (message.no_box != null && message.hasOwnProperty("no_box"))
                  writer.uint32(/* id 7, wireType 0 =*/56).bool(message.no_box);
              if (message.unknown_fields_annotations != null && message.unknown_fields_annotations.length)
                  for (var i = 0; i < message.unknown_fields_annotations.length; ++i)
                      writer.uint32(/* id 8, wireType 2 =*/66).string(message.unknown_fields_annotations[i]);
              return writer;
          };

          /**
           * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link scalapb.MessageOptions.verify|verify} messages.
           * @function encodeDelimited
           * @memberof scalapb.MessageOptions
           * @static
           * @param {scalapb.IMessageOptions} message MessageOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a MessageOptions message from the specified reader or buffer.
           * @function decode
           * @memberof scalapb.MessageOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {scalapb.MessageOptions} MessageOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MessageOptions.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.MessageOptions();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message["extends"] && message["extends"].length))
                          message["extends"] = [];
                      message["extends"].push(reader.string());
                      break;
                  case 2:
                      if (!(message.companion_extends && message.companion_extends.length))
                          message.companion_extends = [];
                      message.companion_extends.push(reader.string());
                      break;
                  case 3:
                      if (!(message.annotations && message.annotations.length))
                          message.annotations = [];
                      message.annotations.push(reader.string());
                      break;
                  case 4:
                      message.type = reader.string();
                      break;
                  case 5:
                      if (!(message.companion_annotations && message.companion_annotations.length))
                          message.companion_annotations = [];
                      message.companion_annotations.push(reader.string());
                      break;
                  case 6:
                      if (!(message.sealed_oneof_extends && message.sealed_oneof_extends.length))
                          message.sealed_oneof_extends = [];
                      message.sealed_oneof_extends.push(reader.string());
                      break;
                  case 7:
                      message.no_box = reader.bool();
                      break;
                  case 8:
                      if (!(message.unknown_fields_annotations && message.unknown_fields_annotations.length))
                          message.unknown_fields_annotations = [];
                      message.unknown_fields_annotations.push(reader.string());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof scalapb.MessageOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {scalapb.MessageOptions} MessageOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MessageOptions.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a MessageOptions message.
           * @function verify
           * @memberof scalapb.MessageOptions
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          MessageOptions.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message["extends"] != null && message.hasOwnProperty("extends")) {
                  if (!Array.isArray(message["extends"]))
                      return "extends: array expected";
                  for (var i = 0; i < message["extends"].length; ++i)
                      if (!$util.isString(message["extends"][i]))
                          return "extends: string[] expected";
              }
              if (message.companion_extends != null && message.hasOwnProperty("companion_extends")) {
                  if (!Array.isArray(message.companion_extends))
                      return "companion_extends: array expected";
                  for (var i = 0; i < message.companion_extends.length; ++i)
                      if (!$util.isString(message.companion_extends[i]))
                          return "companion_extends: string[] expected";
              }
              if (message.annotations != null && message.hasOwnProperty("annotations")) {
                  if (!Array.isArray(message.annotations))
                      return "annotations: array expected";
                  for (var i = 0; i < message.annotations.length; ++i)
                      if (!$util.isString(message.annotations[i]))
                          return "annotations: string[] expected";
              }
              if (message.type != null && message.hasOwnProperty("type"))
                  if (!$util.isString(message.type))
                      return "type: string expected";
              if (message.companion_annotations != null && message.hasOwnProperty("companion_annotations")) {
                  if (!Array.isArray(message.companion_annotations))
                      return "companion_annotations: array expected";
                  for (var i = 0; i < message.companion_annotations.length; ++i)
                      if (!$util.isString(message.companion_annotations[i]))
                          return "companion_annotations: string[] expected";
              }
              if (message.sealed_oneof_extends != null && message.hasOwnProperty("sealed_oneof_extends")) {
                  if (!Array.isArray(message.sealed_oneof_extends))
                      return "sealed_oneof_extends: array expected";
                  for (var i = 0; i < message.sealed_oneof_extends.length; ++i)
                      if (!$util.isString(message.sealed_oneof_extends[i]))
                          return "sealed_oneof_extends: string[] expected";
              }
              if (message.no_box != null && message.hasOwnProperty("no_box"))
                  if (typeof message.no_box !== "boolean")
                      return "no_box: boolean expected";
              if (message.unknown_fields_annotations != null && message.hasOwnProperty("unknown_fields_annotations")) {
                  if (!Array.isArray(message.unknown_fields_annotations))
                      return "unknown_fields_annotations: array expected";
                  for (var i = 0; i < message.unknown_fields_annotations.length; ++i)
                      if (!$util.isString(message.unknown_fields_annotations[i]))
                          return "unknown_fields_annotations: string[] expected";
              }
              return null;
          };

          /**
           * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof scalapb.MessageOptions
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {scalapb.MessageOptions} MessageOptions
           */
          MessageOptions.fromObject = function fromObject(object) {
              if (object instanceof $root.scalapb.MessageOptions)
                  return object;
              var message = new $root.scalapb.MessageOptions();
              if (object["extends"]) {
                  if (!Array.isArray(object["extends"]))
                      throw TypeError(".scalapb.MessageOptions.extends: array expected");
                  message["extends"] = [];
                  for (var i = 0; i < object["extends"].length; ++i)
                      message["extends"][i] = String(object["extends"][i]);
              }
              if (object.companion_extends) {
                  if (!Array.isArray(object.companion_extends))
                      throw TypeError(".scalapb.MessageOptions.companion_extends: array expected");
                  message.companion_extends = [];
                  for (var i = 0; i < object.companion_extends.length; ++i)
                      message.companion_extends[i] = String(object.companion_extends[i]);
              }
              if (object.annotations) {
                  if (!Array.isArray(object.annotations))
                      throw TypeError(".scalapb.MessageOptions.annotations: array expected");
                  message.annotations = [];
                  for (var i = 0; i < object.annotations.length; ++i)
                      message.annotations[i] = String(object.annotations[i]);
              }
              if (object.type != null)
                  message.type = String(object.type);
              if (object.companion_annotations) {
                  if (!Array.isArray(object.companion_annotations))
                      throw TypeError(".scalapb.MessageOptions.companion_annotations: array expected");
                  message.companion_annotations = [];
                  for (var i = 0; i < object.companion_annotations.length; ++i)
                      message.companion_annotations[i] = String(object.companion_annotations[i]);
              }
              if (object.sealed_oneof_extends) {
                  if (!Array.isArray(object.sealed_oneof_extends))
                      throw TypeError(".scalapb.MessageOptions.sealed_oneof_extends: array expected");
                  message.sealed_oneof_extends = [];
                  for (var i = 0; i < object.sealed_oneof_extends.length; ++i)
                      message.sealed_oneof_extends[i] = String(object.sealed_oneof_extends[i]);
              }
              if (object.no_box != null)
                  message.no_box = Boolean(object.no_box);
              if (object.unknown_fields_annotations) {
                  if (!Array.isArray(object.unknown_fields_annotations))
                      throw TypeError(".scalapb.MessageOptions.unknown_fields_annotations: array expected");
                  message.unknown_fields_annotations = [];
                  for (var i = 0; i < object.unknown_fields_annotations.length; ++i)
                      message.unknown_fields_annotations[i] = String(object.unknown_fields_annotations[i]);
              }
              return message;
          };

          /**
           * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
           * @function toObject
           * @memberof scalapb.MessageOptions
           * @static
           * @param {scalapb.MessageOptions} message MessageOptions
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          MessageOptions.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object["extends"] = [];
                  object.companion_extends = [];
                  object.annotations = [];
                  object.companion_annotations = [];
                  object.sealed_oneof_extends = [];
                  object.unknown_fields_annotations = [];
              }
              if (options.defaults) {
                  object.type = "";
                  object.no_box = false;
              }
              if (message["extends"] && message["extends"].length) {
                  object["extends"] = [];
                  for (var j = 0; j < message["extends"].length; ++j)
                      object["extends"][j] = message["extends"][j];
              }
              if (message.companion_extends && message.companion_extends.length) {
                  object.companion_extends = [];
                  for (var j = 0; j < message.companion_extends.length; ++j)
                      object.companion_extends[j] = message.companion_extends[j];
              }
              if (message.annotations && message.annotations.length) {
                  object.annotations = [];
                  for (var j = 0; j < message.annotations.length; ++j)
                      object.annotations[j] = message.annotations[j];
              }
              if (message.type != null && message.hasOwnProperty("type"))
                  object.type = message.type;
              if (message.companion_annotations && message.companion_annotations.length) {
                  object.companion_annotations = [];
                  for (var j = 0; j < message.companion_annotations.length; ++j)
                      object.companion_annotations[j] = message.companion_annotations[j];
              }
              if (message.sealed_oneof_extends && message.sealed_oneof_extends.length) {
                  object.sealed_oneof_extends = [];
                  for (var j = 0; j < message.sealed_oneof_extends.length; ++j)
                      object.sealed_oneof_extends[j] = message.sealed_oneof_extends[j];
              }
              if (message.no_box != null && message.hasOwnProperty("no_box"))
                  object.no_box = message.no_box;
              if (message.unknown_fields_annotations && message.unknown_fields_annotations.length) {
                  object.unknown_fields_annotations = [];
                  for (var j = 0; j < message.unknown_fields_annotations.length; ++j)
                      object.unknown_fields_annotations[j] = message.unknown_fields_annotations[j];
              }
              return object;
          };

          /**
           * Converts this MessageOptions to JSON.
           * @function toJSON
           * @memberof scalapb.MessageOptions
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          MessageOptions.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return MessageOptions;
      })();

      scalapb.FieldOptions = (function() {

          /**
           * Properties of a FieldOptions.
           * @memberof scalapb
           * @interface IFieldOptions
           * @property {string|null} [type] FieldOptions type
           * @property {string|null} [scala_name] FieldOptions scala_name
           * @property {string|null} [collection_type] FieldOptions collection_type
           * @property {string|null} [key_type] FieldOptions key_type
           * @property {string|null} [value_type] FieldOptions value_type
           * @property {Array.<string>|null} [annotations] FieldOptions annotations
           * @property {string|null} [map_type] FieldOptions map_type
           * @property {boolean|null} [no_box] FieldOptions no_box
           */

          /**
           * Constructs a new FieldOptions.
           * @memberof scalapb
           * @classdesc Represents a FieldOptions.
           * @implements IFieldOptions
           * @constructor
           * @param {scalapb.IFieldOptions=} [properties] Properties to set
           */
          function FieldOptions(properties) {
              this.annotations = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * FieldOptions type.
           * @member {string} type
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.type = "";

          /**
           * FieldOptions scala_name.
           * @member {string} scala_name
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.scala_name = "";

          /**
           * FieldOptions collection_type.
           * @member {string} collection_type
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.collection_type = "";

          /**
           * FieldOptions key_type.
           * @member {string} key_type
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.key_type = "";

          /**
           * FieldOptions value_type.
           * @member {string} value_type
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.value_type = "";

          /**
           * FieldOptions annotations.
           * @member {Array.<string>} annotations
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.annotations = $util.emptyArray;

          /**
           * FieldOptions map_type.
           * @member {string} map_type
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.map_type = "";

          /**
           * FieldOptions no_box.
           * @member {boolean} no_box
           * @memberof scalapb.FieldOptions
           * @instance
           */
          FieldOptions.prototype.no_box = false;

          /**
           * Creates a new FieldOptions instance using the specified properties.
           * @function create
           * @memberof scalapb.FieldOptions
           * @static
           * @param {scalapb.IFieldOptions=} [properties] Properties to set
           * @returns {scalapb.FieldOptions} FieldOptions instance
           */
          FieldOptions.create = function create(properties) {
              return new FieldOptions(properties);
          };

          /**
           * Encodes the specified FieldOptions message. Does not implicitly {@link scalapb.FieldOptions.verify|verify} messages.
           * @function encode
           * @memberof scalapb.FieldOptions
           * @static
           * @param {scalapb.IFieldOptions} message FieldOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          FieldOptions.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.type != null && message.hasOwnProperty("type"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.scala_name);
              if (message.collection_type != null && message.hasOwnProperty("collection_type"))
                  writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection_type);
              if (message.key_type != null && message.hasOwnProperty("key_type"))
                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.key_type);
              if (message.value_type != null && message.hasOwnProperty("value_type"))
                  writer.uint32(/* id 5, wireType 2 =*/42).string(message.value_type);
              if (message.annotations != null && message.annotations.length)
                  for (var i = 0; i < message.annotations.length; ++i)
                      writer.uint32(/* id 6, wireType 2 =*/50).string(message.annotations[i]);
              if (message.map_type != null && message.hasOwnProperty("map_type"))
                  writer.uint32(/* id 7, wireType 2 =*/58).string(message.map_type);
              if (message.no_box != null && message.hasOwnProperty("no_box"))
                  writer.uint32(/* id 30, wireType 0 =*/240).bool(message.no_box);
              return writer;
          };

          /**
           * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link scalapb.FieldOptions.verify|verify} messages.
           * @function encodeDelimited
           * @memberof scalapb.FieldOptions
           * @static
           * @param {scalapb.IFieldOptions} message FieldOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a FieldOptions message from the specified reader or buffer.
           * @function decode
           * @memberof scalapb.FieldOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {scalapb.FieldOptions} FieldOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          FieldOptions.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.FieldOptions();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.type = reader.string();
                      break;
                  case 2:
                      message.scala_name = reader.string();
                      break;
                  case 3:
                      message.collection_type = reader.string();
                      break;
                  case 4:
                      message.key_type = reader.string();
                      break;
                  case 5:
                      message.value_type = reader.string();
                      break;
                  case 6:
                      if (!(message.annotations && message.annotations.length))
                          message.annotations = [];
                      message.annotations.push(reader.string());
                      break;
                  case 7:
                      message.map_type = reader.string();
                      break;
                  case 30:
                      message.no_box = reader.bool();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof scalapb.FieldOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {scalapb.FieldOptions} FieldOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          FieldOptions.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a FieldOptions message.
           * @function verify
           * @memberof scalapb.FieldOptions
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          FieldOptions.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.type != null && message.hasOwnProperty("type"))
                  if (!$util.isString(message.type))
                      return "type: string expected";
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  if (!$util.isString(message.scala_name))
                      return "scala_name: string expected";
              if (message.collection_type != null && message.hasOwnProperty("collection_type"))
                  if (!$util.isString(message.collection_type))
                      return "collection_type: string expected";
              if (message.key_type != null && message.hasOwnProperty("key_type"))
                  if (!$util.isString(message.key_type))
                      return "key_type: string expected";
              if (message.value_type != null && message.hasOwnProperty("value_type"))
                  if (!$util.isString(message.value_type))
                      return "value_type: string expected";
              if (message.annotations != null && message.hasOwnProperty("annotations")) {
                  if (!Array.isArray(message.annotations))
                      return "annotations: array expected";
                  for (var i = 0; i < message.annotations.length; ++i)
                      if (!$util.isString(message.annotations[i]))
                          return "annotations: string[] expected";
              }
              if (message.map_type != null && message.hasOwnProperty("map_type"))
                  if (!$util.isString(message.map_type))
                      return "map_type: string expected";
              if (message.no_box != null && message.hasOwnProperty("no_box"))
                  if (typeof message.no_box !== "boolean")
                      return "no_box: boolean expected";
              return null;
          };

          /**
           * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof scalapb.FieldOptions
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {scalapb.FieldOptions} FieldOptions
           */
          FieldOptions.fromObject = function fromObject(object) {
              if (object instanceof $root.scalapb.FieldOptions)
                  return object;
              var message = new $root.scalapb.FieldOptions();
              if (object.type != null)
                  message.type = String(object.type);
              if (object.scala_name != null)
                  message.scala_name = String(object.scala_name);
              if (object.collection_type != null)
                  message.collection_type = String(object.collection_type);
              if (object.key_type != null)
                  message.key_type = String(object.key_type);
              if (object.value_type != null)
                  message.value_type = String(object.value_type);
              if (object.annotations) {
                  if (!Array.isArray(object.annotations))
                      throw TypeError(".scalapb.FieldOptions.annotations: array expected");
                  message.annotations = [];
                  for (var i = 0; i < object.annotations.length; ++i)
                      message.annotations[i] = String(object.annotations[i]);
              }
              if (object.map_type != null)
                  message.map_type = String(object.map_type);
              if (object.no_box != null)
                  message.no_box = Boolean(object.no_box);
              return message;
          };

          /**
           * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
           * @function toObject
           * @memberof scalapb.FieldOptions
           * @static
           * @param {scalapb.FieldOptions} message FieldOptions
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          FieldOptions.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.annotations = [];
              if (options.defaults) {
                  object.type = "";
                  object.scala_name = "";
                  object.collection_type = "";
                  object.key_type = "";
                  object.value_type = "";
                  object.map_type = "";
                  object.no_box = false;
              }
              if (message.type != null && message.hasOwnProperty("type"))
                  object.type = message.type;
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  object.scala_name = message.scala_name;
              if (message.collection_type != null && message.hasOwnProperty("collection_type"))
                  object.collection_type = message.collection_type;
              if (message.key_type != null && message.hasOwnProperty("key_type"))
                  object.key_type = message.key_type;
              if (message.value_type != null && message.hasOwnProperty("value_type"))
                  object.value_type = message.value_type;
              if (message.annotations && message.annotations.length) {
                  object.annotations = [];
                  for (var j = 0; j < message.annotations.length; ++j)
                      object.annotations[j] = message.annotations[j];
              }
              if (message.map_type != null && message.hasOwnProperty("map_type"))
                  object.map_type = message.map_type;
              if (message.no_box != null && message.hasOwnProperty("no_box"))
                  object.no_box = message.no_box;
              return object;
          };

          /**
           * Converts this FieldOptions to JSON.
           * @function toJSON
           * @memberof scalapb.FieldOptions
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          FieldOptions.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return FieldOptions;
      })();

      scalapb.EnumOptions = (function() {

          /**
           * Properties of an EnumOptions.
           * @memberof scalapb
           * @interface IEnumOptions
           * @property {Array.<string>|null} ["extends"] EnumOptions extends
           * @property {Array.<string>|null} [companion_extends] EnumOptions companion_extends
           * @property {string|null} [type] EnumOptions type
           */

          /**
           * Constructs a new EnumOptions.
           * @memberof scalapb
           * @classdesc Represents an EnumOptions.
           * @implements IEnumOptions
           * @constructor
           * @param {scalapb.IEnumOptions=} [properties] Properties to set
           */
          function EnumOptions(properties) {
              this["extends"] = [];
              this.companion_extends = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * EnumOptions extends.
           * @member {Array.<string>} extends
           * @memberof scalapb.EnumOptions
           * @instance
           */
          EnumOptions.prototype["extends"] = $util.emptyArray;

          /**
           * EnumOptions companion_extends.
           * @member {Array.<string>} companion_extends
           * @memberof scalapb.EnumOptions
           * @instance
           */
          EnumOptions.prototype.companion_extends = $util.emptyArray;

          /**
           * EnumOptions type.
           * @member {string} type
           * @memberof scalapb.EnumOptions
           * @instance
           */
          EnumOptions.prototype.type = "";

          /**
           * Creates a new EnumOptions instance using the specified properties.
           * @function create
           * @memberof scalapb.EnumOptions
           * @static
           * @param {scalapb.IEnumOptions=} [properties] Properties to set
           * @returns {scalapb.EnumOptions} EnumOptions instance
           */
          EnumOptions.create = function create(properties) {
              return new EnumOptions(properties);
          };

          /**
           * Encodes the specified EnumOptions message. Does not implicitly {@link scalapb.EnumOptions.verify|verify} messages.
           * @function encode
           * @memberof scalapb.EnumOptions
           * @static
           * @param {scalapb.IEnumOptions} message EnumOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          EnumOptions.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message["extends"] != null && message["extends"].length)
                  for (var i = 0; i < message["extends"].length; ++i)
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message["extends"][i]);
              if (message.companion_extends != null && message.companion_extends.length)
                  for (var i = 0; i < message.companion_extends.length; ++i)
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.companion_extends[i]);
              if (message.type != null && message.hasOwnProperty("type"))
                  writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
              return writer;
          };

          /**
           * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link scalapb.EnumOptions.verify|verify} messages.
           * @function encodeDelimited
           * @memberof scalapb.EnumOptions
           * @static
           * @param {scalapb.IEnumOptions} message EnumOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an EnumOptions message from the specified reader or buffer.
           * @function decode
           * @memberof scalapb.EnumOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {scalapb.EnumOptions} EnumOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          EnumOptions.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.EnumOptions();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message["extends"] && message["extends"].length))
                          message["extends"] = [];
                      message["extends"].push(reader.string());
                      break;
                  case 2:
                      if (!(message.companion_extends && message.companion_extends.length))
                          message.companion_extends = [];
                      message.companion_extends.push(reader.string());
                      break;
                  case 3:
                      message.type = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof scalapb.EnumOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {scalapb.EnumOptions} EnumOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          EnumOptions.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an EnumOptions message.
           * @function verify
           * @memberof scalapb.EnumOptions
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          EnumOptions.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message["extends"] != null && message.hasOwnProperty("extends")) {
                  if (!Array.isArray(message["extends"]))
                      return "extends: array expected";
                  for (var i = 0; i < message["extends"].length; ++i)
                      if (!$util.isString(message["extends"][i]))
                          return "extends: string[] expected";
              }
              if (message.companion_extends != null && message.hasOwnProperty("companion_extends")) {
                  if (!Array.isArray(message.companion_extends))
                      return "companion_extends: array expected";
                  for (var i = 0; i < message.companion_extends.length; ++i)
                      if (!$util.isString(message.companion_extends[i]))
                          return "companion_extends: string[] expected";
              }
              if (message.type != null && message.hasOwnProperty("type"))
                  if (!$util.isString(message.type))
                      return "type: string expected";
              return null;
          };

          /**
           * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof scalapb.EnumOptions
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {scalapb.EnumOptions} EnumOptions
           */
          EnumOptions.fromObject = function fromObject(object) {
              if (object instanceof $root.scalapb.EnumOptions)
                  return object;
              var message = new $root.scalapb.EnumOptions();
              if (object["extends"]) {
                  if (!Array.isArray(object["extends"]))
                      throw TypeError(".scalapb.EnumOptions.extends: array expected");
                  message["extends"] = [];
                  for (var i = 0; i < object["extends"].length; ++i)
                      message["extends"][i] = String(object["extends"][i]);
              }
              if (object.companion_extends) {
                  if (!Array.isArray(object.companion_extends))
                      throw TypeError(".scalapb.EnumOptions.companion_extends: array expected");
                  message.companion_extends = [];
                  for (var i = 0; i < object.companion_extends.length; ++i)
                      message.companion_extends[i] = String(object.companion_extends[i]);
              }
              if (object.type != null)
                  message.type = String(object.type);
              return message;
          };

          /**
           * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
           * @function toObject
           * @memberof scalapb.EnumOptions
           * @static
           * @param {scalapb.EnumOptions} message EnumOptions
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          EnumOptions.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object["extends"] = [];
                  object.companion_extends = [];
              }
              if (options.defaults)
                  object.type = "";
              if (message["extends"] && message["extends"].length) {
                  object["extends"] = [];
                  for (var j = 0; j < message["extends"].length; ++j)
                      object["extends"][j] = message["extends"][j];
              }
              if (message.companion_extends && message.companion_extends.length) {
                  object.companion_extends = [];
                  for (var j = 0; j < message.companion_extends.length; ++j)
                      object.companion_extends[j] = message.companion_extends[j];
              }
              if (message.type != null && message.hasOwnProperty("type"))
                  object.type = message.type;
              return object;
          };

          /**
           * Converts this EnumOptions to JSON.
           * @function toJSON
           * @memberof scalapb.EnumOptions
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          EnumOptions.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return EnumOptions;
      })();

      scalapb.EnumValueOptions = (function() {

          /**
           * Properties of an EnumValueOptions.
           * @memberof scalapb
           * @interface IEnumValueOptions
           * @property {Array.<string>|null} ["extends"] EnumValueOptions extends
           * @property {string|null} [scala_name] EnumValueOptions scala_name
           */

          /**
           * Constructs a new EnumValueOptions.
           * @memberof scalapb
           * @classdesc Represents an EnumValueOptions.
           * @implements IEnumValueOptions
           * @constructor
           * @param {scalapb.IEnumValueOptions=} [properties] Properties to set
           */
          function EnumValueOptions(properties) {
              this["extends"] = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * EnumValueOptions extends.
           * @member {Array.<string>} extends
           * @memberof scalapb.EnumValueOptions
           * @instance
           */
          EnumValueOptions.prototype["extends"] = $util.emptyArray;

          /**
           * EnumValueOptions scala_name.
           * @member {string} scala_name
           * @memberof scalapb.EnumValueOptions
           * @instance
           */
          EnumValueOptions.prototype.scala_name = "";

          /**
           * Creates a new EnumValueOptions instance using the specified properties.
           * @function create
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {scalapb.IEnumValueOptions=} [properties] Properties to set
           * @returns {scalapb.EnumValueOptions} EnumValueOptions instance
           */
          EnumValueOptions.create = function create(properties) {
              return new EnumValueOptions(properties);
          };

          /**
           * Encodes the specified EnumValueOptions message. Does not implicitly {@link scalapb.EnumValueOptions.verify|verify} messages.
           * @function encode
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {scalapb.IEnumValueOptions} message EnumValueOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          EnumValueOptions.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message["extends"] != null && message["extends"].length)
                  for (var i = 0; i < message["extends"].length; ++i)
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message["extends"][i]);
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.scala_name);
              return writer;
          };

          /**
           * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link scalapb.EnumValueOptions.verify|verify} messages.
           * @function encodeDelimited
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {scalapb.IEnumValueOptions} message EnumValueOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an EnumValueOptions message from the specified reader or buffer.
           * @function decode
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {scalapb.EnumValueOptions} EnumValueOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          EnumValueOptions.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.EnumValueOptions();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message["extends"] && message["extends"].length))
                          message["extends"] = [];
                      message["extends"].push(reader.string());
                      break;
                  case 2:
                      message.scala_name = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {scalapb.EnumValueOptions} EnumValueOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an EnumValueOptions message.
           * @function verify
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          EnumValueOptions.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message["extends"] != null && message.hasOwnProperty("extends")) {
                  if (!Array.isArray(message["extends"]))
                      return "extends: array expected";
                  for (var i = 0; i < message["extends"].length; ++i)
                      if (!$util.isString(message["extends"][i]))
                          return "extends: string[] expected";
              }
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  if (!$util.isString(message.scala_name))
                      return "scala_name: string expected";
              return null;
          };

          /**
           * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {scalapb.EnumValueOptions} EnumValueOptions
           */
          EnumValueOptions.fromObject = function fromObject(object) {
              if (object instanceof $root.scalapb.EnumValueOptions)
                  return object;
              var message = new $root.scalapb.EnumValueOptions();
              if (object["extends"]) {
                  if (!Array.isArray(object["extends"]))
                      throw TypeError(".scalapb.EnumValueOptions.extends: array expected");
                  message["extends"] = [];
                  for (var i = 0; i < object["extends"].length; ++i)
                      message["extends"][i] = String(object["extends"][i]);
              }
              if (object.scala_name != null)
                  message.scala_name = String(object.scala_name);
              return message;
          };

          /**
           * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
           * @function toObject
           * @memberof scalapb.EnumValueOptions
           * @static
           * @param {scalapb.EnumValueOptions} message EnumValueOptions
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          EnumValueOptions.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object["extends"] = [];
              if (options.defaults)
                  object.scala_name = "";
              if (message["extends"] && message["extends"].length) {
                  object["extends"] = [];
                  for (var j = 0; j < message["extends"].length; ++j)
                      object["extends"][j] = message["extends"][j];
              }
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  object.scala_name = message.scala_name;
              return object;
          };

          /**
           * Converts this EnumValueOptions to JSON.
           * @function toJSON
           * @memberof scalapb.EnumValueOptions
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          EnumValueOptions.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return EnumValueOptions;
      })();

      scalapb.OneofOptions = (function() {

          /**
           * Properties of an OneofOptions.
           * @memberof scalapb
           * @interface IOneofOptions
           * @property {Array.<string>|null} ["extends"] OneofOptions extends
           * @property {string|null} [scala_name] OneofOptions scala_name
           */

          /**
           * Constructs a new OneofOptions.
           * @memberof scalapb
           * @classdesc Represents an OneofOptions.
           * @implements IOneofOptions
           * @constructor
           * @param {scalapb.IOneofOptions=} [properties] Properties to set
           */
          function OneofOptions(properties) {
              this["extends"] = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * OneofOptions extends.
           * @member {Array.<string>} extends
           * @memberof scalapb.OneofOptions
           * @instance
           */
          OneofOptions.prototype["extends"] = $util.emptyArray;

          /**
           * OneofOptions scala_name.
           * @member {string} scala_name
           * @memberof scalapb.OneofOptions
           * @instance
           */
          OneofOptions.prototype.scala_name = "";

          /**
           * Creates a new OneofOptions instance using the specified properties.
           * @function create
           * @memberof scalapb.OneofOptions
           * @static
           * @param {scalapb.IOneofOptions=} [properties] Properties to set
           * @returns {scalapb.OneofOptions} OneofOptions instance
           */
          OneofOptions.create = function create(properties) {
              return new OneofOptions(properties);
          };

          /**
           * Encodes the specified OneofOptions message. Does not implicitly {@link scalapb.OneofOptions.verify|verify} messages.
           * @function encode
           * @memberof scalapb.OneofOptions
           * @static
           * @param {scalapb.IOneofOptions} message OneofOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          OneofOptions.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message["extends"] != null && message["extends"].length)
                  for (var i = 0; i < message["extends"].length; ++i)
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message["extends"][i]);
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.scala_name);
              return writer;
          };

          /**
           * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link scalapb.OneofOptions.verify|verify} messages.
           * @function encodeDelimited
           * @memberof scalapb.OneofOptions
           * @static
           * @param {scalapb.IOneofOptions} message OneofOptions message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an OneofOptions message from the specified reader or buffer.
           * @function decode
           * @memberof scalapb.OneofOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {scalapb.OneofOptions} OneofOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          OneofOptions.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.scalapb.OneofOptions();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message["extends"] && message["extends"].length))
                          message["extends"] = [];
                      message["extends"].push(reader.string());
                      break;
                  case 2:
                      message.scala_name = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof scalapb.OneofOptions
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {scalapb.OneofOptions} OneofOptions
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          OneofOptions.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an OneofOptions message.
           * @function verify
           * @memberof scalapb.OneofOptions
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          OneofOptions.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message["extends"] != null && message.hasOwnProperty("extends")) {
                  if (!Array.isArray(message["extends"]))
                      return "extends: array expected";
                  for (var i = 0; i < message["extends"].length; ++i)
                      if (!$util.isString(message["extends"][i]))
                          return "extends: string[] expected";
              }
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  if (!$util.isString(message.scala_name))
                      return "scala_name: string expected";
              return null;
          };

          /**
           * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof scalapb.OneofOptions
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {scalapb.OneofOptions} OneofOptions
           */
          OneofOptions.fromObject = function fromObject(object) {
              if (object instanceof $root.scalapb.OneofOptions)
                  return object;
              var message = new $root.scalapb.OneofOptions();
              if (object["extends"]) {
                  if (!Array.isArray(object["extends"]))
                      throw TypeError(".scalapb.OneofOptions.extends: array expected");
                  message["extends"] = [];
                  for (var i = 0; i < object["extends"].length; ++i)
                      message["extends"][i] = String(object["extends"][i]);
              }
              if (object.scala_name != null)
                  message.scala_name = String(object.scala_name);
              return message;
          };

          /**
           * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
           * @function toObject
           * @memberof scalapb.OneofOptions
           * @static
           * @param {scalapb.OneofOptions} message OneofOptions
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          OneofOptions.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object["extends"] = [];
              if (options.defaults)
                  object.scala_name = "";
              if (message["extends"] && message["extends"].length) {
                  object["extends"] = [];
                  for (var j = 0; j < message["extends"].length; ++j)
                      object["extends"][j] = message["extends"][j];
              }
              if (message.scala_name != null && message.hasOwnProperty("scala_name"))
                  object.scala_name = message.scala_name;
              return object;
          };

          /**
           * Converts this OneofOptions to JSON.
           * @function toJSON
           * @memberof scalapb.OneofOptions
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          OneofOptions.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return OneofOptions;
      })();

      return scalapb;
  })();

  $root.google = (function() {

      /**
       * Namespace google.
       * @exports google
       * @namespace
       */
      var google = {};

      google.protobuf = (function() {

          /**
           * Namespace protobuf.
           * @memberof google
           * @namespace
           */
          var protobuf = {};

          protobuf.FileDescriptorSet = (function() {

              /**
               * Properties of a FileDescriptorSet.
               * @memberof google.protobuf
               * @interface IFileDescriptorSet
               * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
               */

              /**
               * Constructs a new FileDescriptorSet.
               * @memberof google.protobuf
               * @classdesc Represents a FileDescriptorSet.
               * @implements IFileDescriptorSet
               * @constructor
               * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
               */
              function FileDescriptorSet(properties) {
                  this.file = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * FileDescriptorSet file.
               * @member {Array.<google.protobuf.IFileDescriptorProto>} file
               * @memberof google.protobuf.FileDescriptorSet
               * @instance
               */
              FileDescriptorSet.prototype.file = $util.emptyArray;

              /**
               * Creates a new FileDescriptorSet instance using the specified properties.
               * @function create
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
               * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
               */
              FileDescriptorSet.create = function create(properties) {
                  return new FileDescriptorSet(properties);
              };

              /**
               * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FileDescriptorSet.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.file != null && message.file.length)
                      for (var i = 0; i < message.file.length; ++i)
                          $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a FileDescriptorSet message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FileDescriptorSet.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          if (!(message.file && message.file.length))
                              message.file = [];
                          message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a FileDescriptorSet message.
               * @function verify
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              FileDescriptorSet.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.file != null && message.hasOwnProperty("file")) {
                      if (!Array.isArray(message.file))
                          return "file: array expected";
                      for (var i = 0; i < message.file.length; ++i) {
                          var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                          if (error)
                              return "file." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
               */
              FileDescriptorSet.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.FileDescriptorSet)
                      return object;
                  var message = new $root.google.protobuf.FileDescriptorSet();
                  if (object.file) {
                      if (!Array.isArray(object.file))
                          throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                      message.file = [];
                      for (var i = 0; i < object.file.length; ++i) {
                          if (typeof object.file[i] !== "object")
                              throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                          message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                      }
                  }
                  return message;
              };

              /**
               * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.FileDescriptorSet
               * @static
               * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              FileDescriptorSet.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.file = [];
                  if (message.file && message.file.length) {
                      object.file = [];
                      for (var j = 0; j < message.file.length; ++j)
                          object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                  }
                  return object;
              };

              /**
               * Converts this FileDescriptorSet to JSON.
               * @function toJSON
               * @memberof google.protobuf.FileDescriptorSet
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              FileDescriptorSet.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return FileDescriptorSet;
          })();

          protobuf.FileDescriptorProto = (function() {

              /**
               * Properties of a FileDescriptorProto.
               * @memberof google.protobuf
               * @interface IFileDescriptorProto
               * @property {string|null} [name] FileDescriptorProto name
               * @property {string|null} ["package"] FileDescriptorProto package
               * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
               * @property {Array.<number>|null} [public_dependency] FileDescriptorProto public_dependency
               * @property {Array.<number>|null} [weak_dependency] FileDescriptorProto weak_dependency
               * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
               * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
               * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
               * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
               * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
               * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
               * @property {string|null} [syntax] FileDescriptorProto syntax
               */

              /**
               * Constructs a new FileDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents a FileDescriptorProto.
               * @implements IFileDescriptorProto
               * @constructor
               * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
               */
              function FileDescriptorProto(properties) {
                  this.dependency = [];
                  this.public_dependency = [];
                  this.weak_dependency = [];
                  this.message_type = [];
                  this.enum_type = [];
                  this.service = [];
                  this.extension = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * FileDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.name = "";

              /**
               * FileDescriptorProto package.
               * @member {string} package
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype["package"] = "";

              /**
               * FileDescriptorProto dependency.
               * @member {Array.<string>} dependency
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.dependency = $util.emptyArray;

              /**
               * FileDescriptorProto public_dependency.
               * @member {Array.<number>} public_dependency
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.public_dependency = $util.emptyArray;

              /**
               * FileDescriptorProto weak_dependency.
               * @member {Array.<number>} weak_dependency
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;

              /**
               * FileDescriptorProto message_type.
               * @member {Array.<google.protobuf.IDescriptorProto>} message_type
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.message_type = $util.emptyArray;

              /**
               * FileDescriptorProto enum_type.
               * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.enum_type = $util.emptyArray;

              /**
               * FileDescriptorProto service.
               * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.service = $util.emptyArray;

              /**
               * FileDescriptorProto extension.
               * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.extension = $util.emptyArray;

              /**
               * FileDescriptorProto options.
               * @member {google.protobuf.IFileOptions|null|undefined} options
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.options = null;

              /**
               * FileDescriptorProto source_code_info.
               * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.source_code_info = null;

              /**
               * FileDescriptorProto syntax.
               * @member {string} syntax
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               */
              FileDescriptorProto.prototype.syntax = "";

              /**
               * Creates a new FileDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
               */
              FileDescriptorProto.create = function create(properties) {
                  return new FileDescriptorProto(properties);
              };

              /**
               * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FileDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message["package"] != null && message.hasOwnProperty("package"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                  if (message.dependency != null && message.dependency.length)
                      for (var i = 0; i < message.dependency.length; ++i)
                          writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                  if (message.message_type != null && message.message_type.length)
                      for (var i = 0; i < message.message_type.length; ++i)
                          $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                  if (message.enum_type != null && message.enum_type.length)
                      for (var i = 0; i < message.enum_type.length; ++i)
                          $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                  if (message.service != null && message.service.length)
                      for (var i = 0; i < message.service.length; ++i)
                          $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                  if (message.extension != null && message.extension.length)
                      for (var i = 0; i < message.extension.length; ++i)
                          $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                  if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                      $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                  if (message.public_dependency != null && message.public_dependency.length)
                      for (var i = 0; i < message.public_dependency.length; ++i)
                          writer.uint32(/* id 10, wireType 0 =*/80).int32(message.public_dependency[i]);
                  if (message.weak_dependency != null && message.weak_dependency.length)
                      for (var i = 0; i < message.weak_dependency.length; ++i)
                          writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weak_dependency[i]);
                  if (message.syntax != null && message.hasOwnProperty("syntax"))
                      writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                  return writer;
              };

              /**
               * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a FileDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FileDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          message["package"] = reader.string();
                          break;
                      case 3:
                          if (!(message.dependency && message.dependency.length))
                              message.dependency = [];
                          message.dependency.push(reader.string());
                          break;
                      case 10:
                          if (!(message.public_dependency && message.public_dependency.length))
                              message.public_dependency = [];
                          if ((tag & 7) === 2) {
                              var end2 = reader.uint32() + reader.pos;
                              while (reader.pos < end2)
                                  message.public_dependency.push(reader.int32());
                          } else
                              message.public_dependency.push(reader.int32());
                          break;
                      case 11:
                          if (!(message.weak_dependency && message.weak_dependency.length))
                              message.weak_dependency = [];
                          if ((tag & 7) === 2) {
                              var end2 = reader.uint32() + reader.pos;
                              while (reader.pos < end2)
                                  message.weak_dependency.push(reader.int32());
                          } else
                              message.weak_dependency.push(reader.int32());
                          break;
                      case 4:
                          if (!(message.message_type && message.message_type.length))
                              message.message_type = [];
                          message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 5:
                          if (!(message.enum_type && message.enum_type.length))
                              message.enum_type = [];
                          message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 6:
                          if (!(message.service && message.service.length))
                              message.service = [];
                          message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 7:
                          if (!(message.extension && message.extension.length))
                              message.extension = [];
                          message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 8:
                          message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                          break;
                      case 9:
                          message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                          break;
                      case 12:
                          message.syntax = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a FileDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              FileDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message["package"] != null && message.hasOwnProperty("package"))
                      if (!$util.isString(message["package"]))
                          return "package: string expected";
                  if (message.dependency != null && message.hasOwnProperty("dependency")) {
                      if (!Array.isArray(message.dependency))
                          return "dependency: array expected";
                      for (var i = 0; i < message.dependency.length; ++i)
                          if (!$util.isString(message.dependency[i]))
                              return "dependency: string[] expected";
                  }
                  if (message.public_dependency != null && message.hasOwnProperty("public_dependency")) {
                      if (!Array.isArray(message.public_dependency))
                          return "public_dependency: array expected";
                      for (var i = 0; i < message.public_dependency.length; ++i)
                          if (!$util.isInteger(message.public_dependency[i]))
                              return "public_dependency: integer[] expected";
                  }
                  if (message.weak_dependency != null && message.hasOwnProperty("weak_dependency")) {
                      if (!Array.isArray(message.weak_dependency))
                          return "weak_dependency: array expected";
                      for (var i = 0; i < message.weak_dependency.length; ++i)
                          if (!$util.isInteger(message.weak_dependency[i]))
                              return "weak_dependency: integer[] expected";
                  }
                  if (message.message_type != null && message.hasOwnProperty("message_type")) {
                      if (!Array.isArray(message.message_type))
                          return "message_type: array expected";
                      for (var i = 0; i < message.message_type.length; ++i) {
                          var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                          if (error)
                              return "message_type." + error;
                      }
                  }
                  if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                      if (!Array.isArray(message.enum_type))
                          return "enum_type: array expected";
                      for (var i = 0; i < message.enum_type.length; ++i) {
                          var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                          if (error)
                              return "enum_type." + error;
                      }
                  }
                  if (message.service != null && message.hasOwnProperty("service")) {
                      if (!Array.isArray(message.service))
                          return "service: array expected";
                      for (var i = 0; i < message.service.length; ++i) {
                          var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                          if (error)
                              return "service." + error;
                      }
                  }
                  if (message.extension != null && message.hasOwnProperty("extension")) {
                      if (!Array.isArray(message.extension))
                          return "extension: array expected";
                      for (var i = 0; i < message.extension.length; ++i) {
                          var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                          if (error)
                              return "extension." + error;
                      }
                  }
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.FileOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                      var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                      if (error)
                          return "source_code_info." + error;
                  }
                  if (message.syntax != null && message.hasOwnProperty("syntax"))
                      if (!$util.isString(message.syntax))
                          return "syntax: string expected";
                  return null;
              };

              /**
               * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
               */
              FileDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.FileDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.FileDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object["package"] != null)
                      message["package"] = String(object["package"]);
                  if (object.dependency) {
                      if (!Array.isArray(object.dependency))
                          throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                      message.dependency = [];
                      for (var i = 0; i < object.dependency.length; ++i)
                          message.dependency[i] = String(object.dependency[i]);
                  }
                  if (object.public_dependency) {
                      if (!Array.isArray(object.public_dependency))
                          throw TypeError(".google.protobuf.FileDescriptorProto.public_dependency: array expected");
                      message.public_dependency = [];
                      for (var i = 0; i < object.public_dependency.length; ++i)
                          message.public_dependency[i] = object.public_dependency[i] | 0;
                  }
                  if (object.weak_dependency) {
                      if (!Array.isArray(object.weak_dependency))
                          throw TypeError(".google.protobuf.FileDescriptorProto.weak_dependency: array expected");
                      message.weak_dependency = [];
                      for (var i = 0; i < object.weak_dependency.length; ++i)
                          message.weak_dependency[i] = object.weak_dependency[i] | 0;
                  }
                  if (object.message_type) {
                      if (!Array.isArray(object.message_type))
                          throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                      message.message_type = [];
                      for (var i = 0; i < object.message_type.length; ++i) {
                          if (typeof object.message_type[i] !== "object")
                              throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                          message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                      }
                  }
                  if (object.enum_type) {
                      if (!Array.isArray(object.enum_type))
                          throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                      message.enum_type = [];
                      for (var i = 0; i < object.enum_type.length; ++i) {
                          if (typeof object.enum_type[i] !== "object")
                              throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                          message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                      }
                  }
                  if (object.service) {
                      if (!Array.isArray(object.service))
                          throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                      message.service = [];
                      for (var i = 0; i < object.service.length; ++i) {
                          if (typeof object.service[i] !== "object")
                              throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                          message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                      }
                  }
                  if (object.extension) {
                      if (!Array.isArray(object.extension))
                          throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                      message.extension = [];
                      for (var i = 0; i < object.extension.length; ++i) {
                          if (typeof object.extension[i] !== "object")
                              throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                          message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                      }
                  }
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                  }
                  if (object.source_code_info != null) {
                      if (typeof object.source_code_info !== "object")
                          throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                      message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                  }
                  if (object.syntax != null)
                      message.syntax = String(object.syntax);
                  return message;
              };

              /**
               * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.FileDescriptorProto
               * @static
               * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              FileDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults) {
                      object.dependency = [];
                      object.message_type = [];
                      object.enum_type = [];
                      object.service = [];
                      object.extension = [];
                      object.public_dependency = [];
                      object.weak_dependency = [];
                  }
                  if (options.defaults) {
                      object.name = "";
                      object["package"] = "";
                      object.options = null;
                      object.source_code_info = null;
                      object.syntax = "";
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message["package"] != null && message.hasOwnProperty("package"))
                      object["package"] = message["package"];
                  if (message.dependency && message.dependency.length) {
                      object.dependency = [];
                      for (var j = 0; j < message.dependency.length; ++j)
                          object.dependency[j] = message.dependency[j];
                  }
                  if (message.message_type && message.message_type.length) {
                      object.message_type = [];
                      for (var j = 0; j < message.message_type.length; ++j)
                          object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                  }
                  if (message.enum_type && message.enum_type.length) {
                      object.enum_type = [];
                      for (var j = 0; j < message.enum_type.length; ++j)
                          object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                  }
                  if (message.service && message.service.length) {
                      object.service = [];
                      for (var j = 0; j < message.service.length; ++j)
                          object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                  }
                  if (message.extension && message.extension.length) {
                      object.extension = [];
                      for (var j = 0; j < message.extension.length; ++j)
                          object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                  }
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                  if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                      object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                  if (message.public_dependency && message.public_dependency.length) {
                      object.public_dependency = [];
                      for (var j = 0; j < message.public_dependency.length; ++j)
                          object.public_dependency[j] = message.public_dependency[j];
                  }
                  if (message.weak_dependency && message.weak_dependency.length) {
                      object.weak_dependency = [];
                      for (var j = 0; j < message.weak_dependency.length; ++j)
                          object.weak_dependency[j] = message.weak_dependency[j];
                  }
                  if (message.syntax != null && message.hasOwnProperty("syntax"))
                      object.syntax = message.syntax;
                  return object;
              };

              /**
               * Converts this FileDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.FileDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              FileDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return FileDescriptorProto;
          })();

          protobuf.DescriptorProto = (function() {

              /**
               * Properties of a DescriptorProto.
               * @memberof google.protobuf
               * @interface IDescriptorProto
               * @property {string|null} [name] DescriptorProto name
               * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
               * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
               * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
               * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
               * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
               * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneof_decl] DescriptorProto oneof_decl
               * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
               * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reserved_range] DescriptorProto reserved_range
               * @property {Array.<string>|null} [reserved_name] DescriptorProto reserved_name
               */

              /**
               * Constructs a new DescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents a DescriptorProto.
               * @implements IDescriptorProto
               * @constructor
               * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
               */
              function DescriptorProto(properties) {
                  this.field = [];
                  this.extension = [];
                  this.nested_type = [];
                  this.enum_type = [];
                  this.extension_range = [];
                  this.oneof_decl = [];
                  this.reserved_range = [];
                  this.reserved_name = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * DescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.name = "";

              /**
               * DescriptorProto field.
               * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.field = $util.emptyArray;

              /**
               * DescriptorProto extension.
               * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.extension = $util.emptyArray;

              /**
               * DescriptorProto nested_type.
               * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.nested_type = $util.emptyArray;

              /**
               * DescriptorProto enum_type.
               * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.enum_type = $util.emptyArray;

              /**
               * DescriptorProto extension_range.
               * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.extension_range = $util.emptyArray;

              /**
               * DescriptorProto oneof_decl.
               * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneof_decl
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.oneof_decl = $util.emptyArray;

              /**
               * DescriptorProto options.
               * @member {google.protobuf.IMessageOptions|null|undefined} options
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.options = null;

              /**
               * DescriptorProto reserved_range.
               * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reserved_range
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.reserved_range = $util.emptyArray;

              /**
               * DescriptorProto reserved_name.
               * @member {Array.<string>} reserved_name
               * @memberof google.protobuf.DescriptorProto
               * @instance
               */
              DescriptorProto.prototype.reserved_name = $util.emptyArray;

              /**
               * Creates a new DescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
               */
              DescriptorProto.create = function create(properties) {
                  return new DescriptorProto(properties);
              };

              /**
               * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              DescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.field != null && message.field.length)
                      for (var i = 0; i < message.field.length; ++i)
                          $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  if (message.nested_type != null && message.nested_type.length)
                      for (var i = 0; i < message.nested_type.length; ++i)
                          $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                  if (message.enum_type != null && message.enum_type.length)
                      for (var i = 0; i < message.enum_type.length; ++i)
                          $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                  if (message.extension_range != null && message.extension_range.length)
                      for (var i = 0; i < message.extension_range.length; ++i)
                          $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                  if (message.extension != null && message.extension.length)
                      for (var i = 0; i < message.extension.length; ++i)
                          $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                  if (message.oneof_decl != null && message.oneof_decl.length)
                      for (var i = 0; i < message.oneof_decl.length; ++i)
                          $root.google.protobuf.OneofDescriptorProto.encode(message.oneof_decl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                  if (message.reserved_range != null && message.reserved_range.length)
                      for (var i = 0; i < message.reserved_range.length; ++i)
                          $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reserved_range[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                  if (message.reserved_name != null && message.reserved_name.length)
                      for (var i = 0; i < message.reserved_name.length; ++i)
                          writer.uint32(/* id 10, wireType 2 =*/82).string(message.reserved_name[i]);
                  return writer;
              };

              /**
               * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a DescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.DescriptorProto} DescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              DescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          if (!(message.field && message.field.length))
                              message.field = [];
                          message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 6:
                          if (!(message.extension && message.extension.length))
                              message.extension = [];
                          message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 3:
                          if (!(message.nested_type && message.nested_type.length))
                              message.nested_type = [];
                          message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 4:
                          if (!(message.enum_type && message.enum_type.length))
                              message.enum_type = [];
                          message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 5:
                          if (!(message.extension_range && message.extension_range.length))
                              message.extension_range = [];
                          message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                          break;
                      case 8:
                          if (!(message.oneof_decl && message.oneof_decl.length))
                              message.oneof_decl = [];
                          message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 7:
                          message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                          break;
                      case 9:
                          if (!(message.reserved_range && message.reserved_range.length))
                              message.reserved_range = [];
                          message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                          break;
                      case 10:
                          if (!(message.reserved_name && message.reserved_name.length))
                              message.reserved_name = [];
                          message.reserved_name.push(reader.string());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.DescriptorProto} DescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a DescriptorProto message.
               * @function verify
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              DescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.field != null && message.hasOwnProperty("field")) {
                      if (!Array.isArray(message.field))
                          return "field: array expected";
                      for (var i = 0; i < message.field.length; ++i) {
                          var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                          if (error)
                              return "field." + error;
                      }
                  }
                  if (message.extension != null && message.hasOwnProperty("extension")) {
                      if (!Array.isArray(message.extension))
                          return "extension: array expected";
                      for (var i = 0; i < message.extension.length; ++i) {
                          var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                          if (error)
                              return "extension." + error;
                      }
                  }
                  if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                      if (!Array.isArray(message.nested_type))
                          return "nested_type: array expected";
                      for (var i = 0; i < message.nested_type.length; ++i) {
                          var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                          if (error)
                              return "nested_type." + error;
                      }
                  }
                  if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                      if (!Array.isArray(message.enum_type))
                          return "enum_type: array expected";
                      for (var i = 0; i < message.enum_type.length; ++i) {
                          var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                          if (error)
                              return "enum_type." + error;
                      }
                  }
                  if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                      if (!Array.isArray(message.extension_range))
                          return "extension_range: array expected";
                      for (var i = 0; i < message.extension_range.length; ++i) {
                          var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                          if (error)
                              return "extension_range." + error;
                      }
                  }
                  if (message.oneof_decl != null && message.hasOwnProperty("oneof_decl")) {
                      if (!Array.isArray(message.oneof_decl))
                          return "oneof_decl: array expected";
                      for (var i = 0; i < message.oneof_decl.length; ++i) {
                          var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
                          if (error)
                              return "oneof_decl." + error;
                      }
                  }
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.MessageOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  if (message.reserved_range != null && message.hasOwnProperty("reserved_range")) {
                      if (!Array.isArray(message.reserved_range))
                          return "reserved_range: array expected";
                      for (var i = 0; i < message.reserved_range.length; ++i) {
                          var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
                          if (error)
                              return "reserved_range." + error;
                      }
                  }
                  if (message.reserved_name != null && message.hasOwnProperty("reserved_name")) {
                      if (!Array.isArray(message.reserved_name))
                          return "reserved_name: array expected";
                      for (var i = 0; i < message.reserved_name.length; ++i)
                          if (!$util.isString(message.reserved_name[i]))
                              return "reserved_name: string[] expected";
                  }
                  return null;
              };

              /**
               * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.DescriptorProto} DescriptorProto
               */
              DescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.DescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.DescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.field) {
                      if (!Array.isArray(object.field))
                          throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                      message.field = [];
                      for (var i = 0; i < object.field.length; ++i) {
                          if (typeof object.field[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                          message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                      }
                  }
                  if (object.extension) {
                      if (!Array.isArray(object.extension))
                          throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                      message.extension = [];
                      for (var i = 0; i < object.extension.length; ++i) {
                          if (typeof object.extension[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                          message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                      }
                  }
                  if (object.nested_type) {
                      if (!Array.isArray(object.nested_type))
                          throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                      message.nested_type = [];
                      for (var i = 0; i < object.nested_type.length; ++i) {
                          if (typeof object.nested_type[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                          message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                      }
                  }
                  if (object.enum_type) {
                      if (!Array.isArray(object.enum_type))
                          throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                      message.enum_type = [];
                      for (var i = 0; i < object.enum_type.length; ++i) {
                          if (typeof object.enum_type[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                          message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                      }
                  }
                  if (object.extension_range) {
                      if (!Array.isArray(object.extension_range))
                          throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                      message.extension_range = [];
                      for (var i = 0; i < object.extension_range.length; ++i) {
                          if (typeof object.extension_range[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                          message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                      }
                  }
                  if (object.oneof_decl) {
                      if (!Array.isArray(object.oneof_decl))
                          throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: array expected");
                      message.oneof_decl = [];
                      for (var i = 0; i < object.oneof_decl.length; ++i) {
                          if (typeof object.oneof_decl[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: object expected");
                          message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
                      }
                  }
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                  }
                  if (object.reserved_range) {
                      if (!Array.isArray(object.reserved_range))
                          throw TypeError(".google.protobuf.DescriptorProto.reserved_range: array expected");
                      message.reserved_range = [];
                      for (var i = 0; i < object.reserved_range.length; ++i) {
                          if (typeof object.reserved_range[i] !== "object")
                              throw TypeError(".google.protobuf.DescriptorProto.reserved_range: object expected");
                          message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
                      }
                  }
                  if (object.reserved_name) {
                      if (!Array.isArray(object.reserved_name))
                          throw TypeError(".google.protobuf.DescriptorProto.reserved_name: array expected");
                      message.reserved_name = [];
                      for (var i = 0; i < object.reserved_name.length; ++i)
                          message.reserved_name[i] = String(object.reserved_name[i]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.DescriptorProto
               * @static
               * @param {google.protobuf.DescriptorProto} message DescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              DescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults) {
                      object.field = [];
                      object.nested_type = [];
                      object.enum_type = [];
                      object.extension_range = [];
                      object.extension = [];
                      object.oneof_decl = [];
                      object.reserved_range = [];
                      object.reserved_name = [];
                  }
                  if (options.defaults) {
                      object.name = "";
                      object.options = null;
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.field && message.field.length) {
                      object.field = [];
                      for (var j = 0; j < message.field.length; ++j)
                          object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                  }
                  if (message.nested_type && message.nested_type.length) {
                      object.nested_type = [];
                      for (var j = 0; j < message.nested_type.length; ++j)
                          object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                  }
                  if (message.enum_type && message.enum_type.length) {
                      object.enum_type = [];
                      for (var j = 0; j < message.enum_type.length; ++j)
                          object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                  }
                  if (message.extension_range && message.extension_range.length) {
                      object.extension_range = [];
                      for (var j = 0; j < message.extension_range.length; ++j)
                          object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                  }
                  if (message.extension && message.extension.length) {
                      object.extension = [];
                      for (var j = 0; j < message.extension.length; ++j)
                          object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                  }
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                  if (message.oneof_decl && message.oneof_decl.length) {
                      object.oneof_decl = [];
                      for (var j = 0; j < message.oneof_decl.length; ++j)
                          object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
                  }
                  if (message.reserved_range && message.reserved_range.length) {
                      object.reserved_range = [];
                      for (var j = 0; j < message.reserved_range.length; ++j)
                          object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
                  }
                  if (message.reserved_name && message.reserved_name.length) {
                      object.reserved_name = [];
                      for (var j = 0; j < message.reserved_name.length; ++j)
                          object.reserved_name[j] = message.reserved_name[j];
                  }
                  return object;
              };

              /**
               * Converts this DescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.DescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              DescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              DescriptorProto.ExtensionRange = (function() {

                  /**
                   * Properties of an ExtensionRange.
                   * @memberof google.protobuf.DescriptorProto
                   * @interface IExtensionRange
                   * @property {number|null} [start] ExtensionRange start
                   * @property {number|null} [end] ExtensionRange end
                   */

                  /**
                   * Constructs a new ExtensionRange.
                   * @memberof google.protobuf.DescriptorProto
                   * @classdesc Represents an ExtensionRange.
                   * @implements IExtensionRange
                   * @constructor
                   * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                   */
                  function ExtensionRange(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * ExtensionRange start.
                   * @member {number} start
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @instance
                   */
                  ExtensionRange.prototype.start = 0;

                  /**
                   * ExtensionRange end.
                   * @member {number} end
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @instance
                   */
                  ExtensionRange.prototype.end = 0;

                  /**
                   * Creates a new ExtensionRange instance using the specified properties.
                   * @function create
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                   * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                   */
                  ExtensionRange.create = function create(properties) {
                      return new ExtensionRange(properties);
                  };

                  /**
                   * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                   * @function encode
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ExtensionRange.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.start != null && message.hasOwnProperty("start"))
                          writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                      if (message.end != null && message.hasOwnProperty("end"))
                          writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                      return writer;
                  };

                  /**
                   * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes an ExtensionRange message from the specified reader or buffer.
                   * @function decode
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ExtensionRange.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.start = reader.int32();
                              break;
                          case 2:
                              message.end = reader.int32();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies an ExtensionRange message.
                   * @function verify
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  ExtensionRange.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.start != null && message.hasOwnProperty("start"))
                          if (!$util.isInteger(message.start))
                              return "start: integer expected";
                      if (message.end != null && message.hasOwnProperty("end"))
                          if (!$util.isInteger(message.end))
                              return "end: integer expected";
                      return null;
                  };

                  /**
                   * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                   */
                  ExtensionRange.fromObject = function fromObject(object) {
                      if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                          return object;
                      var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                      if (object.start != null)
                          message.start = object.start | 0;
                      if (object.end != null)
                          message.end = object.end | 0;
                      return message;
                  };

                  /**
                   * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  ExtensionRange.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults) {
                          object.start = 0;
                          object.end = 0;
                      }
                      if (message.start != null && message.hasOwnProperty("start"))
                          object.start = message.start;
                      if (message.end != null && message.hasOwnProperty("end"))
                          object.end = message.end;
                      return object;
                  };

                  /**
                   * Converts this ExtensionRange to JSON.
                   * @function toJSON
                   * @memberof google.protobuf.DescriptorProto.ExtensionRange
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  ExtensionRange.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return ExtensionRange;
              })();

              DescriptorProto.ReservedRange = (function() {

                  /**
                   * Properties of a ReservedRange.
                   * @memberof google.protobuf.DescriptorProto
                   * @interface IReservedRange
                   * @property {number|null} [start] ReservedRange start
                   * @property {number|null} [end] ReservedRange end
                   */

                  /**
                   * Constructs a new ReservedRange.
                   * @memberof google.protobuf.DescriptorProto
                   * @classdesc Represents a ReservedRange.
                   * @implements IReservedRange
                   * @constructor
                   * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                   */
                  function ReservedRange(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * ReservedRange start.
                   * @member {number} start
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @instance
                   */
                  ReservedRange.prototype.start = 0;

                  /**
                   * ReservedRange end.
                   * @member {number} end
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @instance
                   */
                  ReservedRange.prototype.end = 0;

                  /**
                   * Creates a new ReservedRange instance using the specified properties.
                   * @function create
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                   * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                   */
                  ReservedRange.create = function create(properties) {
                      return new ReservedRange(properties);
                  };

                  /**
                   * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                   * @function encode
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ReservedRange.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.start != null && message.hasOwnProperty("start"))
                          writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                      if (message.end != null && message.hasOwnProperty("end"))
                          writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                      return writer;
                  };

                  /**
                   * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a ReservedRange message from the specified reader or buffer.
                   * @function decode
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ReservedRange.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.start = reader.int32();
                              break;
                          case 2:
                              message.end = reader.int32();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a ReservedRange message.
                   * @function verify
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  ReservedRange.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.start != null && message.hasOwnProperty("start"))
                          if (!$util.isInteger(message.start))
                              return "start: integer expected";
                      if (message.end != null && message.hasOwnProperty("end"))
                          if (!$util.isInteger(message.end))
                              return "end: integer expected";
                      return null;
                  };

                  /**
                   * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                   */
                  ReservedRange.fromObject = function fromObject(object) {
                      if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                          return object;
                      var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                      if (object.start != null)
                          message.start = object.start | 0;
                      if (object.end != null)
                          message.end = object.end | 0;
                      return message;
                  };

                  /**
                   * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @static
                   * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  ReservedRange.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults) {
                          object.start = 0;
                          object.end = 0;
                      }
                      if (message.start != null && message.hasOwnProperty("start"))
                          object.start = message.start;
                      if (message.end != null && message.hasOwnProperty("end"))
                          object.end = message.end;
                      return object;
                  };

                  /**
                   * Converts this ReservedRange to JSON.
                   * @function toJSON
                   * @memberof google.protobuf.DescriptorProto.ReservedRange
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  ReservedRange.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return ReservedRange;
              })();

              return DescriptorProto;
          })();

          protobuf.FieldDescriptorProto = (function() {

              /**
               * Properties of a FieldDescriptorProto.
               * @memberof google.protobuf
               * @interface IFieldDescriptorProto
               * @property {string|null} [name] FieldDescriptorProto name
               * @property {number|null} [number] FieldDescriptorProto number
               * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
               * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
               * @property {string|null} [type_name] FieldDescriptorProto type_name
               * @property {string|null} [extendee] FieldDescriptorProto extendee
               * @property {string|null} [default_value] FieldDescriptorProto default_value
               * @property {number|null} [oneof_index] FieldDescriptorProto oneof_index
               * @property {string|null} [json_name] FieldDescriptorProto json_name
               * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
               */

              /**
               * Constructs a new FieldDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents a FieldDescriptorProto.
               * @implements IFieldDescriptorProto
               * @constructor
               * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
               */
              function FieldDescriptorProto(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * FieldDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.name = "";

              /**
               * FieldDescriptorProto number.
               * @member {number} number
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.number = 0;

              /**
               * FieldDescriptorProto label.
               * @member {google.protobuf.FieldDescriptorProto.Label} label
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.label = 1;

              /**
               * FieldDescriptorProto type.
               * @member {google.protobuf.FieldDescriptorProto.Type} type
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.type = 1;

              /**
               * FieldDescriptorProto type_name.
               * @member {string} type_name
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.type_name = "";

              /**
               * FieldDescriptorProto extendee.
               * @member {string} extendee
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.extendee = "";

              /**
               * FieldDescriptorProto default_value.
               * @member {string} default_value
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.default_value = "";

              /**
               * FieldDescriptorProto oneof_index.
               * @member {number} oneof_index
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.oneof_index = 0;

              /**
               * FieldDescriptorProto json_name.
               * @member {string} json_name
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.json_name = "";

              /**
               * FieldDescriptorProto options.
               * @member {google.protobuf.IFieldOptions|null|undefined} options
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               */
              FieldDescriptorProto.prototype.options = null;

              /**
               * Creates a new FieldDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
               */
              FieldDescriptorProto.create = function create(properties) {
                  return new FieldDescriptorProto(properties);
              };

              /**
               * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FieldDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.extendee != null && message.hasOwnProperty("extendee"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                  if (message.number != null && message.hasOwnProperty("number"))
                      writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                  if (message.label != null && message.hasOwnProperty("label"))
                      writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                  if (message.type != null && message.hasOwnProperty("type"))
                      writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                  if (message.type_name != null && message.hasOwnProperty("type_name"))
                      writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                  if (message.default_value != null && message.hasOwnProperty("default_value"))
                      writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                  if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                      writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneof_index);
                  if (message.json_name != null && message.hasOwnProperty("json_name"))
                      writer.uint32(/* id 10, wireType 2 =*/82).string(message.json_name);
                  return writer;
              };

              /**
               * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a FieldDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FieldDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 3:
                          message.number = reader.int32();
                          break;
                      case 4:
                          message.label = reader.int32();
                          break;
                      case 5:
                          message.type = reader.int32();
                          break;
                      case 6:
                          message.type_name = reader.string();
                          break;
                      case 2:
                          message.extendee = reader.string();
                          break;
                      case 7:
                          message.default_value = reader.string();
                          break;
                      case 9:
                          message.oneof_index = reader.int32();
                          break;
                      case 10:
                          message.json_name = reader.string();
                          break;
                      case 8:
                          message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a FieldDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              FieldDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.number != null && message.hasOwnProperty("number"))
                      if (!$util.isInteger(message.number))
                          return "number: integer expected";
                  if (message.label != null && message.hasOwnProperty("label"))
                      switch (message.label) {
                      default:
                          return "label: enum value expected";
                      case 1:
                      case 2:
                      case 3:
                          break;
                      }
                  if (message.type != null && message.hasOwnProperty("type"))
                      switch (message.type) {
                      default:
                          return "type: enum value expected";
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:
                      case 10:
                      case 11:
                      case 12:
                      case 13:
                      case 14:
                      case 15:
                      case 16:
                      case 17:
                      case 18:
                          break;
                      }
                  if (message.type_name != null && message.hasOwnProperty("type_name"))
                      if (!$util.isString(message.type_name))
                          return "type_name: string expected";
                  if (message.extendee != null && message.hasOwnProperty("extendee"))
                      if (!$util.isString(message.extendee))
                          return "extendee: string expected";
                  if (message.default_value != null && message.hasOwnProperty("default_value"))
                      if (!$util.isString(message.default_value))
                          return "default_value: string expected";
                  if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                      if (!$util.isInteger(message.oneof_index))
                          return "oneof_index: integer expected";
                  if (message.json_name != null && message.hasOwnProperty("json_name"))
                      if (!$util.isString(message.json_name))
                          return "json_name: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.FieldOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
               */
              FieldDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.FieldDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.number != null)
                      message.number = object.number | 0;
                  switch (object.label) {
                  case "LABEL_OPTIONAL":
                  case 1:
                      message.label = 1;
                      break;
                  case "LABEL_REQUIRED":
                  case 2:
                      message.label = 2;
                      break;
                  case "LABEL_REPEATED":
                  case 3:
                      message.label = 3;
                      break;
                  }
                  switch (object.type) {
                  case "TYPE_DOUBLE":
                  case 1:
                      message.type = 1;
                      break;
                  case "TYPE_FLOAT":
                  case 2:
                      message.type = 2;
                      break;
                  case "TYPE_INT64":
                  case 3:
                      message.type = 3;
                      break;
                  case "TYPE_UINT64":
                  case 4:
                      message.type = 4;
                      break;
                  case "TYPE_INT32":
                  case 5:
                      message.type = 5;
                      break;
                  case "TYPE_FIXED64":
                  case 6:
                      message.type = 6;
                      break;
                  case "TYPE_FIXED32":
                  case 7:
                      message.type = 7;
                      break;
                  case "TYPE_BOOL":
                  case 8:
                      message.type = 8;
                      break;
                  case "TYPE_STRING":
                  case 9:
                      message.type = 9;
                      break;
                  case "TYPE_GROUP":
                  case 10:
                      message.type = 10;
                      break;
                  case "TYPE_MESSAGE":
                  case 11:
                      message.type = 11;
                      break;
                  case "TYPE_BYTES":
                  case 12:
                      message.type = 12;
                      break;
                  case "TYPE_UINT32":
                  case 13:
                      message.type = 13;
                      break;
                  case "TYPE_ENUM":
                  case 14:
                      message.type = 14;
                      break;
                  case "TYPE_SFIXED32":
                  case 15:
                      message.type = 15;
                      break;
                  case "TYPE_SFIXED64":
                  case 16:
                      message.type = 16;
                      break;
                  case "TYPE_SINT32":
                  case 17:
                      message.type = 17;
                      break;
                  case "TYPE_SINT64":
                  case 18:
                      message.type = 18;
                      break;
                  }
                  if (object.type_name != null)
                      message.type_name = String(object.type_name);
                  if (object.extendee != null)
                      message.extendee = String(object.extendee);
                  if (object.default_value != null)
                      message.default_value = String(object.default_value);
                  if (object.oneof_index != null)
                      message.oneof_index = object.oneof_index | 0;
                  if (object.json_name != null)
                      message.json_name = String(object.json_name);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.FieldDescriptorProto
               * @static
               * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              FieldDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.name = "";
                      object.extendee = "";
                      object.number = 0;
                      object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                      object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                      object.type_name = "";
                      object.default_value = "";
                      object.options = null;
                      object.oneof_index = 0;
                      object.json_name = "";
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.extendee != null && message.hasOwnProperty("extendee"))
                      object.extendee = message.extendee;
                  if (message.number != null && message.hasOwnProperty("number"))
                      object.number = message.number;
                  if (message.label != null && message.hasOwnProperty("label"))
                      object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                  if (message.type != null && message.hasOwnProperty("type"))
                      object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                  if (message.type_name != null && message.hasOwnProperty("type_name"))
                      object.type_name = message.type_name;
                  if (message.default_value != null && message.hasOwnProperty("default_value"))
                      object.default_value = message.default_value;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                  if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                      object.oneof_index = message.oneof_index;
                  if (message.json_name != null && message.hasOwnProperty("json_name"))
                      object.json_name = message.json_name;
                  return object;
              };

              /**
               * Converts this FieldDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.FieldDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              FieldDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              /**
               * Type enum.
               * @name google.protobuf.FieldDescriptorProto.Type
               * @enum {string}
               * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
               * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
               * @property {number} TYPE_INT64=3 TYPE_INT64 value
               * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
               * @property {number} TYPE_INT32=5 TYPE_INT32 value
               * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
               * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
               * @property {number} TYPE_BOOL=8 TYPE_BOOL value
               * @property {number} TYPE_STRING=9 TYPE_STRING value
               * @property {number} TYPE_GROUP=10 TYPE_GROUP value
               * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
               * @property {number} TYPE_BYTES=12 TYPE_BYTES value
               * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
               * @property {number} TYPE_ENUM=14 TYPE_ENUM value
               * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
               * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
               * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
               * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
               */
              FieldDescriptorProto.Type = (function() {
                  var valuesById = {}, values = Object.create(valuesById);
                  values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                  values[valuesById[2] = "TYPE_FLOAT"] = 2;
                  values[valuesById[3] = "TYPE_INT64"] = 3;
                  values[valuesById[4] = "TYPE_UINT64"] = 4;
                  values[valuesById[5] = "TYPE_INT32"] = 5;
                  values[valuesById[6] = "TYPE_FIXED64"] = 6;
                  values[valuesById[7] = "TYPE_FIXED32"] = 7;
                  values[valuesById[8] = "TYPE_BOOL"] = 8;
                  values[valuesById[9] = "TYPE_STRING"] = 9;
                  values[valuesById[10] = "TYPE_GROUP"] = 10;
                  values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                  values[valuesById[12] = "TYPE_BYTES"] = 12;
                  values[valuesById[13] = "TYPE_UINT32"] = 13;
                  values[valuesById[14] = "TYPE_ENUM"] = 14;
                  values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                  values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                  values[valuesById[17] = "TYPE_SINT32"] = 17;
                  values[valuesById[18] = "TYPE_SINT64"] = 18;
                  return values;
              })();

              /**
               * Label enum.
               * @name google.protobuf.FieldDescriptorProto.Label
               * @enum {string}
               * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
               * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
               * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
               */
              FieldDescriptorProto.Label = (function() {
                  var valuesById = {}, values = Object.create(valuesById);
                  values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                  values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                  values[valuesById[3] = "LABEL_REPEATED"] = 3;
                  return values;
              })();

              return FieldDescriptorProto;
          })();

          protobuf.OneofDescriptorProto = (function() {

              /**
               * Properties of an OneofDescriptorProto.
               * @memberof google.protobuf
               * @interface IOneofDescriptorProto
               * @property {string|null} [name] OneofDescriptorProto name
               * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
               */

              /**
               * Constructs a new OneofDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents an OneofDescriptorProto.
               * @implements IOneofDescriptorProto
               * @constructor
               * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
               */
              function OneofDescriptorProto(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * OneofDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.OneofDescriptorProto
               * @instance
               */
              OneofDescriptorProto.prototype.name = "";

              /**
               * OneofDescriptorProto options.
               * @member {google.protobuf.IOneofOptions|null|undefined} options
               * @memberof google.protobuf.OneofDescriptorProto
               * @instance
               */
              OneofDescriptorProto.prototype.options = null;

              /**
               * Creates a new OneofDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
               */
              OneofDescriptorProto.create = function create(properties) {
                  return new OneofDescriptorProto(properties);
              };

              /**
               * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              OneofDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an OneofDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              OneofDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an OneofDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              OneofDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.OneofOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
               */
              OneofDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.OneofDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.OneofDescriptorProto
               * @static
               * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              OneofDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.name = "";
                      object.options = null;
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this OneofDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.OneofDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              OneofDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return OneofDescriptorProto;
          })();

          protobuf.EnumDescriptorProto = (function() {

              /**
               * Properties of an EnumDescriptorProto.
               * @memberof google.protobuf
               * @interface IEnumDescriptorProto
               * @property {string|null} [name] EnumDescriptorProto name
               * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
               * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
               */

              /**
               * Constructs a new EnumDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents an EnumDescriptorProto.
               * @implements IEnumDescriptorProto
               * @constructor
               * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
               */
              function EnumDescriptorProto(properties) {
                  this.value = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * EnumDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.EnumDescriptorProto
               * @instance
               */
              EnumDescriptorProto.prototype.name = "";

              /**
               * EnumDescriptorProto value.
               * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
               * @memberof google.protobuf.EnumDescriptorProto
               * @instance
               */
              EnumDescriptorProto.prototype.value = $util.emptyArray;

              /**
               * EnumDescriptorProto options.
               * @member {google.protobuf.IEnumOptions|null|undefined} options
               * @memberof google.protobuf.EnumDescriptorProto
               * @instance
               */
              EnumDescriptorProto.prototype.options = null;

              /**
               * Creates a new EnumDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
               */
              EnumDescriptorProto.create = function create(properties) {
                  return new EnumDescriptorProto(properties);
              };

              /**
               * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.value != null && message.value.length)
                      for (var i = 0; i < message.value.length; ++i)
                          $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an EnumDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          if (!(message.value && message.value.length))
                              message.value = [];
                          message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 3:
                          message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an EnumDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              EnumDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.value != null && message.hasOwnProperty("value")) {
                      if (!Array.isArray(message.value))
                          return "value: array expected";
                      for (var i = 0; i < message.value.length; ++i) {
                          var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                          if (error)
                              return "value." + error;
                      }
                  }
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.EnumOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
               */
              EnumDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.EnumDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.value) {
                      if (!Array.isArray(object.value))
                          throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                      message.value = [];
                      for (var i = 0; i < object.value.length; ++i) {
                          if (typeof object.value[i] !== "object")
                              throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                          message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                      }
                  }
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.EnumDescriptorProto
               * @static
               * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              EnumDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.value = [];
                  if (options.defaults) {
                      object.name = "";
                      object.options = null;
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.value && message.value.length) {
                      object.value = [];
                      for (var j = 0; j < message.value.length; ++j)
                          object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                  }
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this EnumDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.EnumDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              EnumDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return EnumDescriptorProto;
          })();

          protobuf.EnumValueDescriptorProto = (function() {

              /**
               * Properties of an EnumValueDescriptorProto.
               * @memberof google.protobuf
               * @interface IEnumValueDescriptorProto
               * @property {string|null} [name] EnumValueDescriptorProto name
               * @property {number|null} [number] EnumValueDescriptorProto number
               * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
               */

              /**
               * Constructs a new EnumValueDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents an EnumValueDescriptorProto.
               * @implements IEnumValueDescriptorProto
               * @constructor
               * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
               */
              function EnumValueDescriptorProto(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * EnumValueDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @instance
               */
              EnumValueDescriptorProto.prototype.name = "";

              /**
               * EnumValueDescriptorProto number.
               * @member {number} number
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @instance
               */
              EnumValueDescriptorProto.prototype.number = 0;

              /**
               * EnumValueDescriptorProto options.
               * @member {google.protobuf.IEnumValueOptions|null|undefined} options
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @instance
               */
              EnumValueDescriptorProto.prototype.options = null;

              /**
               * Creates a new EnumValueDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
               */
              EnumValueDescriptorProto.create = function create(properties) {
                  return new EnumValueDescriptorProto(properties);
              };

              /**
               * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumValueDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.number != null && message.hasOwnProperty("number"))
                      writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumValueDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          message.number = reader.int32();
                          break;
                      case 3:
                          message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an EnumValueDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              EnumValueDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.number != null && message.hasOwnProperty("number"))
                      if (!$util.isInteger(message.number))
                          return "number: integer expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
               */
              EnumValueDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.EnumValueDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.number != null)
                      message.number = object.number | 0;
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @static
               * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              EnumValueDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.name = "";
                      object.number = 0;
                      object.options = null;
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.number != null && message.hasOwnProperty("number"))
                      object.number = message.number;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this EnumValueDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.EnumValueDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return EnumValueDescriptorProto;
          })();

          protobuf.ServiceDescriptorProto = (function() {

              /**
               * Properties of a ServiceDescriptorProto.
               * @memberof google.protobuf
               * @interface IServiceDescriptorProto
               * @property {string|null} [name] ServiceDescriptorProto name
               * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
               * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
               */

              /**
               * Constructs a new ServiceDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents a ServiceDescriptorProto.
               * @implements IServiceDescriptorProto
               * @constructor
               * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
               */
              function ServiceDescriptorProto(properties) {
                  this.method = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ServiceDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.ServiceDescriptorProto
               * @instance
               */
              ServiceDescriptorProto.prototype.name = "";

              /**
               * ServiceDescriptorProto method.
               * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
               * @memberof google.protobuf.ServiceDescriptorProto
               * @instance
               */
              ServiceDescriptorProto.prototype.method = $util.emptyArray;

              /**
               * ServiceDescriptorProto options.
               * @member {google.protobuf.IServiceOptions|null|undefined} options
               * @memberof google.protobuf.ServiceDescriptorProto
               * @instance
               */
              ServiceDescriptorProto.prototype.options = null;

              /**
               * Creates a new ServiceDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
               */
              ServiceDescriptorProto.create = function create(properties) {
                  return new ServiceDescriptorProto(properties);
              };

              /**
               * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ServiceDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.method != null && message.method.length)
                      for (var i = 0; i < message.method.length; ++i)
                          $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ServiceDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          if (!(message.method && message.method.length))
                              message.method = [];
                          message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                          break;
                      case 3:
                          message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ServiceDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ServiceDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.method != null && message.hasOwnProperty("method")) {
                      if (!Array.isArray(message.method))
                          return "method: array expected";
                      for (var i = 0; i < message.method.length; ++i) {
                          var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                          if (error)
                              return "method." + error;
                      }
                  }
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  return null;
              };

              /**
               * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
               */
              ServiceDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.ServiceDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.method) {
                      if (!Array.isArray(object.method))
                          throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                      message.method = [];
                      for (var i = 0; i < object.method.length; ++i) {
                          if (typeof object.method[i] !== "object")
                              throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                          message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                      }
                  }
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.ServiceDescriptorProto
               * @static
               * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ServiceDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.method = [];
                  if (options.defaults) {
                      object.name = "";
                      object.options = null;
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.method && message.method.length) {
                      object.method = [];
                      for (var j = 0; j < message.method.length; ++j)
                          object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                  }
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                  return object;
              };

              /**
               * Converts this ServiceDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.ServiceDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ServiceDescriptorProto;
          })();

          protobuf.MethodDescriptorProto = (function() {

              /**
               * Properties of a MethodDescriptorProto.
               * @memberof google.protobuf
               * @interface IMethodDescriptorProto
               * @property {string|null} [name] MethodDescriptorProto name
               * @property {string|null} [input_type] MethodDescriptorProto input_type
               * @property {string|null} [output_type] MethodDescriptorProto output_type
               * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
               * @property {boolean|null} [client_streaming] MethodDescriptorProto client_streaming
               * @property {boolean|null} [server_streaming] MethodDescriptorProto server_streaming
               */

              /**
               * Constructs a new MethodDescriptorProto.
               * @memberof google.protobuf
               * @classdesc Represents a MethodDescriptorProto.
               * @implements IMethodDescriptorProto
               * @constructor
               * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
               */
              function MethodDescriptorProto(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * MethodDescriptorProto name.
               * @member {string} name
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               */
              MethodDescriptorProto.prototype.name = "";

              /**
               * MethodDescriptorProto input_type.
               * @member {string} input_type
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               */
              MethodDescriptorProto.prototype.input_type = "";

              /**
               * MethodDescriptorProto output_type.
               * @member {string} output_type
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               */
              MethodDescriptorProto.prototype.output_type = "";

              /**
               * MethodDescriptorProto options.
               * @member {google.protobuf.IMethodOptions|null|undefined} options
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               */
              MethodDescriptorProto.prototype.options = null;

              /**
               * MethodDescriptorProto client_streaming.
               * @member {boolean} client_streaming
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               */
              MethodDescriptorProto.prototype.client_streaming = false;

              /**
               * MethodDescriptorProto server_streaming.
               * @member {boolean} server_streaming
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               */
              MethodDescriptorProto.prototype.server_streaming = false;

              /**
               * Creates a new MethodDescriptorProto instance using the specified properties.
               * @function create
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
               * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
               */
              MethodDescriptorProto.create = function create(properties) {
                  return new MethodDescriptorProto(properties);
              };

              /**
               * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MethodDescriptorProto.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.hasOwnProperty("name"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                  if (message.input_type != null && message.hasOwnProperty("input_type"))
                      writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                  if (message.output_type != null && message.hasOwnProperty("output_type"))
                      writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                  if (message.options != null && message.hasOwnProperty("options"))
                      $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                  if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                      writer.uint32(/* id 5, wireType 0 =*/40).bool(message.client_streaming);
                  if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                      writer.uint32(/* id 6, wireType 0 =*/48).bool(message.server_streaming);
                  return writer;
              };

              /**
               * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a MethodDescriptorProto message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MethodDescriptorProto.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.name = reader.string();
                          break;
                      case 2:
                          message.input_type = reader.string();
                          break;
                      case 3:
                          message.output_type = reader.string();
                          break;
                      case 4:
                          message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                          break;
                      case 5:
                          message.client_streaming = reader.bool();
                          break;
                      case 6:
                          message.server_streaming = reader.bool();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a MethodDescriptorProto message.
               * @function verify
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              MethodDescriptorProto.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name"))
                      if (!$util.isString(message.name))
                          return "name: string expected";
                  if (message.input_type != null && message.hasOwnProperty("input_type"))
                      if (!$util.isString(message.input_type))
                          return "input_type: string expected";
                  if (message.output_type != null && message.hasOwnProperty("output_type"))
                      if (!$util.isString(message.output_type))
                          return "output_type: string expected";
                  if (message.options != null && message.hasOwnProperty("options")) {
                      var error = $root.google.protobuf.MethodOptions.verify(message.options);
                      if (error)
                          return "options." + error;
                  }
                  if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                      if (typeof message.client_streaming !== "boolean")
                          return "client_streaming: boolean expected";
                  if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                      if (typeof message.server_streaming !== "boolean")
                          return "server_streaming: boolean expected";
                  return null;
              };

              /**
               * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
               */
              MethodDescriptorProto.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                      return object;
                  var message = new $root.google.protobuf.MethodDescriptorProto();
                  if (object.name != null)
                      message.name = String(object.name);
                  if (object.input_type != null)
                      message.input_type = String(object.input_type);
                  if (object.output_type != null)
                      message.output_type = String(object.output_type);
                  if (object.options != null) {
                      if (typeof object.options !== "object")
                          throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                      message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                  }
                  if (object.client_streaming != null)
                      message.client_streaming = Boolean(object.client_streaming);
                  if (object.server_streaming != null)
                      message.server_streaming = Boolean(object.server_streaming);
                  return message;
              };

              /**
               * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.MethodDescriptorProto
               * @static
               * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              MethodDescriptorProto.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.name = "";
                      object.input_type = "";
                      object.output_type = "";
                      object.options = null;
                      object.client_streaming = false;
                      object.server_streaming = false;
                  }
                  if (message.name != null && message.hasOwnProperty("name"))
                      object.name = message.name;
                  if (message.input_type != null && message.hasOwnProperty("input_type"))
                      object.input_type = message.input_type;
                  if (message.output_type != null && message.hasOwnProperty("output_type"))
                      object.output_type = message.output_type;
                  if (message.options != null && message.hasOwnProperty("options"))
                      object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                  if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                      object.client_streaming = message.client_streaming;
                  if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                      object.server_streaming = message.server_streaming;
                  return object;
              };

              /**
               * Converts this MethodDescriptorProto to JSON.
               * @function toJSON
               * @memberof google.protobuf.MethodDescriptorProto
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              MethodDescriptorProto.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return MethodDescriptorProto;
          })();

          protobuf.FileOptions = (function() {

              /**
               * Properties of a FileOptions.
               * @memberof google.protobuf
               * @interface IFileOptions
               * @property {string|null} [java_package] FileOptions java_package
               * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
               * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
               * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
               * @property {boolean|null} [java_string_check_utf8] FileOptions java_string_check_utf8
               * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
               * @property {string|null} [go_package] FileOptions go_package
               * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
               * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
               * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
               * @property {boolean|null} [deprecated] FileOptions deprecated
               * @property {boolean|null} [cc_enable_arenas] FileOptions cc_enable_arenas
               * @property {string|null} [objc_class_prefix] FileOptions objc_class_prefix
               * @property {string|null} [csharp_namespace] FileOptions csharp_namespace
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
               * @property {scalapb.IScalaPbOptions|null} [".scalapb.options"] FileOptions .scalapb.options
               */

              /**
               * Constructs a new FileOptions.
               * @memberof google.protobuf
               * @classdesc Represents a FileOptions.
               * @implements IFileOptions
               * @constructor
               * @param {google.protobuf.IFileOptions=} [properties] Properties to set
               */
              function FileOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * FileOptions java_package.
               * @member {string} java_package
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.java_package = "";

              /**
               * FileOptions java_outer_classname.
               * @member {string} java_outer_classname
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.java_outer_classname = "";

              /**
               * FileOptions java_multiple_files.
               * @member {boolean} java_multiple_files
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.java_multiple_files = false;

              /**
               * FileOptions java_generate_equals_and_hash.
               * @member {boolean} java_generate_equals_and_hash
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.java_generate_equals_and_hash = false;

              /**
               * FileOptions java_string_check_utf8.
               * @member {boolean} java_string_check_utf8
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.java_string_check_utf8 = false;

              /**
               * FileOptions optimize_for.
               * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.optimize_for = 1;

              /**
               * FileOptions go_package.
               * @member {string} go_package
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.go_package = "";

              /**
               * FileOptions cc_generic_services.
               * @member {boolean} cc_generic_services
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.cc_generic_services = false;

              /**
               * FileOptions java_generic_services.
               * @member {boolean} java_generic_services
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.java_generic_services = false;

              /**
               * FileOptions py_generic_services.
               * @member {boolean} py_generic_services
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.py_generic_services = false;

              /**
               * FileOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.deprecated = false;

              /**
               * FileOptions cc_enable_arenas.
               * @member {boolean} cc_enable_arenas
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.cc_enable_arenas = false;

              /**
               * FileOptions objc_class_prefix.
               * @member {string} objc_class_prefix
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.objc_class_prefix = "";

              /**
               * FileOptions csharp_namespace.
               * @member {string} csharp_namespace
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.csharp_namespace = "";

              /**
               * FileOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * FileOptions .scalapb.options.
               * @member {scalapb.IScalaPbOptions|null|undefined} .scalapb.options
               * @memberof google.protobuf.FileOptions
               * @instance
               */
              FileOptions.prototype[".scalapb.options"] = null;

              /**
               * Creates a new FileOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {google.protobuf.IFileOptions=} [properties] Properties to set
               * @returns {google.protobuf.FileOptions} FileOptions instance
               */
              FileOptions.create = function create(properties) {
                  return new FileOptions(properties);
              };

              /**
               * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FileOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.java_package != null && message.hasOwnProperty("java_package"))
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                  if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                      writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                  if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                      writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                  if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                      writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                  if (message.go_package != null && message.hasOwnProperty("go_package"))
                      writer.uint32(/* id 11, wireType 2 =*/90).string(message.go_package);
                  if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                      writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                  if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                      writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                  if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                      writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                  if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                      writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                  if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                      writer.uint32(/* id 27, wireType 0 =*/216).bool(message.java_string_check_utf8);
                  if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                      writer.uint32(/* id 31, wireType 0 =*/248).bool(message.cc_enable_arenas);
                  if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                      writer.uint32(/* id 36, wireType 2 =*/290).string(message.objc_class_prefix);
                  if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                      writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharp_namespace);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  if (message[".scalapb.options"] != null && message.hasOwnProperty(".scalapb.options"))
                      $root.scalapb.ScalaPbOptions.encode(message[".scalapb.options"], writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a FileOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.FileOptions} FileOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FileOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.java_package = reader.string();
                          break;
                      case 8:
                          message.java_outer_classname = reader.string();
                          break;
                      case 10:
                          message.java_multiple_files = reader.bool();
                          break;
                      case 20:
                          message.java_generate_equals_and_hash = reader.bool();
                          break;
                      case 27:
                          message.java_string_check_utf8 = reader.bool();
                          break;
                      case 9:
                          message.optimize_for = reader.int32();
                          break;
                      case 11:
                          message.go_package = reader.string();
                          break;
                      case 16:
                          message.cc_generic_services = reader.bool();
                          break;
                      case 17:
                          message.java_generic_services = reader.bool();
                          break;
                      case 18:
                          message.py_generic_services = reader.bool();
                          break;
                      case 23:
                          message.deprecated = reader.bool();
                          break;
                      case 31:
                          message.cc_enable_arenas = reader.bool();
                          break;
                      case 36:
                          message.objc_class_prefix = reader.string();
                          break;
                      case 37:
                          message.csharp_namespace = reader.string();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      case 1020:
                          message[".scalapb.options"] = $root.scalapb.ScalaPbOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a FileOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.FileOptions} FileOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FileOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a FileOptions message.
               * @function verify
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              FileOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.java_package != null && message.hasOwnProperty("java_package"))
                      if (!$util.isString(message.java_package))
                          return "java_package: string expected";
                  if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                      if (!$util.isString(message.java_outer_classname))
                          return "java_outer_classname: string expected";
                  if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                      if (typeof message.java_multiple_files !== "boolean")
                          return "java_multiple_files: boolean expected";
                  if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                      if (typeof message.java_generate_equals_and_hash !== "boolean")
                          return "java_generate_equals_and_hash: boolean expected";
                  if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                      if (typeof message.java_string_check_utf8 !== "boolean")
                          return "java_string_check_utf8: boolean expected";
                  if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                      switch (message.optimize_for) {
                      default:
                          return "optimize_for: enum value expected";
                      case 1:
                      case 2:
                      case 3:
                          break;
                      }
                  if (message.go_package != null && message.hasOwnProperty("go_package"))
                      if (!$util.isString(message.go_package))
                          return "go_package: string expected";
                  if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                      if (typeof message.cc_generic_services !== "boolean")
                          return "cc_generic_services: boolean expected";
                  if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                      if (typeof message.java_generic_services !== "boolean")
                          return "java_generic_services: boolean expected";
                  if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                      if (typeof message.py_generic_services !== "boolean")
                          return "py_generic_services: boolean expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                      if (typeof message.cc_enable_arenas !== "boolean")
                          return "cc_enable_arenas: boolean expected";
                  if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                      if (!$util.isString(message.objc_class_prefix))
                          return "objc_class_prefix: string expected";
                  if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                      if (!$util.isString(message.csharp_namespace))
                          return "csharp_namespace: string expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  if (message[".scalapb.options"] != null && message.hasOwnProperty(".scalapb.options")) {
                      var error = $root.scalapb.ScalaPbOptions.verify(message[".scalapb.options"]);
                      if (error)
                          return ".scalapb.options." + error;
                  }
                  return null;
              };

              /**
               * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.FileOptions} FileOptions
               */
              FileOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.FileOptions)
                      return object;
                  var message = new $root.google.protobuf.FileOptions();
                  if (object.java_package != null)
                      message.java_package = String(object.java_package);
                  if (object.java_outer_classname != null)
                      message.java_outer_classname = String(object.java_outer_classname);
                  if (object.java_multiple_files != null)
                      message.java_multiple_files = Boolean(object.java_multiple_files);
                  if (object.java_generate_equals_and_hash != null)
                      message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                  if (object.java_string_check_utf8 != null)
                      message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
                  switch (object.optimize_for) {
                  case "SPEED":
                  case 1:
                      message.optimize_for = 1;
                      break;
                  case "CODE_SIZE":
                  case 2:
                      message.optimize_for = 2;
                      break;
                  case "LITE_RUNTIME":
                  case 3:
                      message.optimize_for = 3;
                      break;
                  }
                  if (object.go_package != null)
                      message.go_package = String(object.go_package);
                  if (object.cc_generic_services != null)
                      message.cc_generic_services = Boolean(object.cc_generic_services);
                  if (object.java_generic_services != null)
                      message.java_generic_services = Boolean(object.java_generic_services);
                  if (object.py_generic_services != null)
                      message.py_generic_services = Boolean(object.py_generic_services);
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.cc_enable_arenas != null)
                      message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
                  if (object.objc_class_prefix != null)
                      message.objc_class_prefix = String(object.objc_class_prefix);
                  if (object.csharp_namespace != null)
                      message.csharp_namespace = String(object.csharp_namespace);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  if (object[".scalapb.options"] != null) {
                      if (typeof object[".scalapb.options"] !== "object")
                          throw TypeError(".google.protobuf.FileOptions..scalapb.options: object expected");
                      message[".scalapb.options"] = $root.scalapb.ScalaPbOptions.fromObject(object[".scalapb.options"]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.FileOptions
               * @static
               * @param {google.protobuf.FileOptions} message FileOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              FileOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults) {
                      object.java_package = "";
                      object.java_outer_classname = "";
                      object.optimize_for = options.enums === String ? "SPEED" : 1;
                      object.java_multiple_files = false;
                      object.go_package = "";
                      object.cc_generic_services = false;
                      object.java_generic_services = false;
                      object.py_generic_services = false;
                      object.java_generate_equals_and_hash = false;
                      object.deprecated = false;
                      object.java_string_check_utf8 = false;
                      object.cc_enable_arenas = false;
                      object.objc_class_prefix = "";
                      object.csharp_namespace = "";
                      object[".scalapb.options"] = null;
                  }
                  if (message.java_package != null && message.hasOwnProperty("java_package"))
                      object.java_package = message.java_package;
                  if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                      object.java_outer_classname = message.java_outer_classname;
                  if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                      object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                  if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                      object.java_multiple_files = message.java_multiple_files;
                  if (message.go_package != null && message.hasOwnProperty("go_package"))
                      object.go_package = message.go_package;
                  if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                      object.cc_generic_services = message.cc_generic_services;
                  if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                      object.java_generic_services = message.java_generic_services;
                  if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                      object.py_generic_services = message.py_generic_services;
                  if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                      object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                      object.java_string_check_utf8 = message.java_string_check_utf8;
                  if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                      object.cc_enable_arenas = message.cc_enable_arenas;
                  if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                      object.objc_class_prefix = message.objc_class_prefix;
                  if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                      object.csharp_namespace = message.csharp_namespace;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  if (message[".scalapb.options"] != null && message.hasOwnProperty(".scalapb.options"))
                      object[".scalapb.options"] = $root.scalapb.ScalaPbOptions.toObject(message[".scalapb.options"], options);
                  return object;
              };

              /**
               * Converts this FileOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.FileOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              FileOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              /**
               * OptimizeMode enum.
               * @name google.protobuf.FileOptions.OptimizeMode
               * @enum {string}
               * @property {number} SPEED=1 SPEED value
               * @property {number} CODE_SIZE=2 CODE_SIZE value
               * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
               */
              FileOptions.OptimizeMode = (function() {
                  var valuesById = {}, values = Object.create(valuesById);
                  values[valuesById[1] = "SPEED"] = 1;
                  values[valuesById[2] = "CODE_SIZE"] = 2;
                  values[valuesById[3] = "LITE_RUNTIME"] = 3;
                  return values;
              })();

              return FileOptions;
          })();

          protobuf.MessageOptions = (function() {

              /**
               * Properties of a MessageOptions.
               * @memberof google.protobuf
               * @interface IMessageOptions
               * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
               * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
               * @property {boolean|null} [deprecated] MessageOptions deprecated
               * @property {boolean|null} [map_entry] MessageOptions map_entry
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
               * @property {scalapb.IMessageOptions|null} [".scalapb.message"] MessageOptions .scalapb.message
               */

              /**
               * Constructs a new MessageOptions.
               * @memberof google.protobuf
               * @classdesc Represents a MessageOptions.
               * @implements IMessageOptions
               * @constructor
               * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
               */
              function MessageOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * MessageOptions message_set_wire_format.
               * @member {boolean} message_set_wire_format
               * @memberof google.protobuf.MessageOptions
               * @instance
               */
              MessageOptions.prototype.message_set_wire_format = false;

              /**
               * MessageOptions no_standard_descriptor_accessor.
               * @member {boolean} no_standard_descriptor_accessor
               * @memberof google.protobuf.MessageOptions
               * @instance
               */
              MessageOptions.prototype.no_standard_descriptor_accessor = false;

              /**
               * MessageOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.MessageOptions
               * @instance
               */
              MessageOptions.prototype.deprecated = false;

              /**
               * MessageOptions map_entry.
               * @member {boolean} map_entry
               * @memberof google.protobuf.MessageOptions
               * @instance
               */
              MessageOptions.prototype.map_entry = false;

              /**
               * MessageOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.MessageOptions
               * @instance
               */
              MessageOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * MessageOptions .scalapb.message.
               * @member {scalapb.IMessageOptions|null|undefined} .scalapb.message
               * @memberof google.protobuf.MessageOptions
               * @instance
               */
              MessageOptions.prototype[".scalapb.message"] = null;

              /**
               * Creates a new MessageOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
               * @returns {google.protobuf.MessageOptions} MessageOptions instance
               */
              MessageOptions.create = function create(properties) {
                  return new MessageOptions(properties);
              };

              /**
               * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MessageOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                      writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                  if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                      writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                  if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                      writer.uint32(/* id 7, wireType 0 =*/56).bool(message.map_entry);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  if (message[".scalapb.message"] != null && message.hasOwnProperty(".scalapb.message"))
                      $root.scalapb.MessageOptions.encode(message[".scalapb.message"], writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a MessageOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.MessageOptions} MessageOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MessageOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.message_set_wire_format = reader.bool();
                          break;
                      case 2:
                          message.no_standard_descriptor_accessor = reader.bool();
                          break;
                      case 3:
                          message.deprecated = reader.bool();
                          break;
                      case 7:
                          message.map_entry = reader.bool();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      case 1020:
                          message[".scalapb.message"] = $root.scalapb.MessageOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.MessageOptions} MessageOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a MessageOptions message.
               * @function verify
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              MessageOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                      if (typeof message.message_set_wire_format !== "boolean")
                          return "message_set_wire_format: boolean expected";
                  if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                      if (typeof message.no_standard_descriptor_accessor !== "boolean")
                          return "no_standard_descriptor_accessor: boolean expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                      if (typeof message.map_entry !== "boolean")
                          return "map_entry: boolean expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  if (message[".scalapb.message"] != null && message.hasOwnProperty(".scalapb.message")) {
                      var error = $root.scalapb.MessageOptions.verify(message[".scalapb.message"]);
                      if (error)
                          return ".scalapb.message." + error;
                  }
                  return null;
              };

              /**
               * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.MessageOptions} MessageOptions
               */
              MessageOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.MessageOptions)
                      return object;
                  var message = new $root.google.protobuf.MessageOptions();
                  if (object.message_set_wire_format != null)
                      message.message_set_wire_format = Boolean(object.message_set_wire_format);
                  if (object.no_standard_descriptor_accessor != null)
                      message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.map_entry != null)
                      message.map_entry = Boolean(object.map_entry);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  if (object[".scalapb.message"] != null) {
                      if (typeof object[".scalapb.message"] !== "object")
                          throw TypeError(".google.protobuf.MessageOptions..scalapb.message: object expected");
                      message[".scalapb.message"] = $root.scalapb.MessageOptions.fromObject(object[".scalapb.message"]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.MessageOptions
               * @static
               * @param {google.protobuf.MessageOptions} message MessageOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              MessageOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults) {
                      object.message_set_wire_format = false;
                      object.no_standard_descriptor_accessor = false;
                      object.deprecated = false;
                      object.map_entry = false;
                      object[".scalapb.message"] = null;
                  }
                  if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                      object.message_set_wire_format = message.message_set_wire_format;
                  if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                      object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                      object.map_entry = message.map_entry;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  if (message[".scalapb.message"] != null && message.hasOwnProperty(".scalapb.message"))
                      object[".scalapb.message"] = $root.scalapb.MessageOptions.toObject(message[".scalapb.message"], options);
                  return object;
              };

              /**
               * Converts this MessageOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.MessageOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              MessageOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return MessageOptions;
          })();

          protobuf.FieldOptions = (function() {

              /**
               * Properties of a FieldOptions.
               * @memberof google.protobuf
               * @interface IFieldOptions
               * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
               * @property {boolean|null} [packed] FieldOptions packed
               * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
               * @property {boolean|null} [lazy] FieldOptions lazy
               * @property {boolean|null} [deprecated] FieldOptions deprecated
               * @property {boolean|null} [weak] FieldOptions weak
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
               * @property {scalapb.IFieldOptions|null} [".scalapb.field"] FieldOptions .scalapb.field
               */

              /**
               * Constructs a new FieldOptions.
               * @memberof google.protobuf
               * @classdesc Represents a FieldOptions.
               * @implements IFieldOptions
               * @constructor
               * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
               */
              function FieldOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * FieldOptions ctype.
               * @member {google.protobuf.FieldOptions.CType} ctype
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.ctype = 0;

              /**
               * FieldOptions packed.
               * @member {boolean} packed
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.packed = false;

              /**
               * FieldOptions jstype.
               * @member {google.protobuf.FieldOptions.JSType} jstype
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.jstype = 0;

              /**
               * FieldOptions lazy.
               * @member {boolean} lazy
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.lazy = false;

              /**
               * FieldOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.deprecated = false;

              /**
               * FieldOptions weak.
               * @member {boolean} weak
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.weak = false;

              /**
               * FieldOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * FieldOptions .scalapb.field.
               * @member {scalapb.IFieldOptions|null|undefined} .scalapb.field
               * @memberof google.protobuf.FieldOptions
               * @instance
               */
              FieldOptions.prototype[".scalapb.field"] = null;

              /**
               * Creates a new FieldOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
               * @returns {google.protobuf.FieldOptions} FieldOptions instance
               */
              FieldOptions.create = function create(properties) {
                  return new FieldOptions(properties);
              };

              /**
               * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FieldOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.ctype != null && message.hasOwnProperty("ctype"))
                      writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                  if (message.packed != null && message.hasOwnProperty("packed"))
                      writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                  if (message.lazy != null && message.hasOwnProperty("lazy"))
                      writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                  if (message.jstype != null && message.hasOwnProperty("jstype"))
                      writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                  if (message.weak != null && message.hasOwnProperty("weak"))
                      writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  if (message[".scalapb.field"] != null && message.hasOwnProperty(".scalapb.field"))
                      $root.scalapb.FieldOptions.encode(message[".scalapb.field"], writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a FieldOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.FieldOptions} FieldOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FieldOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.ctype = reader.int32();
                          break;
                      case 2:
                          message.packed = reader.bool();
                          break;
                      case 6:
                          message.jstype = reader.int32();
                          break;
                      case 5:
                          message.lazy = reader.bool();
                          break;
                      case 3:
                          message.deprecated = reader.bool();
                          break;
                      case 10:
                          message.weak = reader.bool();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      case 1020:
                          message[".scalapb.field"] = $root.scalapb.FieldOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.FieldOptions} FieldOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a FieldOptions message.
               * @function verify
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              FieldOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.ctype != null && message.hasOwnProperty("ctype"))
                      switch (message.ctype) {
                      default:
                          return "ctype: enum value expected";
                      case 0:
                      case 1:
                      case 2:
                          break;
                      }
                  if (message.packed != null && message.hasOwnProperty("packed"))
                      if (typeof message.packed !== "boolean")
                          return "packed: boolean expected";
                  if (message.jstype != null && message.hasOwnProperty("jstype"))
                      switch (message.jstype) {
                      default:
                          return "jstype: enum value expected";
                      case 0:
                      case 1:
                      case 2:
                          break;
                      }
                  if (message.lazy != null && message.hasOwnProperty("lazy"))
                      if (typeof message.lazy !== "boolean")
                          return "lazy: boolean expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.weak != null && message.hasOwnProperty("weak"))
                      if (typeof message.weak !== "boolean")
                          return "weak: boolean expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  if (message[".scalapb.field"] != null && message.hasOwnProperty(".scalapb.field")) {
                      var error = $root.scalapb.FieldOptions.verify(message[".scalapb.field"]);
                      if (error)
                          return ".scalapb.field." + error;
                  }
                  return null;
              };

              /**
               * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.FieldOptions} FieldOptions
               */
              FieldOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.FieldOptions)
                      return object;
                  var message = new $root.google.protobuf.FieldOptions();
                  switch (object.ctype) {
                  case "STRING":
                  case 0:
                      message.ctype = 0;
                      break;
                  case "CORD":
                  case 1:
                      message.ctype = 1;
                      break;
                  case "STRING_PIECE":
                  case 2:
                      message.ctype = 2;
                      break;
                  }
                  if (object.packed != null)
                      message.packed = Boolean(object.packed);
                  switch (object.jstype) {
                  case "JS_NORMAL":
                  case 0:
                      message.jstype = 0;
                      break;
                  case "JS_STRING":
                  case 1:
                      message.jstype = 1;
                      break;
                  case "JS_NUMBER":
                  case 2:
                      message.jstype = 2;
                      break;
                  }
                  if (object.lazy != null)
                      message.lazy = Boolean(object.lazy);
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.weak != null)
                      message.weak = Boolean(object.weak);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  if (object[".scalapb.field"] != null) {
                      if (typeof object[".scalapb.field"] !== "object")
                          throw TypeError(".google.protobuf.FieldOptions..scalapb.field: object expected");
                      message[".scalapb.field"] = $root.scalapb.FieldOptions.fromObject(object[".scalapb.field"]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.FieldOptions
               * @static
               * @param {google.protobuf.FieldOptions} message FieldOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              FieldOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults) {
                      object.ctype = options.enums === String ? "STRING" : 0;
                      object.packed = false;
                      object.deprecated = false;
                      object.lazy = false;
                      object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                      object.weak = false;
                      object[".scalapb.field"] = null;
                  }
                  if (message.ctype != null && message.hasOwnProperty("ctype"))
                      object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                  if (message.packed != null && message.hasOwnProperty("packed"))
                      object.packed = message.packed;
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.lazy != null && message.hasOwnProperty("lazy"))
                      object.lazy = message.lazy;
                  if (message.jstype != null && message.hasOwnProperty("jstype"))
                      object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                  if (message.weak != null && message.hasOwnProperty("weak"))
                      object.weak = message.weak;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  if (message[".scalapb.field"] != null && message.hasOwnProperty(".scalapb.field"))
                      object[".scalapb.field"] = $root.scalapb.FieldOptions.toObject(message[".scalapb.field"], options);
                  return object;
              };

              /**
               * Converts this FieldOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.FieldOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              FieldOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              /**
               * CType enum.
               * @name google.protobuf.FieldOptions.CType
               * @enum {string}
               * @property {number} STRING=0 STRING value
               * @property {number} CORD=1 CORD value
               * @property {number} STRING_PIECE=2 STRING_PIECE value
               */
              FieldOptions.CType = (function() {
                  var valuesById = {}, values = Object.create(valuesById);
                  values[valuesById[0] = "STRING"] = 0;
                  values[valuesById[1] = "CORD"] = 1;
                  values[valuesById[2] = "STRING_PIECE"] = 2;
                  return values;
              })();

              /**
               * JSType enum.
               * @name google.protobuf.FieldOptions.JSType
               * @enum {string}
               * @property {number} JS_NORMAL=0 JS_NORMAL value
               * @property {number} JS_STRING=1 JS_STRING value
               * @property {number} JS_NUMBER=2 JS_NUMBER value
               */
              FieldOptions.JSType = (function() {
                  var valuesById = {}, values = Object.create(valuesById);
                  values[valuesById[0] = "JS_NORMAL"] = 0;
                  values[valuesById[1] = "JS_STRING"] = 1;
                  values[valuesById[2] = "JS_NUMBER"] = 2;
                  return values;
              })();

              return FieldOptions;
          })();

          protobuf.OneofOptions = (function() {

              /**
               * Properties of an OneofOptions.
               * @memberof google.protobuf
               * @interface IOneofOptions
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] OneofOptions uninterpreted_option
               * @property {scalapb.IOneofOptions|null} [".scalapb.oneof"] OneofOptions .scalapb.oneof
               */

              /**
               * Constructs a new OneofOptions.
               * @memberof google.protobuf
               * @classdesc Represents an OneofOptions.
               * @implements IOneofOptions
               * @constructor
               * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
               */
              function OneofOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * OneofOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.OneofOptions
               * @instance
               */
              OneofOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * OneofOptions .scalapb.oneof.
               * @member {scalapb.IOneofOptions|null|undefined} .scalapb.oneof
               * @memberof google.protobuf.OneofOptions
               * @instance
               */
              OneofOptions.prototype[".scalapb.oneof"] = null;

              /**
               * Creates a new OneofOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
               * @returns {google.protobuf.OneofOptions} OneofOptions instance
               */
              OneofOptions.create = function create(properties) {
                  return new OneofOptions(properties);
              };

              /**
               * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              OneofOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  if (message[".scalapb.oneof"] != null && message.hasOwnProperty(".scalapb.oneof"))
                      $root.scalapb.OneofOptions.encode(message[".scalapb.oneof"], writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an OneofOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.OneofOptions} OneofOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              OneofOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      case 1020:
                          message[".scalapb.oneof"] = $root.scalapb.OneofOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.OneofOptions} OneofOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an OneofOptions message.
               * @function verify
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              OneofOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  if (message[".scalapb.oneof"] != null && message.hasOwnProperty(".scalapb.oneof")) {
                      var error = $root.scalapb.OneofOptions.verify(message[".scalapb.oneof"]);
                      if (error)
                          return ".scalapb.oneof." + error;
                  }
                  return null;
              };

              /**
               * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.OneofOptions} OneofOptions
               */
              OneofOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.OneofOptions)
                      return object;
                  var message = new $root.google.protobuf.OneofOptions();
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  if (object[".scalapb.oneof"] != null) {
                      if (typeof object[".scalapb.oneof"] !== "object")
                          throw TypeError(".google.protobuf.OneofOptions..scalapb.oneof: object expected");
                      message[".scalapb.oneof"] = $root.scalapb.OneofOptions.fromObject(object[".scalapb.oneof"]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.OneofOptions
               * @static
               * @param {google.protobuf.OneofOptions} message OneofOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              OneofOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults)
                      object[".scalapb.oneof"] = null;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  if (message[".scalapb.oneof"] != null && message.hasOwnProperty(".scalapb.oneof"))
                      object[".scalapb.oneof"] = $root.scalapb.OneofOptions.toObject(message[".scalapb.oneof"], options);
                  return object;
              };

              /**
               * Converts this OneofOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.OneofOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              OneofOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return OneofOptions;
          })();

          protobuf.EnumOptions = (function() {

              /**
               * Properties of an EnumOptions.
               * @memberof google.protobuf
               * @interface IEnumOptions
               * @property {boolean|null} [allow_alias] EnumOptions allow_alias
               * @property {boolean|null} [deprecated] EnumOptions deprecated
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
               * @property {scalapb.IEnumOptions|null} [".scalapb.enum_options"] EnumOptions .scalapb.enum_options
               */

              /**
               * Constructs a new EnumOptions.
               * @memberof google.protobuf
               * @classdesc Represents an EnumOptions.
               * @implements IEnumOptions
               * @constructor
               * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
               */
              function EnumOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * EnumOptions allow_alias.
               * @member {boolean} allow_alias
               * @memberof google.protobuf.EnumOptions
               * @instance
               */
              EnumOptions.prototype.allow_alias = false;

              /**
               * EnumOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.EnumOptions
               * @instance
               */
              EnumOptions.prototype.deprecated = false;

              /**
               * EnumOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.EnumOptions
               * @instance
               */
              EnumOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * EnumOptions .scalapb.enum_options.
               * @member {scalapb.IEnumOptions|null|undefined} .scalapb.enum_options
               * @memberof google.protobuf.EnumOptions
               * @instance
               */
              EnumOptions.prototype[".scalapb.enum_options"] = null;

              /**
               * Creates a new EnumOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
               * @returns {google.protobuf.EnumOptions} EnumOptions instance
               */
              EnumOptions.create = function create(properties) {
                  return new EnumOptions(properties);
              };

              /**
               * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                      writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allow_alias);
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  if (message[".scalapb.enum_options"] != null && message.hasOwnProperty(".scalapb.enum_options"))
                      $root.scalapb.EnumOptions.encode(message[".scalapb.enum_options"], writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an EnumOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.EnumOptions} EnumOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 2:
                          message.allow_alias = reader.bool();
                          break;
                      case 3:
                          message.deprecated = reader.bool();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      case 1020:
                          message[".scalapb.enum_options"] = $root.scalapb.EnumOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.EnumOptions} EnumOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an EnumOptions message.
               * @function verify
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              EnumOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                      if (typeof message.allow_alias !== "boolean")
                          return "allow_alias: boolean expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  if (message[".scalapb.enum_options"] != null && message.hasOwnProperty(".scalapb.enum_options")) {
                      var error = $root.scalapb.EnumOptions.verify(message[".scalapb.enum_options"]);
                      if (error)
                          return ".scalapb.enum_options." + error;
                  }
                  return null;
              };

              /**
               * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.EnumOptions} EnumOptions
               */
              EnumOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.EnumOptions)
                      return object;
                  var message = new $root.google.protobuf.EnumOptions();
                  if (object.allow_alias != null)
                      message.allow_alias = Boolean(object.allow_alias);
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  if (object[".scalapb.enum_options"] != null) {
                      if (typeof object[".scalapb.enum_options"] !== "object")
                          throw TypeError(".google.protobuf.EnumOptions..scalapb.enum_options: object expected");
                      message[".scalapb.enum_options"] = $root.scalapb.EnumOptions.fromObject(object[".scalapb.enum_options"]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.EnumOptions
               * @static
               * @param {google.protobuf.EnumOptions} message EnumOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              EnumOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults) {
                      object.allow_alias = false;
                      object.deprecated = false;
                      object[".scalapb.enum_options"] = null;
                  }
                  if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                      object.allow_alias = message.allow_alias;
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  if (message[".scalapb.enum_options"] != null && message.hasOwnProperty(".scalapb.enum_options"))
                      object[".scalapb.enum_options"] = $root.scalapb.EnumOptions.toObject(message[".scalapb.enum_options"], options);
                  return object;
              };

              /**
               * Converts this EnumOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.EnumOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              EnumOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return EnumOptions;
          })();

          protobuf.EnumValueOptions = (function() {

              /**
               * Properties of an EnumValueOptions.
               * @memberof google.protobuf
               * @interface IEnumValueOptions
               * @property {boolean|null} [deprecated] EnumValueOptions deprecated
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
               * @property {scalapb.IEnumValueOptions|null} [".scalapb.enum_value"] EnumValueOptions .scalapb.enum_value
               */

              /**
               * Constructs a new EnumValueOptions.
               * @memberof google.protobuf
               * @classdesc Represents an EnumValueOptions.
               * @implements IEnumValueOptions
               * @constructor
               * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
               */
              function EnumValueOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * EnumValueOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.EnumValueOptions
               * @instance
               */
              EnumValueOptions.prototype.deprecated = false;

              /**
               * EnumValueOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.EnumValueOptions
               * @instance
               */
              EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * EnumValueOptions .scalapb.enum_value.
               * @member {scalapb.IEnumValueOptions|null|undefined} .scalapb.enum_value
               * @memberof google.protobuf.EnumValueOptions
               * @instance
               */
              EnumValueOptions.prototype[".scalapb.enum_value"] = null;

              /**
               * Creates a new EnumValueOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
               * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
               */
              EnumValueOptions.create = function create(properties) {
                  return new EnumValueOptions(properties);
              };

              /**
               * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumValueOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  if (message[".scalapb.enum_value"] != null && message.hasOwnProperty(".scalapb.enum_value"))
                      $root.scalapb.EnumValueOptions.encode(message[".scalapb.enum_value"], writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an EnumValueOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumValueOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.deprecated = reader.bool();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      case 1020:
                          message[".scalapb.enum_value"] = $root.scalapb.EnumValueOptions.decode(reader, reader.uint32());
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an EnumValueOptions message.
               * @function verify
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              EnumValueOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  if (message[".scalapb.enum_value"] != null && message.hasOwnProperty(".scalapb.enum_value")) {
                      var error = $root.scalapb.EnumValueOptions.verify(message[".scalapb.enum_value"]);
                      if (error)
                          return ".scalapb.enum_value." + error;
                  }
                  return null;
              };

              /**
               * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
               */
              EnumValueOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.EnumValueOptions)
                      return object;
                  var message = new $root.google.protobuf.EnumValueOptions();
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  if (object[".scalapb.enum_value"] != null) {
                      if (typeof object[".scalapb.enum_value"] !== "object")
                          throw TypeError(".google.protobuf.EnumValueOptions..scalapb.enum_value: object expected");
                      message[".scalapb.enum_value"] = $root.scalapb.EnumValueOptions.fromObject(object[".scalapb.enum_value"]);
                  }
                  return message;
              };

              /**
               * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.EnumValueOptions
               * @static
               * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              EnumValueOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults) {
                      object.deprecated = false;
                      object[".scalapb.enum_value"] = null;
                  }
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  if (message[".scalapb.enum_value"] != null && message.hasOwnProperty(".scalapb.enum_value"))
                      object[".scalapb.enum_value"] = $root.scalapb.EnumValueOptions.toObject(message[".scalapb.enum_value"], options);
                  return object;
              };

              /**
               * Converts this EnumValueOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.EnumValueOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              EnumValueOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return EnumValueOptions;
          })();

          protobuf.ServiceOptions = (function() {

              /**
               * Properties of a ServiceOptions.
               * @memberof google.protobuf
               * @interface IServiceOptions
               * @property {boolean|null} [deprecated] ServiceOptions deprecated
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
               */

              /**
               * Constructs a new ServiceOptions.
               * @memberof google.protobuf
               * @classdesc Represents a ServiceOptions.
               * @implements IServiceOptions
               * @constructor
               * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
               */
              function ServiceOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * ServiceOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.ServiceOptions
               * @instance
               */
              ServiceOptions.prototype.deprecated = false;

              /**
               * ServiceOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.ServiceOptions
               * @instance
               */
              ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * Creates a new ServiceOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
               * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
               */
              ServiceOptions.create = function create(properties) {
                  return new ServiceOptions(properties);
              };

              /**
               * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ServiceOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a ServiceOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.ServiceOptions} ServiceOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ServiceOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 33:
                          message.deprecated = reader.bool();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.ServiceOptions} ServiceOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a ServiceOptions message.
               * @function verify
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              ServiceOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.ServiceOptions} ServiceOptions
               */
              ServiceOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.ServiceOptions)
                      return object;
                  var message = new $root.google.protobuf.ServiceOptions();
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  return message;
              };

              /**
               * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.ServiceOptions
               * @static
               * @param {google.protobuf.ServiceOptions} message ServiceOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              ServiceOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults)
                      object.deprecated = false;
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  return object;
              };

              /**
               * Converts this ServiceOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.ServiceOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              ServiceOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return ServiceOptions;
          })();

          protobuf.MethodOptions = (function() {

              /**
               * Properties of a MethodOptions.
               * @memberof google.protobuf
               * @interface IMethodOptions
               * @property {boolean|null} [deprecated] MethodOptions deprecated
               * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
               */

              /**
               * Constructs a new MethodOptions.
               * @memberof google.protobuf
               * @classdesc Represents a MethodOptions.
               * @implements IMethodOptions
               * @constructor
               * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
               */
              function MethodOptions(properties) {
                  this.uninterpreted_option = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * MethodOptions deprecated.
               * @member {boolean} deprecated
               * @memberof google.protobuf.MethodOptions
               * @instance
               */
              MethodOptions.prototype.deprecated = false;

              /**
               * MethodOptions uninterpreted_option.
               * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
               * @memberof google.protobuf.MethodOptions
               * @instance
               */
              MethodOptions.prototype.uninterpreted_option = $util.emptyArray;

              /**
               * Creates a new MethodOptions instance using the specified properties.
               * @function create
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
               * @returns {google.protobuf.MethodOptions} MethodOptions instance
               */
              MethodOptions.create = function create(properties) {
                  return new MethodOptions(properties);
              };

              /**
               * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MethodOptions.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                  if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                      for (var i = 0; i < message.uninterpreted_option.length; ++i)
                          $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a MethodOptions message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.MethodOptions} MethodOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MethodOptions.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 33:
                          message.deprecated = reader.bool();
                          break;
                      case 999:
                          if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                              message.uninterpreted_option = [];
                          message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.MethodOptions} MethodOptions
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a MethodOptions message.
               * @function verify
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              MethodOptions.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      if (typeof message.deprecated !== "boolean")
                          return "deprecated: boolean expected";
                  if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                      if (!Array.isArray(message.uninterpreted_option))
                          return "uninterpreted_option: array expected";
                      for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                          if (error)
                              return "uninterpreted_option." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.MethodOptions} MethodOptions
               */
              MethodOptions.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.MethodOptions)
                      return object;
                  var message = new $root.google.protobuf.MethodOptions();
                  if (object.deprecated != null)
                      message.deprecated = Boolean(object.deprecated);
                  if (object.uninterpreted_option) {
                      if (!Array.isArray(object.uninterpreted_option))
                          throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                      message.uninterpreted_option = [];
                      for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                          if (typeof object.uninterpreted_option[i] !== "object")
                              throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                          message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                      }
                  }
                  return message;
              };

              /**
               * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.MethodOptions
               * @static
               * @param {google.protobuf.MethodOptions} message MethodOptions
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              MethodOptions.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.uninterpreted_option = [];
                  if (options.defaults)
                      object.deprecated = false;
                  if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                      object.deprecated = message.deprecated;
                  if (message.uninterpreted_option && message.uninterpreted_option.length) {
                      object.uninterpreted_option = [];
                      for (var j = 0; j < message.uninterpreted_option.length; ++j)
                          object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                  }
                  return object;
              };

              /**
               * Converts this MethodOptions to JSON.
               * @function toJSON
               * @memberof google.protobuf.MethodOptions
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              MethodOptions.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              return MethodOptions;
          })();

          protobuf.UninterpretedOption = (function() {

              /**
               * Properties of an UninterpretedOption.
               * @memberof google.protobuf
               * @interface IUninterpretedOption
               * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
               * @property {string|null} [identifier_value] UninterpretedOption identifier_value
               * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
               * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
               * @property {number|null} [double_value] UninterpretedOption double_value
               * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
               * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
               */

              /**
               * Constructs a new UninterpretedOption.
               * @memberof google.protobuf
               * @classdesc Represents an UninterpretedOption.
               * @implements IUninterpretedOption
               * @constructor
               * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
               */
              function UninterpretedOption(properties) {
                  this.name = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * UninterpretedOption name.
               * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.name = $util.emptyArray;

              /**
               * UninterpretedOption identifier_value.
               * @member {string} identifier_value
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.identifier_value = "";

              /**
               * UninterpretedOption positive_int_value.
               * @member {number|Long} positive_int_value
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

              /**
               * UninterpretedOption negative_int_value.
               * @member {number|Long} negative_int_value
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

              /**
               * UninterpretedOption double_value.
               * @member {number} double_value
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.double_value = 0;

              /**
               * UninterpretedOption string_value.
               * @member {Uint8Array} string_value
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.string_value = $util.newBuffer([]);

              /**
               * UninterpretedOption aggregate_value.
               * @member {string} aggregate_value
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               */
              UninterpretedOption.prototype.aggregate_value = "";

              /**
               * Creates a new UninterpretedOption instance using the specified properties.
               * @function create
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
               * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
               */
              UninterpretedOption.create = function create(properties) {
                  return new UninterpretedOption(properties);
              };

              /**
               * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              UninterpretedOption.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.name != null && message.name.length)
                      for (var i = 0; i < message.name.length; ++i)
                          $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                  if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                      writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                  if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                      writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                  if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                      writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                  if (message.double_value != null && message.hasOwnProperty("double_value"))
                      writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                  if (message.string_value != null && message.hasOwnProperty("string_value"))
                      writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                  if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                      writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                  return writer;
              };

              /**
               * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes an UninterpretedOption message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              UninterpretedOption.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 2:
                          if (!(message.name && message.name.length))
                              message.name = [];
                          message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                          break;
                      case 3:
                          message.identifier_value = reader.string();
                          break;
                      case 4:
                          message.positive_int_value = reader.uint64();
                          break;
                      case 5:
                          message.negative_int_value = reader.int64();
                          break;
                      case 6:
                          message.double_value = reader.double();
                          break;
                      case 7:
                          message.string_value = reader.bytes();
                          break;
                      case 8:
                          message.aggregate_value = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies an UninterpretedOption message.
               * @function verify
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              UninterpretedOption.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.name != null && message.hasOwnProperty("name")) {
                      if (!Array.isArray(message.name))
                          return "name: array expected";
                      for (var i = 0; i < message.name.length; ++i) {
                          var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                          if (error)
                              return "name." + error;
                      }
                  }
                  if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                      if (!$util.isString(message.identifier_value))
                          return "identifier_value: string expected";
                  if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                      if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                          return "positive_int_value: integer|Long expected";
                  if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                      if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                          return "negative_int_value: integer|Long expected";
                  if (message.double_value != null && message.hasOwnProperty("double_value"))
                      if (typeof message.double_value !== "number")
                          return "double_value: number expected";
                  if (message.string_value != null && message.hasOwnProperty("string_value"))
                      if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                          return "string_value: buffer expected";
                  if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                      if (!$util.isString(message.aggregate_value))
                          return "aggregate_value: string expected";
                  return null;
              };

              /**
               * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
               */
              UninterpretedOption.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.UninterpretedOption)
                      return object;
                  var message = new $root.google.protobuf.UninterpretedOption();
                  if (object.name) {
                      if (!Array.isArray(object.name))
                          throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                      message.name = [];
                      for (var i = 0; i < object.name.length; ++i) {
                          if (typeof object.name[i] !== "object")
                              throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                          message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                      }
                  }
                  if (object.identifier_value != null)
                      message.identifier_value = String(object.identifier_value);
                  if (object.positive_int_value != null)
                      if ($util.Long)
                          (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                      else if (typeof object.positive_int_value === "string")
                          message.positive_int_value = parseInt(object.positive_int_value, 10);
                      else if (typeof object.positive_int_value === "number")
                          message.positive_int_value = object.positive_int_value;
                      else if (typeof object.positive_int_value === "object")
                          message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                  if (object.negative_int_value != null)
                      if ($util.Long)
                          (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                      else if (typeof object.negative_int_value === "string")
                          message.negative_int_value = parseInt(object.negative_int_value, 10);
                      else if (typeof object.negative_int_value === "number")
                          message.negative_int_value = object.negative_int_value;
                      else if (typeof object.negative_int_value === "object")
                          message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                  if (object.double_value != null)
                      message.double_value = Number(object.double_value);
                  if (object.string_value != null)
                      if (typeof object.string_value === "string")
                          $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                      else if (object.string_value.length)
                          message.string_value = object.string_value;
                  if (object.aggregate_value != null)
                      message.aggregate_value = String(object.aggregate_value);
                  return message;
              };

              /**
               * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.UninterpretedOption
               * @static
               * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              UninterpretedOption.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.name = [];
                  if (options.defaults) {
                      object.identifier_value = "";
                      if ($util.Long) {
                          var long = new $util.Long(0, 0, true);
                          object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                      } else
                          object.positive_int_value = options.longs === String ? "0" : 0;
                      if ($util.Long) {
                          var long = new $util.Long(0, 0, false);
                          object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                      } else
                          object.negative_int_value = options.longs === String ? "0" : 0;
                      object.double_value = 0;
                      if (options.bytes === String)
                          object.string_value = "";
                      else {
                          object.string_value = [];
                          if (options.bytes !== Array)
                              object.string_value = $util.newBuffer(object.string_value);
                      }
                      object.aggregate_value = "";
                  }
                  if (message.name && message.name.length) {
                      object.name = [];
                      for (var j = 0; j < message.name.length; ++j)
                          object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                  }
                  if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                      object.identifier_value = message.identifier_value;
                  if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                      if (typeof message.positive_int_value === "number")
                          object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                      else
                          object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                  if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                      if (typeof message.negative_int_value === "number")
                          object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                      else
                          object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                  if (message.double_value != null && message.hasOwnProperty("double_value"))
                      object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                  if (message.string_value != null && message.hasOwnProperty("string_value"))
                      object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                  if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                      object.aggregate_value = message.aggregate_value;
                  return object;
              };

              /**
               * Converts this UninterpretedOption to JSON.
               * @function toJSON
               * @memberof google.protobuf.UninterpretedOption
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              UninterpretedOption.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              UninterpretedOption.NamePart = (function() {

                  /**
                   * Properties of a NamePart.
                   * @memberof google.protobuf.UninterpretedOption
                   * @interface INamePart
                   * @property {string} name_part NamePart name_part
                   * @property {boolean} is_extension NamePart is_extension
                   */

                  /**
                   * Constructs a new NamePart.
                   * @memberof google.protobuf.UninterpretedOption
                   * @classdesc Represents a NamePart.
                   * @implements INamePart
                   * @constructor
                   * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                   */
                  function NamePart(properties) {
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * NamePart name_part.
                   * @member {string} name_part
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @instance
                   */
                  NamePart.prototype.name_part = "";

                  /**
                   * NamePart is_extension.
                   * @member {boolean} is_extension
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @instance
                   */
                  NamePart.prototype.is_extension = false;

                  /**
                   * Creates a new NamePart instance using the specified properties.
                   * @function create
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                   * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                   */
                  NamePart.create = function create(properties) {
                      return new NamePart(properties);
                  };

                  /**
                   * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                   * @function encode
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  NamePart.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                      writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                      return writer;
                  };

                  /**
                   * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a NamePart message from the specified reader or buffer.
                   * @function decode
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  NamePart.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              message.name_part = reader.string();
                              break;
                          case 2:
                              message.is_extension = reader.bool();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      if (!message.hasOwnProperty("name_part"))
                          throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                      if (!message.hasOwnProperty("is_extension"))
                          throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                      return message;
                  };

                  /**
                   * Decodes a NamePart message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  NamePart.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a NamePart message.
                   * @function verify
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  NamePart.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (!$util.isString(message.name_part))
                          return "name_part: string expected";
                      if (typeof message.is_extension !== "boolean")
                          return "is_extension: boolean expected";
                      return null;
                  };

                  /**
                   * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                   */
                  NamePart.fromObject = function fromObject(object) {
                      if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                          return object;
                      var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                      if (object.name_part != null)
                          message.name_part = String(object.name_part);
                      if (object.is_extension != null)
                          message.is_extension = Boolean(object.is_extension);
                      return message;
                  };

                  /**
                   * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @static
                   * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  NamePart.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.defaults) {
                          object.name_part = "";
                          object.is_extension = false;
                      }
                      if (message.name_part != null && message.hasOwnProperty("name_part"))
                          object.name_part = message.name_part;
                      if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                          object.is_extension = message.is_extension;
                      return object;
                  };

                  /**
                   * Converts this NamePart to JSON.
                   * @function toJSON
                   * @memberof google.protobuf.UninterpretedOption.NamePart
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  NamePart.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return NamePart;
              })();

              return UninterpretedOption;
          })();

          protobuf.SourceCodeInfo = (function() {

              /**
               * Properties of a SourceCodeInfo.
               * @memberof google.protobuf
               * @interface ISourceCodeInfo
               * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
               */

              /**
               * Constructs a new SourceCodeInfo.
               * @memberof google.protobuf
               * @classdesc Represents a SourceCodeInfo.
               * @implements ISourceCodeInfo
               * @constructor
               * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
               */
              function SourceCodeInfo(properties) {
                  this.location = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * SourceCodeInfo location.
               * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
               * @memberof google.protobuf.SourceCodeInfo
               * @instance
               */
              SourceCodeInfo.prototype.location = $util.emptyArray;

              /**
               * Creates a new SourceCodeInfo instance using the specified properties.
               * @function create
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
               * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
               */
              SourceCodeInfo.create = function create(properties) {
                  return new SourceCodeInfo(properties);
              };

              /**
               * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              SourceCodeInfo.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.location != null && message.location.length)
                      for (var i = 0; i < message.location.length; ++i)
                          $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a SourceCodeInfo message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              SourceCodeInfo.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          if (!(message.location && message.location.length))
                              message.location = [];
                          message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a SourceCodeInfo message.
               * @function verify
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              SourceCodeInfo.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.location != null && message.hasOwnProperty("location")) {
                      if (!Array.isArray(message.location))
                          return "location: array expected";
                      for (var i = 0; i < message.location.length; ++i) {
                          var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                          if (error)
                              return "location." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
               */
              SourceCodeInfo.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.SourceCodeInfo)
                      return object;
                  var message = new $root.google.protobuf.SourceCodeInfo();
                  if (object.location) {
                      if (!Array.isArray(object.location))
                          throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                      message.location = [];
                      for (var i = 0; i < object.location.length; ++i) {
                          if (typeof object.location[i] !== "object")
                              throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                          message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                      }
                  }
                  return message;
              };

              /**
               * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.SourceCodeInfo
               * @static
               * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              SourceCodeInfo.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.location = [];
                  if (message.location && message.location.length) {
                      object.location = [];
                      for (var j = 0; j < message.location.length; ++j)
                          object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                  }
                  return object;
              };

              /**
               * Converts this SourceCodeInfo to JSON.
               * @function toJSON
               * @memberof google.protobuf.SourceCodeInfo
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              SourceCodeInfo.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              SourceCodeInfo.Location = (function() {

                  /**
                   * Properties of a Location.
                   * @memberof google.protobuf.SourceCodeInfo
                   * @interface ILocation
                   * @property {Array.<number>|null} [path] Location path
                   * @property {Array.<number>|null} [span] Location span
                   * @property {string|null} [leading_comments] Location leading_comments
                   * @property {string|null} [trailing_comments] Location trailing_comments
                   * @property {Array.<string>|null} [leading_detached_comments] Location leading_detached_comments
                   */

                  /**
                   * Constructs a new Location.
                   * @memberof google.protobuf.SourceCodeInfo
                   * @classdesc Represents a Location.
                   * @implements ILocation
                   * @constructor
                   * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                   */
                  function Location(properties) {
                      this.path = [];
                      this.span = [];
                      this.leading_detached_comments = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * Location path.
                   * @member {Array.<number>} path
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @instance
                   */
                  Location.prototype.path = $util.emptyArray;

                  /**
                   * Location span.
                   * @member {Array.<number>} span
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @instance
                   */
                  Location.prototype.span = $util.emptyArray;

                  /**
                   * Location leading_comments.
                   * @member {string} leading_comments
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @instance
                   */
                  Location.prototype.leading_comments = "";

                  /**
                   * Location trailing_comments.
                   * @member {string} trailing_comments
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @instance
                   */
                  Location.prototype.trailing_comments = "";

                  /**
                   * Location leading_detached_comments.
                   * @member {Array.<string>} leading_detached_comments
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @instance
                   */
                  Location.prototype.leading_detached_comments = $util.emptyArray;

                  /**
                   * Creates a new Location instance using the specified properties.
                   * @function create
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                   * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                   */
                  Location.create = function create(properties) {
                      return new Location(properties);
                  };

                  /**
                   * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                   * @function encode
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Location.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.path != null && message.path.length) {
                          writer.uint32(/* id 1, wireType 2 =*/10).fork();
                          for (var i = 0; i < message.path.length; ++i)
                              writer.int32(message.path[i]);
                          writer.ldelim();
                      }
                      if (message.span != null && message.span.length) {
                          writer.uint32(/* id 2, wireType 2 =*/18).fork();
                          for (var i = 0; i < message.span.length; ++i)
                              writer.int32(message.span[i]);
                          writer.ldelim();
                      }
                      if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                          writer.uint32(/* id 3, wireType 2 =*/26).string(message.leading_comments);
                      if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                          writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailing_comments);
                      if (message.leading_detached_comments != null && message.leading_detached_comments.length)
                          for (var i = 0; i < message.leading_detached_comments.length; ++i)
                              writer.uint32(/* id 6, wireType 2 =*/50).string(message.leading_detached_comments[i]);
                      return writer;
                  };

                  /**
                   * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Location.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes a Location message from the specified reader or buffer.
                   * @function decode
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {google.protobuf.SourceCodeInfo.Location} Location
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Location.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              if (!(message.path && message.path.length))
                                  message.path = [];
                              if ((tag & 7) === 2) {
                                  var end2 = reader.uint32() + reader.pos;
                                  while (reader.pos < end2)
                                      message.path.push(reader.int32());
                              } else
                                  message.path.push(reader.int32());
                              break;
                          case 2:
                              if (!(message.span && message.span.length))
                                  message.span = [];
                              if ((tag & 7) === 2) {
                                  var end2 = reader.uint32() + reader.pos;
                                  while (reader.pos < end2)
                                      message.span.push(reader.int32());
                              } else
                                  message.span.push(reader.int32());
                              break;
                          case 3:
                              message.leading_comments = reader.string();
                              break;
                          case 4:
                              message.trailing_comments = reader.string();
                              break;
                          case 6:
                              if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                                  message.leading_detached_comments = [];
                              message.leading_detached_comments.push(reader.string());
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes a Location message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {google.protobuf.SourceCodeInfo.Location} Location
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Location.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies a Location message.
                   * @function verify
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  Location.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.path != null && message.hasOwnProperty("path")) {
                          if (!Array.isArray(message.path))
                              return "path: array expected";
                          for (var i = 0; i < message.path.length; ++i)
                              if (!$util.isInteger(message.path[i]))
                                  return "path: integer[] expected";
                      }
                      if (message.span != null && message.hasOwnProperty("span")) {
                          if (!Array.isArray(message.span))
                              return "span: array expected";
                          for (var i = 0; i < message.span.length; ++i)
                              if (!$util.isInteger(message.span[i]))
                                  return "span: integer[] expected";
                      }
                      if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                          if (!$util.isString(message.leading_comments))
                              return "leading_comments: string expected";
                      if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                          if (!$util.isString(message.trailing_comments))
                              return "trailing_comments: string expected";
                      if (message.leading_detached_comments != null && message.hasOwnProperty("leading_detached_comments")) {
                          if (!Array.isArray(message.leading_detached_comments))
                              return "leading_detached_comments: array expected";
                          for (var i = 0; i < message.leading_detached_comments.length; ++i)
                              if (!$util.isString(message.leading_detached_comments[i]))
                                  return "leading_detached_comments: string[] expected";
                      }
                      return null;
                  };

                  /**
                   * Creates a Location message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {google.protobuf.SourceCodeInfo.Location} Location
                   */
                  Location.fromObject = function fromObject(object) {
                      if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                          return object;
                      var message = new $root.google.protobuf.SourceCodeInfo.Location();
                      if (object.path) {
                          if (!Array.isArray(object.path))
                              throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                          message.path = [];
                          for (var i = 0; i < object.path.length; ++i)
                              message.path[i] = object.path[i] | 0;
                      }
                      if (object.span) {
                          if (!Array.isArray(object.span))
                              throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                          message.span = [];
                          for (var i = 0; i < object.span.length; ++i)
                              message.span[i] = object.span[i] | 0;
                      }
                      if (object.leading_comments != null)
                          message.leading_comments = String(object.leading_comments);
                      if (object.trailing_comments != null)
                          message.trailing_comments = String(object.trailing_comments);
                      if (object.leading_detached_comments) {
                          if (!Array.isArray(object.leading_detached_comments))
                              throw TypeError(".google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected");
                          message.leading_detached_comments = [];
                          for (var i = 0; i < object.leading_detached_comments.length; ++i)
                              message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
                      }
                      return message;
                  };

                  /**
                   * Creates a plain object from a Location message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @static
                   * @param {google.protobuf.SourceCodeInfo.Location} message Location
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  Location.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults) {
                          object.path = [];
                          object.span = [];
                          object.leading_detached_comments = [];
                      }
                      if (options.defaults) {
                          object.leading_comments = "";
                          object.trailing_comments = "";
                      }
                      if (message.path && message.path.length) {
                          object.path = [];
                          for (var j = 0; j < message.path.length; ++j)
                              object.path[j] = message.path[j];
                      }
                      if (message.span && message.span.length) {
                          object.span = [];
                          for (var j = 0; j < message.span.length; ++j)
                              object.span[j] = message.span[j];
                      }
                      if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                          object.leading_comments = message.leading_comments;
                      if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                          object.trailing_comments = message.trailing_comments;
                      if (message.leading_detached_comments && message.leading_detached_comments.length) {
                          object.leading_detached_comments = [];
                          for (var j = 0; j < message.leading_detached_comments.length; ++j)
                              object.leading_detached_comments[j] = message.leading_detached_comments[j];
                      }
                      return object;
                  };

                  /**
                   * Converts this Location to JSON.
                   * @function toJSON
                   * @memberof google.protobuf.SourceCodeInfo.Location
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  Location.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return Location;
              })();

              return SourceCodeInfo;
          })();

          protobuf.GeneratedCodeInfo = (function() {

              /**
               * Properties of a GeneratedCodeInfo.
               * @memberof google.protobuf
               * @interface IGeneratedCodeInfo
               * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
               */

              /**
               * Constructs a new GeneratedCodeInfo.
               * @memberof google.protobuf
               * @classdesc Represents a GeneratedCodeInfo.
               * @implements IGeneratedCodeInfo
               * @constructor
               * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
               */
              function GeneratedCodeInfo(properties) {
                  this.annotation = [];
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * GeneratedCodeInfo annotation.
               * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
               * @memberof google.protobuf.GeneratedCodeInfo
               * @instance
               */
              GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

              /**
               * Creates a new GeneratedCodeInfo instance using the specified properties.
               * @function create
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
               * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
               */
              GeneratedCodeInfo.create = function create(properties) {
                  return new GeneratedCodeInfo(properties);
              };

              /**
               * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
               * @function encode
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              GeneratedCodeInfo.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  if (message.annotation != null && message.annotation.length)
                      for (var i = 0; i < message.annotation.length; ++i)
                          $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                  return writer;
              };

              /**
               * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
               * @function encodeDelimited
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
               * @function decode
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              GeneratedCodeInfo.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          if (!(message.annotation && message.annotation.length))
                              message.annotation = [];
                          message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  return message;
              };

              /**
               * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a GeneratedCodeInfo message.
               * @function verify
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              GeneratedCodeInfo.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (message.annotation != null && message.hasOwnProperty("annotation")) {
                      if (!Array.isArray(message.annotation))
                          return "annotation: array expected";
                      for (var i = 0; i < message.annotation.length; ++i) {
                          var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                          if (error)
                              return "annotation." + error;
                      }
                  }
                  return null;
              };

              /**
               * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
               */
              GeneratedCodeInfo.fromObject = function fromObject(object) {
                  if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                      return object;
                  var message = new $root.google.protobuf.GeneratedCodeInfo();
                  if (object.annotation) {
                      if (!Array.isArray(object.annotation))
                          throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                      message.annotation = [];
                      for (var i = 0; i < object.annotation.length; ++i) {
                          if (typeof object.annotation[i] !== "object")
                              throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                          message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                      }
                  }
                  return message;
              };

              /**
               * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
               * @function toObject
               * @memberof google.protobuf.GeneratedCodeInfo
               * @static
               * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              GeneratedCodeInfo.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.arrays || options.defaults)
                      object.annotation = [];
                  if (message.annotation && message.annotation.length) {
                      object.annotation = [];
                      for (var j = 0; j < message.annotation.length; ++j)
                          object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                  }
                  return object;
              };

              /**
               * Converts this GeneratedCodeInfo to JSON.
               * @function toJSON
               * @memberof google.protobuf.GeneratedCodeInfo
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
              };

              GeneratedCodeInfo.Annotation = (function() {

                  /**
                   * Properties of an Annotation.
                   * @memberof google.protobuf.GeneratedCodeInfo
                   * @interface IAnnotation
                   * @property {Array.<number>|null} [path] Annotation path
                   * @property {string|null} [source_file] Annotation source_file
                   * @property {number|null} [begin] Annotation begin
                   * @property {number|null} [end] Annotation end
                   */

                  /**
                   * Constructs a new Annotation.
                   * @memberof google.protobuf.GeneratedCodeInfo
                   * @classdesc Represents an Annotation.
                   * @implements IAnnotation
                   * @constructor
                   * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                   */
                  function Annotation(properties) {
                      this.path = [];
                      if (properties)
                          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                              if (properties[keys[i]] != null)
                                  this[keys[i]] = properties[keys[i]];
                  }

                  /**
                   * Annotation path.
                   * @member {Array.<number>} path
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @instance
                   */
                  Annotation.prototype.path = $util.emptyArray;

                  /**
                   * Annotation source_file.
                   * @member {string} source_file
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @instance
                   */
                  Annotation.prototype.source_file = "";

                  /**
                   * Annotation begin.
                   * @member {number} begin
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @instance
                   */
                  Annotation.prototype.begin = 0;

                  /**
                   * Annotation end.
                   * @member {number} end
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @instance
                   */
                  Annotation.prototype.end = 0;

                  /**
                   * Creates a new Annotation instance using the specified properties.
                   * @function create
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                   * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                   */
                  Annotation.create = function create(properties) {
                      return new Annotation(properties);
                  };

                  /**
                   * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                   * @function encode
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Annotation.encode = function encode(message, writer) {
                      if (!writer)
                          writer = $Writer.create();
                      if (message.path != null && message.path.length) {
                          writer.uint32(/* id 1, wireType 2 =*/10).fork();
                          for (var i = 0; i < message.path.length; ++i)
                              writer.int32(message.path[i]);
                          writer.ldelim();
                      }
                      if (message.source_file != null && message.hasOwnProperty("source_file"))
                          writer.uint32(/* id 2, wireType 2 =*/18).string(message.source_file);
                      if (message.begin != null && message.hasOwnProperty("begin"))
                          writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                      if (message.end != null && message.hasOwnProperty("end"))
                          writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                      return writer;
                  };

                  /**
                   * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                   * @function encodeDelimited
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                   * @param {$protobuf.Writer} [writer] Writer to encode to
                   * @returns {$protobuf.Writer} Writer
                   */
                  Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                      return this.encode(message, writer).ldelim();
                  };

                  /**
                   * Decodes an Annotation message from the specified reader or buffer.
                   * @function decode
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @param {number} [length] Message length if known beforehand
                   * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Annotation.decode = function decode(reader, length) {
                      if (!(reader instanceof $Reader))
                          reader = $Reader.create(reader);
                      var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                      while (reader.pos < end) {
                          var tag = reader.uint32();
                          switch (tag >>> 3) {
                          case 1:
                              if (!(message.path && message.path.length))
                                  message.path = [];
                              if ((tag & 7) === 2) {
                                  var end2 = reader.uint32() + reader.pos;
                                  while (reader.pos < end2)
                                      message.path.push(reader.int32());
                              } else
                                  message.path.push(reader.int32());
                              break;
                          case 2:
                              message.source_file = reader.string();
                              break;
                          case 3:
                              message.begin = reader.int32();
                              break;
                          case 4:
                              message.end = reader.int32();
                              break;
                          default:
                              reader.skipType(tag & 7);
                              break;
                          }
                      }
                      return message;
                  };

                  /**
                   * Decodes an Annotation message from the specified reader or buffer, length delimited.
                   * @function decodeDelimited
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                   * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                   * @throws {Error} If the payload is not a reader or valid buffer
                   * @throws {$protobuf.util.ProtocolError} If required fields are missing
                   */
                  Annotation.decodeDelimited = function decodeDelimited(reader) {
                      if (!(reader instanceof $Reader))
                          reader = new $Reader(reader);
                      return this.decode(reader, reader.uint32());
                  };

                  /**
                   * Verifies an Annotation message.
                   * @function verify
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {Object.<string,*>} message Plain object to verify
                   * @returns {string|null} `null` if valid, otherwise the reason why it is not
                   */
                  Annotation.verify = function verify(message) {
                      if (typeof message !== "object" || message === null)
                          return "object expected";
                      if (message.path != null && message.hasOwnProperty("path")) {
                          if (!Array.isArray(message.path))
                              return "path: array expected";
                          for (var i = 0; i < message.path.length; ++i)
                              if (!$util.isInteger(message.path[i]))
                                  return "path: integer[] expected";
                      }
                      if (message.source_file != null && message.hasOwnProperty("source_file"))
                          if (!$util.isString(message.source_file))
                              return "source_file: string expected";
                      if (message.begin != null && message.hasOwnProperty("begin"))
                          if (!$util.isInteger(message.begin))
                              return "begin: integer expected";
                      if (message.end != null && message.hasOwnProperty("end"))
                          if (!$util.isInteger(message.end))
                              return "end: integer expected";
                      return null;
                  };

                  /**
                   * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                   * @function fromObject
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {Object.<string,*>} object Plain object
                   * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                   */
                  Annotation.fromObject = function fromObject(object) {
                      if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                          return object;
                      var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                      if (object.path) {
                          if (!Array.isArray(object.path))
                              throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                          message.path = [];
                          for (var i = 0; i < object.path.length; ++i)
                              message.path[i] = object.path[i] | 0;
                      }
                      if (object.source_file != null)
                          message.source_file = String(object.source_file);
                      if (object.begin != null)
                          message.begin = object.begin | 0;
                      if (object.end != null)
                          message.end = object.end | 0;
                      return message;
                  };

                  /**
                   * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                   * @function toObject
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @static
                   * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                   * @param {$protobuf.IConversionOptions} [options] Conversion options
                   * @returns {Object.<string,*>} Plain object
                   */
                  Annotation.toObject = function toObject(message, options) {
                      if (!options)
                          options = {};
                      var object = {};
                      if (options.arrays || options.defaults)
                          object.path = [];
                      if (options.defaults) {
                          object.source_file = "";
                          object.begin = 0;
                          object.end = 0;
                      }
                      if (message.path && message.path.length) {
                          object.path = [];
                          for (var j = 0; j < message.path.length; ++j)
                              object.path[j] = message.path[j];
                      }
                      if (message.source_file != null && message.hasOwnProperty("source_file"))
                          object.source_file = message.source_file;
                      if (message.begin != null && message.hasOwnProperty("begin"))
                          object.begin = message.begin;
                      if (message.end != null && message.hasOwnProperty("end"))
                          object.end = message.end;
                      return object;
                  };

                  /**
                   * Converts this Annotation to JSON.
                   * @function toJSON
                   * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                   * @instance
                   * @returns {Object.<string,*>} JSON object
                   */
                  Annotation.prototype.toJSON = function toJSON() {
                      return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
                  };

                  return Annotation;
              })();

              return GeneratedCodeInfo;
          })();

          return protobuf;
      })();

      return google;
  })();

  $root.Par = (function() {

      /**
       * Properties of a Par.
       * @exports IPar
       * @interface IPar
       * @property {Array.<ISend>|null} [sends] Par sends
       * @property {Array.<IReceive>|null} [receives] Par receives
       * @property {Array.<INew>|null} [news] Par news
       * @property {Array.<IExpr>|null} [exprs] Par exprs
       * @property {Array.<IMatch>|null} [matches] Par matches
       * @property {Array.<IGUnforgeable>|null} [unforgeables] Par unforgeables
       * @property {Array.<IBundle>|null} [bundles] Par bundles
       * @property {Array.<IConnective>|null} [connectives] Par connectives
       * @property {Uint8Array|null} [locallyFree] Par locallyFree
       * @property {boolean|null} [connective_used] Par connective_used
       */

      /**
       * Constructs a new Par.
       * @exports Par
       * @classdesc Rholang process
       * 
       * For example, `@0!(1) | @2!(3) | for(x <- @0) { Nil }` has two sends
       * and one receive.
       * 
       * The Nil process is a `Par` with no sends, receives, etc.
       * @implements IPar
       * @constructor
       * @param {IPar=} [properties] Properties to set
       */
      function Par(properties) {
          this.sends = [];
          this.receives = [];
          this.news = [];
          this.exprs = [];
          this.matches = [];
          this.unforgeables = [];
          this.bundles = [];
          this.connectives = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Par sends.
       * @member {Array.<ISend>} sends
       * @memberof Par
       * @instance
       */
      Par.prototype.sends = $util.emptyArray;

      /**
       * Par receives.
       * @member {Array.<IReceive>} receives
       * @memberof Par
       * @instance
       */
      Par.prototype.receives = $util.emptyArray;

      /**
       * Par news.
       * @member {Array.<INew>} news
       * @memberof Par
       * @instance
       */
      Par.prototype.news = $util.emptyArray;

      /**
       * Par exprs.
       * @member {Array.<IExpr>} exprs
       * @memberof Par
       * @instance
       */
      Par.prototype.exprs = $util.emptyArray;

      /**
       * Par matches.
       * @member {Array.<IMatch>} matches
       * @memberof Par
       * @instance
       */
      Par.prototype.matches = $util.emptyArray;

      /**
       * Par unforgeables.
       * @member {Array.<IGUnforgeable>} unforgeables
       * @memberof Par
       * @instance
       */
      Par.prototype.unforgeables = $util.emptyArray;

      /**
       * Par bundles.
       * @member {Array.<IBundle>} bundles
       * @memberof Par
       * @instance
       */
      Par.prototype.bundles = $util.emptyArray;

      /**
       * Par connectives.
       * @member {Array.<IConnective>} connectives
       * @memberof Par
       * @instance
       */
      Par.prototype.connectives = $util.emptyArray;

      /**
       * Par locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof Par
       * @instance
       */
      Par.prototype.locallyFree = $util.newBuffer([]);

      /**
       * Par connective_used.
       * @member {boolean} connective_used
       * @memberof Par
       * @instance
       */
      Par.prototype.connective_used = false;

      /**
       * Creates a new Par instance using the specified properties.
       * @function create
       * @memberof Par
       * @static
       * @param {IPar=} [properties] Properties to set
       * @returns {Par} Par instance
       */
      Par.create = function create(properties) {
          return new Par(properties);
      };

      /**
       * Encodes the specified Par message. Does not implicitly {@link Par.verify|verify} messages.
       * @function encode
       * @memberof Par
       * @static
       * @param {IPar} message Par message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Par.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.sends != null && message.sends.length)
              for (var i = 0; i < message.sends.length; ++i)
                  $root.Send.encode(message.sends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.receives != null && message.receives.length)
              for (var i = 0; i < message.receives.length; ++i)
                  $root.Receive.encode(message.receives[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.news != null && message.news.length)
              for (var i = 0; i < message.news.length; ++i)
                  $root.New.encode(message.news[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
          if (message.exprs != null && message.exprs.length)
              for (var i = 0; i < message.exprs.length; ++i)
                  $root.Expr.encode(message.exprs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
          if (message.matches != null && message.matches.length)
              for (var i = 0; i < message.matches.length; ++i)
                  $root.Match.encode(message.matches[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
          if (message.unforgeables != null && message.unforgeables.length)
              for (var i = 0; i < message.unforgeables.length; ++i)
                  $root.GUnforgeable.encode(message.unforgeables[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
          if (message.connectives != null && message.connectives.length)
              for (var i = 0; i < message.connectives.length; ++i)
                  $root.Connective.encode(message.connectives[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 10, wireType 0 =*/80).bool(message.connective_used);
          if (message.bundles != null && message.bundles.length)
              for (var i = 0; i < message.bundles.length; ++i)
                  $root.Bundle.encode(message.bundles[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified Par message, length delimited. Does not implicitly {@link Par.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Par
       * @static
       * @param {IPar} message Par message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Par.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Par message from the specified reader or buffer.
       * @function decode
       * @memberof Par
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Par} Par
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Par.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Par();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.sends && message.sends.length))
                      message.sends = [];
                  message.sends.push($root.Send.decode(reader, reader.uint32()));
                  break;
              case 2:
                  if (!(message.receives && message.receives.length))
                      message.receives = [];
                  message.receives.push($root.Receive.decode(reader, reader.uint32()));
                  break;
              case 4:
                  if (!(message.news && message.news.length))
                      message.news = [];
                  message.news.push($root.New.decode(reader, reader.uint32()));
                  break;
              case 5:
                  if (!(message.exprs && message.exprs.length))
                      message.exprs = [];
                  message.exprs.push($root.Expr.decode(reader, reader.uint32()));
                  break;
              case 6:
                  if (!(message.matches && message.matches.length))
                      message.matches = [];
                  message.matches.push($root.Match.decode(reader, reader.uint32()));
                  break;
              case 7:
                  if (!(message.unforgeables && message.unforgeables.length))
                      message.unforgeables = [];
                  message.unforgeables.push($root.GUnforgeable.decode(reader, reader.uint32()));
                  break;
              case 11:
                  if (!(message.bundles && message.bundles.length))
                      message.bundles = [];
                  message.bundles.push($root.Bundle.decode(reader, reader.uint32()));
                  break;
              case 8:
                  if (!(message.connectives && message.connectives.length))
                      message.connectives = [];
                  message.connectives.push($root.Connective.decode(reader, reader.uint32()));
                  break;
              case 9:
                  message.locallyFree = reader.bytes();
                  break;
              case 10:
                  message.connective_used = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Par message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Par
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Par} Par
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Par.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Par message.
       * @function verify
       * @memberof Par
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Par.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.sends != null && message.hasOwnProperty("sends")) {
              if (!Array.isArray(message.sends))
                  return "sends: array expected";
              for (var i = 0; i < message.sends.length; ++i) {
                  var error = $root.Send.verify(message.sends[i]);
                  if (error)
                      return "sends." + error;
              }
          }
          if (message.receives != null && message.hasOwnProperty("receives")) {
              if (!Array.isArray(message.receives))
                  return "receives: array expected";
              for (var i = 0; i < message.receives.length; ++i) {
                  var error = $root.Receive.verify(message.receives[i]);
                  if (error)
                      return "receives." + error;
              }
          }
          if (message.news != null && message.hasOwnProperty("news")) {
              if (!Array.isArray(message.news))
                  return "news: array expected";
              for (var i = 0; i < message.news.length; ++i) {
                  var error = $root.New.verify(message.news[i]);
                  if (error)
                      return "news." + error;
              }
          }
          if (message.exprs != null && message.hasOwnProperty("exprs")) {
              if (!Array.isArray(message.exprs))
                  return "exprs: array expected";
              for (var i = 0; i < message.exprs.length; ++i) {
                  var error = $root.Expr.verify(message.exprs[i]);
                  if (error)
                      return "exprs." + error;
              }
          }
          if (message.matches != null && message.hasOwnProperty("matches")) {
              if (!Array.isArray(message.matches))
                  return "matches: array expected";
              for (var i = 0; i < message.matches.length; ++i) {
                  var error = $root.Match.verify(message.matches[i]);
                  if (error)
                      return "matches." + error;
              }
          }
          if (message.unforgeables != null && message.hasOwnProperty("unforgeables")) {
              if (!Array.isArray(message.unforgeables))
                  return "unforgeables: array expected";
              for (var i = 0; i < message.unforgeables.length; ++i) {
                  var error = $root.GUnforgeable.verify(message.unforgeables[i]);
                  if (error)
                      return "unforgeables." + error;
              }
          }
          if (message.bundles != null && message.hasOwnProperty("bundles")) {
              if (!Array.isArray(message.bundles))
                  return "bundles: array expected";
              for (var i = 0; i < message.bundles.length; ++i) {
                  var error = $root.Bundle.verify(message.bundles[i]);
                  if (error)
                      return "bundles." + error;
              }
          }
          if (message.connectives != null && message.hasOwnProperty("connectives")) {
              if (!Array.isArray(message.connectives))
                  return "connectives: array expected";
              for (var i = 0; i < message.connectives.length; ++i) {
                  var error = $root.Connective.verify(message.connectives[i]);
                  if (error)
                      return "connectives." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          return null;
      };

      /**
       * Creates a Par message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Par
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Par} Par
       */
      Par.fromObject = function fromObject(object) {
          if (object instanceof $root.Par)
              return object;
          var message = new $root.Par();
          if (object.sends) {
              if (!Array.isArray(object.sends))
                  throw TypeError(".Par.sends: array expected");
              message.sends = [];
              for (var i = 0; i < object.sends.length; ++i) {
                  if (typeof object.sends[i] !== "object")
                      throw TypeError(".Par.sends: object expected");
                  message.sends[i] = $root.Send.fromObject(object.sends[i]);
              }
          }
          if (object.receives) {
              if (!Array.isArray(object.receives))
                  throw TypeError(".Par.receives: array expected");
              message.receives = [];
              for (var i = 0; i < object.receives.length; ++i) {
                  if (typeof object.receives[i] !== "object")
                      throw TypeError(".Par.receives: object expected");
                  message.receives[i] = $root.Receive.fromObject(object.receives[i]);
              }
          }
          if (object.news) {
              if (!Array.isArray(object.news))
                  throw TypeError(".Par.news: array expected");
              message.news = [];
              for (var i = 0; i < object.news.length; ++i) {
                  if (typeof object.news[i] !== "object")
                      throw TypeError(".Par.news: object expected");
                  message.news[i] = $root.New.fromObject(object.news[i]);
              }
          }
          if (object.exprs) {
              if (!Array.isArray(object.exprs))
                  throw TypeError(".Par.exprs: array expected");
              message.exprs = [];
              for (var i = 0; i < object.exprs.length; ++i) {
                  if (typeof object.exprs[i] !== "object")
                      throw TypeError(".Par.exprs: object expected");
                  message.exprs[i] = $root.Expr.fromObject(object.exprs[i]);
              }
          }
          if (object.matches) {
              if (!Array.isArray(object.matches))
                  throw TypeError(".Par.matches: array expected");
              message.matches = [];
              for (var i = 0; i < object.matches.length; ++i) {
                  if (typeof object.matches[i] !== "object")
                      throw TypeError(".Par.matches: object expected");
                  message.matches[i] = $root.Match.fromObject(object.matches[i]);
              }
          }
          if (object.unforgeables) {
              if (!Array.isArray(object.unforgeables))
                  throw TypeError(".Par.unforgeables: array expected");
              message.unforgeables = [];
              for (var i = 0; i < object.unforgeables.length; ++i) {
                  if (typeof object.unforgeables[i] !== "object")
                      throw TypeError(".Par.unforgeables: object expected");
                  message.unforgeables[i] = $root.GUnforgeable.fromObject(object.unforgeables[i]);
              }
          }
          if (object.bundles) {
              if (!Array.isArray(object.bundles))
                  throw TypeError(".Par.bundles: array expected");
              message.bundles = [];
              for (var i = 0; i < object.bundles.length; ++i) {
                  if (typeof object.bundles[i] !== "object")
                      throw TypeError(".Par.bundles: object expected");
                  message.bundles[i] = $root.Bundle.fromObject(object.bundles[i]);
              }
          }
          if (object.connectives) {
              if (!Array.isArray(object.connectives))
                  throw TypeError(".Par.connectives: array expected");
              message.connectives = [];
              for (var i = 0; i < object.connectives.length; ++i) {
                  if (typeof object.connectives[i] !== "object")
                      throw TypeError(".Par.connectives: object expected");
                  message.connectives[i] = $root.Connective.fromObject(object.connectives[i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          return message;
      };

      /**
       * Creates a plain object from a Par message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Par
       * @static
       * @param {Par} message Par
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Par.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults) {
              object.sends = [];
              object.receives = [];
              object.news = [];
              object.exprs = [];
              object.matches = [];
              object.unforgeables = [];
              object.connectives = [];
              object.bundles = [];
          }
          if (options.defaults) {
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
          }
          if (message.sends && message.sends.length) {
              object.sends = [];
              for (var j = 0; j < message.sends.length; ++j)
                  object.sends[j] = $root.Send.toObject(message.sends[j], options);
          }
          if (message.receives && message.receives.length) {
              object.receives = [];
              for (var j = 0; j < message.receives.length; ++j)
                  object.receives[j] = $root.Receive.toObject(message.receives[j], options);
          }
          if (message.news && message.news.length) {
              object.news = [];
              for (var j = 0; j < message.news.length; ++j)
                  object.news[j] = $root.New.toObject(message.news[j], options);
          }
          if (message.exprs && message.exprs.length) {
              object.exprs = [];
              for (var j = 0; j < message.exprs.length; ++j)
                  object.exprs[j] = $root.Expr.toObject(message.exprs[j], options);
          }
          if (message.matches && message.matches.length) {
              object.matches = [];
              for (var j = 0; j < message.matches.length; ++j)
                  object.matches[j] = $root.Match.toObject(message.matches[j], options);
          }
          if (message.unforgeables && message.unforgeables.length) {
              object.unforgeables = [];
              for (var j = 0; j < message.unforgeables.length; ++j)
                  object.unforgeables[j] = $root.GUnforgeable.toObject(message.unforgeables[j], options);
          }
          if (message.connectives && message.connectives.length) {
              object.connectives = [];
              for (var j = 0; j < message.connectives.length; ++j)
                  object.connectives[j] = $root.Connective.toObject(message.connectives[j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          if (message.bundles && message.bundles.length) {
              object.bundles = [];
              for (var j = 0; j < message.bundles.length; ++j)
                  object.bundles[j] = $root.Bundle.toObject(message.bundles[j], options);
          }
          return object;
      };

      /**
       * Converts this Par to JSON.
       * @function toJSON
       * @memberof Par
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Par.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Par;
  })();

  $root.TaggedContinuation = (function() {

      /**
       * Properties of a TaggedContinuation.
       * @exports ITaggedContinuation
       * @interface ITaggedContinuation
       * @property {IParWithRandom|null} [par_body] TaggedContinuation par_body
       * @property {number|Long|null} [scala_body_ref] TaggedContinuation scala_body_ref
       */

      /**
       * Constructs a new TaggedContinuation.
       * @exports TaggedContinuation
       * @classdesc Either rholang code or code built in to the interpreter.
       * @implements ITaggedContinuation
       * @constructor
       * @param {ITaggedContinuation=} [properties] Properties to set
       */
      function TaggedContinuation(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * TaggedContinuation par_body.
       * @member {IParWithRandom|null|undefined} par_body
       * @memberof TaggedContinuation
       * @instance
       */
      TaggedContinuation.prototype.par_body = null;

      /**
       * TaggedContinuation scala_body_ref.
       * @member {number|Long} scala_body_ref
       * @memberof TaggedContinuation
       * @instance
       */
      TaggedContinuation.prototype.scala_body_ref = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

      // OneOf field names bound to virtual getters and setters
      var $oneOfFields;

      /**
       * TaggedContinuation tagged_cont.
       * @member {"par_body"|"scala_body_ref"|undefined} tagged_cont
       * @memberof TaggedContinuation
       * @instance
       */
      Object.defineProperty(TaggedContinuation.prototype, "tagged_cont", {
          get: $util.oneOfGetter($oneOfFields = ["par_body", "scala_body_ref"]),
          set: $util.oneOfSetter($oneOfFields)
      });

      /**
       * Creates a new TaggedContinuation instance using the specified properties.
       * @function create
       * @memberof TaggedContinuation
       * @static
       * @param {ITaggedContinuation=} [properties] Properties to set
       * @returns {TaggedContinuation} TaggedContinuation instance
       */
      TaggedContinuation.create = function create(properties) {
          return new TaggedContinuation(properties);
      };

      /**
       * Encodes the specified TaggedContinuation message. Does not implicitly {@link TaggedContinuation.verify|verify} messages.
       * @function encode
       * @memberof TaggedContinuation
       * @static
       * @param {ITaggedContinuation} message TaggedContinuation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TaggedContinuation.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.par_body != null && message.hasOwnProperty("par_body"))
              $root.ParWithRandom.encode(message.par_body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.scala_body_ref != null && message.hasOwnProperty("scala_body_ref"))
              writer.uint32(/* id 2, wireType 0 =*/16).int64(message.scala_body_ref);
          return writer;
      };

      /**
       * Encodes the specified TaggedContinuation message, length delimited. Does not implicitly {@link TaggedContinuation.verify|verify} messages.
       * @function encodeDelimited
       * @memberof TaggedContinuation
       * @static
       * @param {ITaggedContinuation} message TaggedContinuation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TaggedContinuation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a TaggedContinuation message from the specified reader or buffer.
       * @function decode
       * @memberof TaggedContinuation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {TaggedContinuation} TaggedContinuation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TaggedContinuation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TaggedContinuation();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.par_body = $root.ParWithRandom.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.scala_body_ref = reader.int64();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a TaggedContinuation message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof TaggedContinuation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {TaggedContinuation} TaggedContinuation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TaggedContinuation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a TaggedContinuation message.
       * @function verify
       * @memberof TaggedContinuation
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      TaggedContinuation.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          var properties = {};
          if (message.par_body != null && message.hasOwnProperty("par_body")) {
              properties.tagged_cont = 1;
              {
                  var error = $root.ParWithRandom.verify(message.par_body);
                  if (error)
                      return "par_body." + error;
              }
          }
          if (message.scala_body_ref != null && message.hasOwnProperty("scala_body_ref")) {
              if (properties.tagged_cont === 1)
                  return "tagged_cont: multiple values";
              properties.tagged_cont = 1;
              if (!$util.isInteger(message.scala_body_ref) && !(message.scala_body_ref && $util.isInteger(message.scala_body_ref.low) && $util.isInteger(message.scala_body_ref.high)))
                  return "scala_body_ref: integer|Long expected";
          }
          return null;
      };

      /**
       * Creates a TaggedContinuation message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof TaggedContinuation
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {TaggedContinuation} TaggedContinuation
       */
      TaggedContinuation.fromObject = function fromObject(object) {
          if (object instanceof $root.TaggedContinuation)
              return object;
          var message = new $root.TaggedContinuation();
          if (object.par_body != null) {
              if (typeof object.par_body !== "object")
                  throw TypeError(".TaggedContinuation.par_body: object expected");
              message.par_body = $root.ParWithRandom.fromObject(object.par_body);
          }
          if (object.scala_body_ref != null)
              if ($util.Long)
                  (message.scala_body_ref = $util.Long.fromValue(object.scala_body_ref)).unsigned = false;
              else if (typeof object.scala_body_ref === "string")
                  message.scala_body_ref = parseInt(object.scala_body_ref, 10);
              else if (typeof object.scala_body_ref === "number")
                  message.scala_body_ref = object.scala_body_ref;
              else if (typeof object.scala_body_ref === "object")
                  message.scala_body_ref = new $util.LongBits(object.scala_body_ref.low >>> 0, object.scala_body_ref.high >>> 0).toNumber();
          return message;
      };

      /**
       * Creates a plain object from a TaggedContinuation message. Also converts values to other types if specified.
       * @function toObject
       * @memberof TaggedContinuation
       * @static
       * @param {TaggedContinuation} message TaggedContinuation
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      TaggedContinuation.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (message.par_body != null && message.hasOwnProperty("par_body")) {
              object.par_body = $root.ParWithRandom.toObject(message.par_body, options);
              if (options.oneofs)
                  object.tagged_cont = "par_body";
          }
          if (message.scala_body_ref != null && message.hasOwnProperty("scala_body_ref")) {
              if (typeof message.scala_body_ref === "number")
                  object.scala_body_ref = options.longs === String ? String(message.scala_body_ref) : message.scala_body_ref;
              else
                  object.scala_body_ref = options.longs === String ? $util.Long.prototype.toString.call(message.scala_body_ref) : options.longs === Number ? new $util.LongBits(message.scala_body_ref.low >>> 0, message.scala_body_ref.high >>> 0).toNumber() : message.scala_body_ref;
              if (options.oneofs)
                  object.tagged_cont = "scala_body_ref";
          }
          return object;
      };

      /**
       * Converts this TaggedContinuation to JSON.
       * @function toJSON
       * @memberof TaggedContinuation
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      TaggedContinuation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return TaggedContinuation;
  })();

  $root.ParWithRandom = (function() {

      /**
       * Properties of a ParWithRandom.
       * @exports IParWithRandom
       * @interface IParWithRandom
       * @property {IPar|null} [body] ParWithRandom body
       * @property {Uint8Array|null} [randomState] ParWithRandom randomState
       */

      /**
       * Constructs a new ParWithRandom.
       * @exports ParWithRandom
       * @classdesc Rholang code along with the state of a split random number
       * generator for generating new unforgeable names.
       * @implements IParWithRandom
       * @constructor
       * @param {IParWithRandom=} [properties] Properties to set
       */
      function ParWithRandom(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ParWithRandom body.
       * @member {IPar|null|undefined} body
       * @memberof ParWithRandom
       * @instance
       */
      ParWithRandom.prototype.body = null;

      /**
       * ParWithRandom randomState.
       * @member {Uint8Array} randomState
       * @memberof ParWithRandom
       * @instance
       */
      ParWithRandom.prototype.randomState = $util.newBuffer([]);

      /**
       * Creates a new ParWithRandom instance using the specified properties.
       * @function create
       * @memberof ParWithRandom
       * @static
       * @param {IParWithRandom=} [properties] Properties to set
       * @returns {ParWithRandom} ParWithRandom instance
       */
      ParWithRandom.create = function create(properties) {
          return new ParWithRandom(properties);
      };

      /**
       * Encodes the specified ParWithRandom message. Does not implicitly {@link ParWithRandom.verify|verify} messages.
       * @function encode
       * @memberof ParWithRandom
       * @static
       * @param {IParWithRandom} message ParWithRandom message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ParWithRandom.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.body != null && message.hasOwnProperty("body"))
              $root.Par.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.randomState != null && message.hasOwnProperty("randomState"))
              writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.randomState);
          return writer;
      };

      /**
       * Encodes the specified ParWithRandom message, length delimited. Does not implicitly {@link ParWithRandom.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ParWithRandom
       * @static
       * @param {IParWithRandom} message ParWithRandom message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ParWithRandom.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ParWithRandom message from the specified reader or buffer.
       * @function decode
       * @memberof ParWithRandom
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ParWithRandom} ParWithRandom
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ParWithRandom.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ParWithRandom();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.body = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.randomState = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ParWithRandom message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ParWithRandom
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ParWithRandom} ParWithRandom
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ParWithRandom.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ParWithRandom message.
       * @function verify
       * @memberof ParWithRandom
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ParWithRandom.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.body != null && message.hasOwnProperty("body")) {
              var error = $root.Par.verify(message.body);
              if (error)
                  return "body." + error;
          }
          if (message.randomState != null && message.hasOwnProperty("randomState"))
              if (!(message.randomState && typeof message.randomState.length === "number" || $util.isString(message.randomState)))
                  return "randomState: buffer expected";
          return null;
      };

      /**
       * Creates a ParWithRandom message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ParWithRandom
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ParWithRandom} ParWithRandom
       */
      ParWithRandom.fromObject = function fromObject(object) {
          if (object instanceof $root.ParWithRandom)
              return object;
          var message = new $root.ParWithRandom();
          if (object.body != null) {
              if (typeof object.body !== "object")
                  throw TypeError(".ParWithRandom.body: object expected");
              message.body = $root.Par.fromObject(object.body);
          }
          if (object.randomState != null)
              if (typeof object.randomState === "string")
                  $util.base64.decode(object.randomState, message.randomState = $util.newBuffer($util.base64.length(object.randomState)), 0);
              else if (object.randomState.length)
                  message.randomState = object.randomState;
          return message;
      };

      /**
       * Creates a plain object from a ParWithRandom message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ParWithRandom
       * @static
       * @param {ParWithRandom} message ParWithRandom
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ParWithRandom.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.body = null;
              if (options.bytes === String)
                  object.randomState = "";
              else {
                  object.randomState = [];
                  if (options.bytes !== Array)
                      object.randomState = $util.newBuffer(object.randomState);
              }
          }
          if (message.body != null && message.hasOwnProperty("body"))
              object.body = $root.Par.toObject(message.body, options);
          if (message.randomState != null && message.hasOwnProperty("randomState"))
              object.randomState = options.bytes === String ? $util.base64.encode(message.randomState, 0, message.randomState.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomState) : message.randomState;
          return object;
      };

      /**
       * Converts this ParWithRandom to JSON.
       * @function toJSON
       * @memberof ParWithRandom
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ParWithRandom.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ParWithRandom;
  })();

  $root.PCost = (function() {

      /**
       * Properties of a PCost.
       * @exports IPCost
       * @interface IPCost
       * @property {number|Long|null} [cost] PCost cost
       */

      /**
       * Constructs a new PCost.
       * @exports PCost
       * @classdesc Cost of the performed operations.
       * @implements IPCost
       * @constructor
       * @param {IPCost=} [properties] Properties to set
       */
      function PCost(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * PCost cost.
       * @member {number|Long} cost
       * @memberof PCost
       * @instance
       */
      PCost.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

      /**
       * Creates a new PCost instance using the specified properties.
       * @function create
       * @memberof PCost
       * @static
       * @param {IPCost=} [properties] Properties to set
       * @returns {PCost} PCost instance
       */
      PCost.create = function create(properties) {
          return new PCost(properties);
      };

      /**
       * Encodes the specified PCost message. Does not implicitly {@link PCost.verify|verify} messages.
       * @function encode
       * @memberof PCost
       * @static
       * @param {IPCost} message PCost message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PCost.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.cost != null && message.hasOwnProperty("cost"))
              writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.cost);
          return writer;
      };

      /**
       * Encodes the specified PCost message, length delimited. Does not implicitly {@link PCost.verify|verify} messages.
       * @function encodeDelimited
       * @memberof PCost
       * @static
       * @param {IPCost} message PCost message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PCost.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PCost message from the specified reader or buffer.
       * @function decode
       * @memberof PCost
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {PCost} PCost
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PCost.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PCost();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.cost = reader.uint64();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a PCost message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof PCost
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {PCost} PCost
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PCost.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PCost message.
       * @function verify
       * @memberof PCost
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PCost.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.cost != null && message.hasOwnProperty("cost"))
              if (!$util.isInteger(message.cost) && !(message.cost && $util.isInteger(message.cost.low) && $util.isInteger(message.cost.high)))
                  return "cost: integer|Long expected";
          return null;
      };

      /**
       * Creates a PCost message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof PCost
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {PCost} PCost
       */
      PCost.fromObject = function fromObject(object) {
          if (object instanceof $root.PCost)
              return object;
          var message = new $root.PCost();
          if (object.cost != null)
              if ($util.Long)
                  (message.cost = $util.Long.fromValue(object.cost)).unsigned = true;
              else if (typeof object.cost === "string")
                  message.cost = parseInt(object.cost, 10);
              else if (typeof object.cost === "number")
                  message.cost = object.cost;
              else if (typeof object.cost === "object")
                  message.cost = new $util.LongBits(object.cost.low >>> 0, object.cost.high >>> 0).toNumber(true);
          return message;
      };

      /**
       * Creates a plain object from a PCost message. Also converts values to other types if specified.
       * @function toObject
       * @memberof PCost
       * @static
       * @param {PCost} message PCost
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PCost.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              if ($util.Long) {
                  var long = new $util.Long(0, 0, true);
                  object.cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                  object.cost = options.longs === String ? "0" : 0;
          if (message.cost != null && message.hasOwnProperty("cost"))
              if (typeof message.cost === "number")
                  object.cost = options.longs === String ? String(message.cost) : message.cost;
              else
                  object.cost = options.longs === String ? $util.Long.prototype.toString.call(message.cost) : options.longs === Number ? new $util.LongBits(message.cost.low >>> 0, message.cost.high >>> 0).toNumber(true) : message.cost;
          return object;
      };

      /**
       * Converts this PCost to JSON.
       * @function toJSON
       * @memberof PCost
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PCost.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return PCost;
  })();

  $root.ListParWithRandom = (function() {

      /**
       * Properties of a ListParWithRandom.
       * @exports IListParWithRandom
       * @interface IListParWithRandom
       * @property {Array.<IPar>|null} [pars] ListParWithRandom pars
       * @property {Uint8Array|null} [randomState] ListParWithRandom randomState
       */

      /**
       * Constructs a new ListParWithRandom.
       * @exports ListParWithRandom
       * @classdesc Represents a ListParWithRandom.
       * @implements IListParWithRandom
       * @constructor
       * @param {IListParWithRandom=} [properties] Properties to set
       */
      function ListParWithRandom(properties) {
          this.pars = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ListParWithRandom pars.
       * @member {Array.<IPar>} pars
       * @memberof ListParWithRandom
       * @instance
       */
      ListParWithRandom.prototype.pars = $util.emptyArray;

      /**
       * ListParWithRandom randomState.
       * @member {Uint8Array} randomState
       * @memberof ListParWithRandom
       * @instance
       */
      ListParWithRandom.prototype.randomState = $util.newBuffer([]);

      /**
       * Creates a new ListParWithRandom instance using the specified properties.
       * @function create
       * @memberof ListParWithRandom
       * @static
       * @param {IListParWithRandom=} [properties] Properties to set
       * @returns {ListParWithRandom} ListParWithRandom instance
       */
      ListParWithRandom.create = function create(properties) {
          return new ListParWithRandom(properties);
      };

      /**
       * Encodes the specified ListParWithRandom message. Does not implicitly {@link ListParWithRandom.verify|verify} messages.
       * @function encode
       * @memberof ListParWithRandom
       * @static
       * @param {IListParWithRandom} message ListParWithRandom message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListParWithRandom.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.pars != null && message.pars.length)
              for (var i = 0; i < message.pars.length; ++i)
                  $root.Par.encode(message.pars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.randomState != null && message.hasOwnProperty("randomState"))
              writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.randomState);
          return writer;
      };

      /**
       * Encodes the specified ListParWithRandom message, length delimited. Does not implicitly {@link ListParWithRandom.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ListParWithRandom
       * @static
       * @param {IListParWithRandom} message ListParWithRandom message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListParWithRandom.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ListParWithRandom message from the specified reader or buffer.
       * @function decode
       * @memberof ListParWithRandom
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ListParWithRandom} ListParWithRandom
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListParWithRandom.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListParWithRandom();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.pars && message.pars.length))
                      message.pars = [];
                  message.pars.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 2:
                  message.randomState = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ListParWithRandom message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ListParWithRandom
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ListParWithRandom} ListParWithRandom
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListParWithRandom.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ListParWithRandom message.
       * @function verify
       * @memberof ListParWithRandom
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ListParWithRandom.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.pars != null && message.hasOwnProperty("pars")) {
              if (!Array.isArray(message.pars))
                  return "pars: array expected";
              for (var i = 0; i < message.pars.length; ++i) {
                  var error = $root.Par.verify(message.pars[i]);
                  if (error)
                      return "pars." + error;
              }
          }
          if (message.randomState != null && message.hasOwnProperty("randomState"))
              if (!(message.randomState && typeof message.randomState.length === "number" || $util.isString(message.randomState)))
                  return "randomState: buffer expected";
          return null;
      };

      /**
       * Creates a ListParWithRandom message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ListParWithRandom
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ListParWithRandom} ListParWithRandom
       */
      ListParWithRandom.fromObject = function fromObject(object) {
          if (object instanceof $root.ListParWithRandom)
              return object;
          var message = new $root.ListParWithRandom();
          if (object.pars) {
              if (!Array.isArray(object.pars))
                  throw TypeError(".ListParWithRandom.pars: array expected");
              message.pars = [];
              for (var i = 0; i < object.pars.length; ++i) {
                  if (typeof object.pars[i] !== "object")
                      throw TypeError(".ListParWithRandom.pars: object expected");
                  message.pars[i] = $root.Par.fromObject(object.pars[i]);
              }
          }
          if (object.randomState != null)
              if (typeof object.randomState === "string")
                  $util.base64.decode(object.randomState, message.randomState = $util.newBuffer($util.base64.length(object.randomState)), 0);
              else if (object.randomState.length)
                  message.randomState = object.randomState;
          return message;
      };

      /**
       * Creates a plain object from a ListParWithRandom message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ListParWithRandom
       * @static
       * @param {ListParWithRandom} message ListParWithRandom
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ListParWithRandom.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.pars = [];
          if (options.defaults)
              if (options.bytes === String)
                  object.randomState = "";
              else {
                  object.randomState = [];
                  if (options.bytes !== Array)
                      object.randomState = $util.newBuffer(object.randomState);
              }
          if (message.pars && message.pars.length) {
              object.pars = [];
              for (var j = 0; j < message.pars.length; ++j)
                  object.pars[j] = $root.Par.toObject(message.pars[j], options);
          }
          if (message.randomState != null && message.hasOwnProperty("randomState"))
              object.randomState = options.bytes === String ? $util.base64.encode(message.randomState, 0, message.randomState.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomState) : message.randomState;
          return object;
      };

      /**
       * Converts this ListParWithRandom to JSON.
       * @function toJSON
       * @memberof ListParWithRandom
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ListParWithRandom.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ListParWithRandom;
  })();

  $root.Var = (function() {

      /**
       * Properties of a Var.
       * @exports IVar
       * @interface IVar
       * @property {number|null} [bound_var] Var bound_var
       * @property {number|null} [free_var] Var free_var
       * @property {Var.IWildcardMsg|null} [wildcard] Var wildcard
       */

      /**
       * Constructs a new Var.
       * @exports Var
       * @classdesc Represents a Var.
       * @implements IVar
       * @constructor
       * @param {IVar=} [properties] Properties to set
       */
      function Var(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Var bound_var.
       * @member {number} bound_var
       * @memberof Var
       * @instance
       */
      Var.prototype.bound_var = 0;

      /**
       * Var free_var.
       * @member {number} free_var
       * @memberof Var
       * @instance
       */
      Var.prototype.free_var = 0;

      /**
       * Var wildcard.
       * @member {Var.IWildcardMsg|null|undefined} wildcard
       * @memberof Var
       * @instance
       */
      Var.prototype.wildcard = null;

      // OneOf field names bound to virtual getters and setters
      var $oneOfFields;

      /**
       * Var var_instance.
       * @member {"bound_var"|"free_var"|"wildcard"|undefined} var_instance
       * @memberof Var
       * @instance
       */
      Object.defineProperty(Var.prototype, "var_instance", {
          get: $util.oneOfGetter($oneOfFields = ["bound_var", "free_var", "wildcard"]),
          set: $util.oneOfSetter($oneOfFields)
      });

      /**
       * Creates a new Var instance using the specified properties.
       * @function create
       * @memberof Var
       * @static
       * @param {IVar=} [properties] Properties to set
       * @returns {Var} Var instance
       */
      Var.create = function create(properties) {
          return new Var(properties);
      };

      /**
       * Encodes the specified Var message. Does not implicitly {@link Var.verify|verify} messages.
       * @function encode
       * @memberof Var
       * @static
       * @param {IVar} message Var message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Var.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.bound_var != null && message.hasOwnProperty("bound_var"))
              writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.bound_var);
          if (message.free_var != null && message.hasOwnProperty("free_var"))
              writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.free_var);
          if (message.wildcard != null && message.hasOwnProperty("wildcard"))
              $root.Var.WildcardMsg.encode(message.wildcard, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified Var message, length delimited. Does not implicitly {@link Var.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Var
       * @static
       * @param {IVar} message Var message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Var.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Var message from the specified reader or buffer.
       * @function decode
       * @memberof Var
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Var} Var
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Var.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Var();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.bound_var = reader.sint32();
                  break;
              case 2:
                  message.free_var = reader.sint32();
                  break;
              case 3:
                  message.wildcard = $root.Var.WildcardMsg.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Var message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Var
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Var} Var
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Var.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Var message.
       * @function verify
       * @memberof Var
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Var.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          var properties = {};
          if (message.bound_var != null && message.hasOwnProperty("bound_var")) {
              properties.var_instance = 1;
              if (!$util.isInteger(message.bound_var))
                  return "bound_var: integer expected";
          }
          if (message.free_var != null && message.hasOwnProperty("free_var")) {
              if (properties.var_instance === 1)
                  return "var_instance: multiple values";
              properties.var_instance = 1;
              if (!$util.isInteger(message.free_var))
                  return "free_var: integer expected";
          }
          if (message.wildcard != null && message.hasOwnProperty("wildcard")) {
              if (properties.var_instance === 1)
                  return "var_instance: multiple values";
              properties.var_instance = 1;
              {
                  var error = $root.Var.WildcardMsg.verify(message.wildcard);
                  if (error)
                      return "wildcard." + error;
              }
          }
          return null;
      };

      /**
       * Creates a Var message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Var
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Var} Var
       */
      Var.fromObject = function fromObject(object) {
          if (object instanceof $root.Var)
              return object;
          var message = new $root.Var();
          if (object.bound_var != null)
              message.bound_var = object.bound_var | 0;
          if (object.free_var != null)
              message.free_var = object.free_var | 0;
          if (object.wildcard != null) {
              if (typeof object.wildcard !== "object")
                  throw TypeError(".Var.wildcard: object expected");
              message.wildcard = $root.Var.WildcardMsg.fromObject(object.wildcard);
          }
          return message;
      };

      /**
       * Creates a plain object from a Var message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Var
       * @static
       * @param {Var} message Var
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Var.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (message.bound_var != null && message.hasOwnProperty("bound_var")) {
              object.bound_var = message.bound_var;
              if (options.oneofs)
                  object.var_instance = "bound_var";
          }
          if (message.free_var != null && message.hasOwnProperty("free_var")) {
              object.free_var = message.free_var;
              if (options.oneofs)
                  object.var_instance = "free_var";
          }
          if (message.wildcard != null && message.hasOwnProperty("wildcard")) {
              object.wildcard = $root.Var.WildcardMsg.toObject(message.wildcard, options);
              if (options.oneofs)
                  object.var_instance = "wildcard";
          }
          return object;
      };

      /**
       * Converts this Var to JSON.
       * @function toJSON
       * @memberof Var
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Var.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      Var.WildcardMsg = (function() {

          /**
           * Properties of a WildcardMsg.
           * @memberof Var
           * @interface IWildcardMsg
           */

          /**
           * Constructs a new WildcardMsg.
           * @memberof Var
           * @classdesc Represents a WildcardMsg.
           * @implements IWildcardMsg
           * @constructor
           * @param {Var.IWildcardMsg=} [properties] Properties to set
           */
          function WildcardMsg(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new WildcardMsg instance using the specified properties.
           * @function create
           * @memberof Var.WildcardMsg
           * @static
           * @param {Var.IWildcardMsg=} [properties] Properties to set
           * @returns {Var.WildcardMsg} WildcardMsg instance
           */
          WildcardMsg.create = function create(properties) {
              return new WildcardMsg(properties);
          };

          /**
           * Encodes the specified WildcardMsg message. Does not implicitly {@link Var.WildcardMsg.verify|verify} messages.
           * @function encode
           * @memberof Var.WildcardMsg
           * @static
           * @param {Var.IWildcardMsg} message WildcardMsg message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          WildcardMsg.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified WildcardMsg message, length delimited. Does not implicitly {@link Var.WildcardMsg.verify|verify} messages.
           * @function encodeDelimited
           * @memberof Var.WildcardMsg
           * @static
           * @param {Var.IWildcardMsg} message WildcardMsg message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          WildcardMsg.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a WildcardMsg message from the specified reader or buffer.
           * @function decode
           * @memberof Var.WildcardMsg
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {Var.WildcardMsg} WildcardMsg
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          WildcardMsg.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Var.WildcardMsg();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a WildcardMsg message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof Var.WildcardMsg
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {Var.WildcardMsg} WildcardMsg
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          WildcardMsg.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a WildcardMsg message.
           * @function verify
           * @memberof Var.WildcardMsg
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          WildcardMsg.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a WildcardMsg message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof Var.WildcardMsg
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {Var.WildcardMsg} WildcardMsg
           */
          WildcardMsg.fromObject = function fromObject(object) {
              if (object instanceof $root.Var.WildcardMsg)
                  return object;
              return new $root.Var.WildcardMsg();
          };

          /**
           * Creates a plain object from a WildcardMsg message. Also converts values to other types if specified.
           * @function toObject
           * @memberof Var.WildcardMsg
           * @static
           * @param {Var.WildcardMsg} message WildcardMsg
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          WildcardMsg.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this WildcardMsg to JSON.
           * @function toJSON
           * @memberof Var.WildcardMsg
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          WildcardMsg.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return WildcardMsg;
      })();

      return Var;
  })();

  $root.Bundle = (function() {

      /**
       * Properties of a Bundle.
       * @exports IBundle
       * @interface IBundle
       * @property {IPar|null} [body] Bundle body
       * @property {boolean|null} [writeFlag] Bundle writeFlag
       * @property {boolean|null} [readFlag] Bundle readFlag
       */

      /**
       * Constructs a new Bundle.
       * @exports Bundle
       * @classdesc Nothing can be received from a (quoted) bundle with `readFlag = false`.
       * Likeise nothing can be sent to a (quoted) bundle with `writeFlag = false`.
       * 
       * If both flags are set to false, bundle allows only for equivalance check.
       * @implements IBundle
       * @constructor
       * @param {IBundle=} [properties] Properties to set
       */
      function Bundle(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Bundle body.
       * @member {IPar|null|undefined} body
       * @memberof Bundle
       * @instance
       */
      Bundle.prototype.body = null;

      /**
       * Bundle writeFlag.
       * @member {boolean} writeFlag
       * @memberof Bundle
       * @instance
       */
      Bundle.prototype.writeFlag = false;

      /**
       * Bundle readFlag.
       * @member {boolean} readFlag
       * @memberof Bundle
       * @instance
       */
      Bundle.prototype.readFlag = false;

      /**
       * Creates a new Bundle instance using the specified properties.
       * @function create
       * @memberof Bundle
       * @static
       * @param {IBundle=} [properties] Properties to set
       * @returns {Bundle} Bundle instance
       */
      Bundle.create = function create(properties) {
          return new Bundle(properties);
      };

      /**
       * Encodes the specified Bundle message. Does not implicitly {@link Bundle.verify|verify} messages.
       * @function encode
       * @memberof Bundle
       * @static
       * @param {IBundle} message Bundle message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Bundle.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.body != null && message.hasOwnProperty("body"))
              $root.Par.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.writeFlag != null && message.hasOwnProperty("writeFlag"))
              writer.uint32(/* id 2, wireType 0 =*/16).bool(message.writeFlag);
          if (message.readFlag != null && message.hasOwnProperty("readFlag"))
              writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readFlag);
          return writer;
      };

      /**
       * Encodes the specified Bundle message, length delimited. Does not implicitly {@link Bundle.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Bundle
       * @static
       * @param {IBundle} message Bundle message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Bundle.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Bundle message from the specified reader or buffer.
       * @function decode
       * @memberof Bundle
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Bundle} Bundle
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Bundle.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Bundle();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.body = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.writeFlag = reader.bool();
                  break;
              case 3:
                  message.readFlag = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Bundle message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Bundle
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Bundle} Bundle
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Bundle.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Bundle message.
       * @function verify
       * @memberof Bundle
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Bundle.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.body != null && message.hasOwnProperty("body")) {
              var error = $root.Par.verify(message.body);
              if (error)
                  return "body." + error;
          }
          if (message.writeFlag != null && message.hasOwnProperty("writeFlag"))
              if (typeof message.writeFlag !== "boolean")
                  return "writeFlag: boolean expected";
          if (message.readFlag != null && message.hasOwnProperty("readFlag"))
              if (typeof message.readFlag !== "boolean")
                  return "readFlag: boolean expected";
          return null;
      };

      /**
       * Creates a Bundle message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Bundle
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Bundle} Bundle
       */
      Bundle.fromObject = function fromObject(object) {
          if (object instanceof $root.Bundle)
              return object;
          var message = new $root.Bundle();
          if (object.body != null) {
              if (typeof object.body !== "object")
                  throw TypeError(".Bundle.body: object expected");
              message.body = $root.Par.fromObject(object.body);
          }
          if (object.writeFlag != null)
              message.writeFlag = Boolean(object.writeFlag);
          if (object.readFlag != null)
              message.readFlag = Boolean(object.readFlag);
          return message;
      };

      /**
       * Creates a plain object from a Bundle message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Bundle
       * @static
       * @param {Bundle} message Bundle
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Bundle.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.body = null;
              object.writeFlag = false;
              object.readFlag = false;
          }
          if (message.body != null && message.hasOwnProperty("body"))
              object.body = $root.Par.toObject(message.body, options);
          if (message.writeFlag != null && message.hasOwnProperty("writeFlag"))
              object.writeFlag = message.writeFlag;
          if (message.readFlag != null && message.hasOwnProperty("readFlag"))
              object.readFlag = message.readFlag;
          return object;
      };

      /**
       * Converts this Bundle to JSON.
       * @function toJSON
       * @memberof Bundle
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Bundle.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Bundle;
  })();

  $root.Send = (function() {

      /**
       * Properties of a Send.
       * @exports ISend
       * @interface ISend
       * @property {IPar|null} [chan] Send chan
       * @property {Array.<IPar>|null} [data] Send data
       * @property {boolean|null} [persistent] Send persistent
       * @property {Uint8Array|null} [locallyFree] Send locallyFree
       * @property {boolean|null} [connective_used] Send connective_used
       */

      /**
       * Constructs a new Send.
       * @exports Send
       * @classdesc A send is written `chan!(data)` or `chan!!(data)` for a persistent send.
       * 
       * Upon send, all free variables in data are substituted with their values.
       * @implements ISend
       * @constructor
       * @param {ISend=} [properties] Properties to set
       */
      function Send(properties) {
          this.data = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Send chan.
       * @member {IPar|null|undefined} chan
       * @memberof Send
       * @instance
       */
      Send.prototype.chan = null;

      /**
       * Send data.
       * @member {Array.<IPar>} data
       * @memberof Send
       * @instance
       */
      Send.prototype.data = $util.emptyArray;

      /**
       * Send persistent.
       * @member {boolean} persistent
       * @memberof Send
       * @instance
       */
      Send.prototype.persistent = false;

      /**
       * Send locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof Send
       * @instance
       */
      Send.prototype.locallyFree = $util.newBuffer([]);

      /**
       * Send connective_used.
       * @member {boolean} connective_used
       * @memberof Send
       * @instance
       */
      Send.prototype.connective_used = false;

      /**
       * Creates a new Send instance using the specified properties.
       * @function create
       * @memberof Send
       * @static
       * @param {ISend=} [properties] Properties to set
       * @returns {Send} Send instance
       */
      Send.create = function create(properties) {
          return new Send(properties);
      };

      /**
       * Encodes the specified Send message. Does not implicitly {@link Send.verify|verify} messages.
       * @function encode
       * @memberof Send
       * @static
       * @param {ISend} message Send message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Send.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.chan != null && message.hasOwnProperty("chan"))
              $root.Par.encode(message.chan, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.data != null && message.data.length)
              for (var i = 0; i < message.data.length; ++i)
                  $root.Par.encode(message.data[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.persistent != null && message.hasOwnProperty("persistent"))
              writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 6, wireType 0 =*/48).bool(message.connective_used);
          return writer;
      };

      /**
       * Encodes the specified Send message, length delimited. Does not implicitly {@link Send.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Send
       * @static
       * @param {ISend} message Send message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Send.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Send message from the specified reader or buffer.
       * @function decode
       * @memberof Send
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Send} Send
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Send.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Send();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.chan = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  if (!(message.data && message.data.length))
                      message.data = [];
                  message.data.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 3:
                  message.persistent = reader.bool();
                  break;
              case 5:
                  message.locallyFree = reader.bytes();
                  break;
              case 6:
                  message.connective_used = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Send message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Send
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Send} Send
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Send.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Send message.
       * @function verify
       * @memberof Send
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Send.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.chan != null && message.hasOwnProperty("chan")) {
              var error = $root.Par.verify(message.chan);
              if (error)
                  return "chan." + error;
          }
          if (message.data != null && message.hasOwnProperty("data")) {
              if (!Array.isArray(message.data))
                  return "data: array expected";
              for (var i = 0; i < message.data.length; ++i) {
                  var error = $root.Par.verify(message.data[i]);
                  if (error)
                      return "data." + error;
              }
          }
          if (message.persistent != null && message.hasOwnProperty("persistent"))
              if (typeof message.persistent !== "boolean")
                  return "persistent: boolean expected";
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          return null;
      };

      /**
       * Creates a Send message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Send
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Send} Send
       */
      Send.fromObject = function fromObject(object) {
          if (object instanceof $root.Send)
              return object;
          var message = new $root.Send();
          if (object.chan != null) {
              if (typeof object.chan !== "object")
                  throw TypeError(".Send.chan: object expected");
              message.chan = $root.Par.fromObject(object.chan);
          }
          if (object.data) {
              if (!Array.isArray(object.data))
                  throw TypeError(".Send.data: array expected");
              message.data = [];
              for (var i = 0; i < object.data.length; ++i) {
                  if (typeof object.data[i] !== "object")
                      throw TypeError(".Send.data: object expected");
                  message.data[i] = $root.Par.fromObject(object.data[i]);
              }
          }
          if (object.persistent != null)
              message.persistent = Boolean(object.persistent);
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          return message;
      };

      /**
       * Creates a plain object from a Send message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Send
       * @static
       * @param {Send} message Send
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Send.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.data = [];
          if (options.defaults) {
              object.chan = null;
              object.persistent = false;
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
          }
          if (message.chan != null && message.hasOwnProperty("chan"))
              object.chan = $root.Par.toObject(message.chan, options);
          if (message.data && message.data.length) {
              object.data = [];
              for (var j = 0; j < message.data.length; ++j)
                  object.data[j] = $root.Par.toObject(message.data[j], options);
          }
          if (message.persistent != null && message.hasOwnProperty("persistent"))
              object.persistent = message.persistent;
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          return object;
      };

      /**
       * Converts this Send to JSON.
       * @function toJSON
       * @memberof Send
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Send.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Send;
  })();

  $root.ReceiveBind = (function() {

      /**
       * Properties of a ReceiveBind.
       * @exports IReceiveBind
       * @interface IReceiveBind
       * @property {Array.<IPar>|null} [patterns] ReceiveBind patterns
       * @property {IPar|null} [source] ReceiveBind source
       * @property {IVar|null} [remainder] ReceiveBind remainder
       * @property {number|null} [freeCount] ReceiveBind freeCount
       */

      /**
       * Constructs a new ReceiveBind.
       * @exports ReceiveBind
       * @classdesc Represents a ReceiveBind.
       * @implements IReceiveBind
       * @constructor
       * @param {IReceiveBind=} [properties] Properties to set
       */
      function ReceiveBind(properties) {
          this.patterns = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ReceiveBind patterns.
       * @member {Array.<IPar>} patterns
       * @memberof ReceiveBind
       * @instance
       */
      ReceiveBind.prototype.patterns = $util.emptyArray;

      /**
       * ReceiveBind source.
       * @member {IPar|null|undefined} source
       * @memberof ReceiveBind
       * @instance
       */
      ReceiveBind.prototype.source = null;

      /**
       * ReceiveBind remainder.
       * @member {IVar|null|undefined} remainder
       * @memberof ReceiveBind
       * @instance
       */
      ReceiveBind.prototype.remainder = null;

      /**
       * ReceiveBind freeCount.
       * @member {number} freeCount
       * @memberof ReceiveBind
       * @instance
       */
      ReceiveBind.prototype.freeCount = 0;

      /**
       * Creates a new ReceiveBind instance using the specified properties.
       * @function create
       * @memberof ReceiveBind
       * @static
       * @param {IReceiveBind=} [properties] Properties to set
       * @returns {ReceiveBind} ReceiveBind instance
       */
      ReceiveBind.create = function create(properties) {
          return new ReceiveBind(properties);
      };

      /**
       * Encodes the specified ReceiveBind message. Does not implicitly {@link ReceiveBind.verify|verify} messages.
       * @function encode
       * @memberof ReceiveBind
       * @static
       * @param {IReceiveBind} message ReceiveBind message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ReceiveBind.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.patterns != null && message.patterns.length)
              for (var i = 0; i < message.patterns.length; ++i)
                  $root.Par.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.source != null && message.hasOwnProperty("source"))
              $root.Par.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              $root.Var.encode(message.remainder, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              writer.uint32(/* id 4, wireType 0 =*/32).int32(message.freeCount);
          return writer;
      };

      /**
       * Encodes the specified ReceiveBind message, length delimited. Does not implicitly {@link ReceiveBind.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ReceiveBind
       * @static
       * @param {IReceiveBind} message ReceiveBind message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ReceiveBind.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ReceiveBind message from the specified reader or buffer.
       * @function decode
       * @memberof ReceiveBind
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ReceiveBind} ReceiveBind
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ReceiveBind.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReceiveBind();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.patterns && message.patterns.length))
                      message.patterns = [];
                  message.patterns.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 2:
                  message.source = $root.Par.decode(reader, reader.uint32());
                  break;
              case 3:
                  message.remainder = $root.Var.decode(reader, reader.uint32());
                  break;
              case 4:
                  message.freeCount = reader.int32();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ReceiveBind message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ReceiveBind
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ReceiveBind} ReceiveBind
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ReceiveBind.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ReceiveBind message.
       * @function verify
       * @memberof ReceiveBind
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ReceiveBind.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.patterns != null && message.hasOwnProperty("patterns")) {
              if (!Array.isArray(message.patterns))
                  return "patterns: array expected";
              for (var i = 0; i < message.patterns.length; ++i) {
                  var error = $root.Par.verify(message.patterns[i]);
                  if (error)
                      return "patterns." + error;
              }
          }
          if (message.source != null && message.hasOwnProperty("source")) {
              var error = $root.Par.verify(message.source);
              if (error)
                  return "source." + error;
          }
          if (message.remainder != null && message.hasOwnProperty("remainder")) {
              var error = $root.Var.verify(message.remainder);
              if (error)
                  return "remainder." + error;
          }
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              if (!$util.isInteger(message.freeCount))
                  return "freeCount: integer expected";
          return null;
      };

      /**
       * Creates a ReceiveBind message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ReceiveBind
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ReceiveBind} ReceiveBind
       */
      ReceiveBind.fromObject = function fromObject(object) {
          if (object instanceof $root.ReceiveBind)
              return object;
          var message = new $root.ReceiveBind();
          if (object.patterns) {
              if (!Array.isArray(object.patterns))
                  throw TypeError(".ReceiveBind.patterns: array expected");
              message.patterns = [];
              for (var i = 0; i < object.patterns.length; ++i) {
                  if (typeof object.patterns[i] !== "object")
                      throw TypeError(".ReceiveBind.patterns: object expected");
                  message.patterns[i] = $root.Par.fromObject(object.patterns[i]);
              }
          }
          if (object.source != null) {
              if (typeof object.source !== "object")
                  throw TypeError(".ReceiveBind.source: object expected");
              message.source = $root.Par.fromObject(object.source);
          }
          if (object.remainder != null) {
              if (typeof object.remainder !== "object")
                  throw TypeError(".ReceiveBind.remainder: object expected");
              message.remainder = $root.Var.fromObject(object.remainder);
          }
          if (object.freeCount != null)
              message.freeCount = object.freeCount | 0;
          return message;
      };

      /**
       * Creates a plain object from a ReceiveBind message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ReceiveBind
       * @static
       * @param {ReceiveBind} message ReceiveBind
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ReceiveBind.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.patterns = [];
          if (options.defaults) {
              object.source = null;
              object.remainder = null;
              object.freeCount = 0;
          }
          if (message.patterns && message.patterns.length) {
              object.patterns = [];
              for (var j = 0; j < message.patterns.length; ++j)
                  object.patterns[j] = $root.Par.toObject(message.patterns[j], options);
          }
          if (message.source != null && message.hasOwnProperty("source"))
              object.source = $root.Par.toObject(message.source, options);
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              object.remainder = $root.Var.toObject(message.remainder, options);
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              object.freeCount = message.freeCount;
          return object;
      };

      /**
       * Converts this ReceiveBind to JSON.
       * @function toJSON
       * @memberof ReceiveBind
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ReceiveBind.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ReceiveBind;
  })();

  $root.BindPattern = (function() {

      /**
       * Properties of a BindPattern.
       * @exports IBindPattern
       * @interface IBindPattern
       * @property {Array.<IPar>|null} [patterns] BindPattern patterns
       * @property {IVar|null} [remainder] BindPattern remainder
       * @property {number|null} [freeCount] BindPattern freeCount
       */

      /**
       * Constructs a new BindPattern.
       * @exports BindPattern
       * @classdesc Represents a BindPattern.
       * @implements IBindPattern
       * @constructor
       * @param {IBindPattern=} [properties] Properties to set
       */
      function BindPattern(properties) {
          this.patterns = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * BindPattern patterns.
       * @member {Array.<IPar>} patterns
       * @memberof BindPattern
       * @instance
       */
      BindPattern.prototype.patterns = $util.emptyArray;

      /**
       * BindPattern remainder.
       * @member {IVar|null|undefined} remainder
       * @memberof BindPattern
       * @instance
       */
      BindPattern.prototype.remainder = null;

      /**
       * BindPattern freeCount.
       * @member {number} freeCount
       * @memberof BindPattern
       * @instance
       */
      BindPattern.prototype.freeCount = 0;

      /**
       * Creates a new BindPattern instance using the specified properties.
       * @function create
       * @memberof BindPattern
       * @static
       * @param {IBindPattern=} [properties] Properties to set
       * @returns {BindPattern} BindPattern instance
       */
      BindPattern.create = function create(properties) {
          return new BindPattern(properties);
      };

      /**
       * Encodes the specified BindPattern message. Does not implicitly {@link BindPattern.verify|verify} messages.
       * @function encode
       * @memberof BindPattern
       * @static
       * @param {IBindPattern} message BindPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BindPattern.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.patterns != null && message.patterns.length)
              for (var i = 0; i < message.patterns.length; ++i)
                  $root.Par.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              $root.Var.encode(message.remainder, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              writer.uint32(/* id 3, wireType 0 =*/24).int32(message.freeCount);
          return writer;
      };

      /**
       * Encodes the specified BindPattern message, length delimited. Does not implicitly {@link BindPattern.verify|verify} messages.
       * @function encodeDelimited
       * @memberof BindPattern
       * @static
       * @param {IBindPattern} message BindPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BindPattern.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BindPattern message from the specified reader or buffer.
       * @function decode
       * @memberof BindPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {BindPattern} BindPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BindPattern.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BindPattern();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.patterns && message.patterns.length))
                      message.patterns = [];
                  message.patterns.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 2:
                  message.remainder = $root.Var.decode(reader, reader.uint32());
                  break;
              case 3:
                  message.freeCount = reader.int32();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a BindPattern message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof BindPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {BindPattern} BindPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BindPattern.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BindPattern message.
       * @function verify
       * @memberof BindPattern
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BindPattern.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.patterns != null && message.hasOwnProperty("patterns")) {
              if (!Array.isArray(message.patterns))
                  return "patterns: array expected";
              for (var i = 0; i < message.patterns.length; ++i) {
                  var error = $root.Par.verify(message.patterns[i]);
                  if (error)
                      return "patterns." + error;
              }
          }
          if (message.remainder != null && message.hasOwnProperty("remainder")) {
              var error = $root.Var.verify(message.remainder);
              if (error)
                  return "remainder." + error;
          }
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              if (!$util.isInteger(message.freeCount))
                  return "freeCount: integer expected";
          return null;
      };

      /**
       * Creates a BindPattern message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof BindPattern
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {BindPattern} BindPattern
       */
      BindPattern.fromObject = function fromObject(object) {
          if (object instanceof $root.BindPattern)
              return object;
          var message = new $root.BindPattern();
          if (object.patterns) {
              if (!Array.isArray(object.patterns))
                  throw TypeError(".BindPattern.patterns: array expected");
              message.patterns = [];
              for (var i = 0; i < object.patterns.length; ++i) {
                  if (typeof object.patterns[i] !== "object")
                      throw TypeError(".BindPattern.patterns: object expected");
                  message.patterns[i] = $root.Par.fromObject(object.patterns[i]);
              }
          }
          if (object.remainder != null) {
              if (typeof object.remainder !== "object")
                  throw TypeError(".BindPattern.remainder: object expected");
              message.remainder = $root.Var.fromObject(object.remainder);
          }
          if (object.freeCount != null)
              message.freeCount = object.freeCount | 0;
          return message;
      };

      /**
       * Creates a plain object from a BindPattern message. Also converts values to other types if specified.
       * @function toObject
       * @memberof BindPattern
       * @static
       * @param {BindPattern} message BindPattern
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BindPattern.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.patterns = [];
          if (options.defaults) {
              object.remainder = null;
              object.freeCount = 0;
          }
          if (message.patterns && message.patterns.length) {
              object.patterns = [];
              for (var j = 0; j < message.patterns.length; ++j)
                  object.patterns[j] = $root.Par.toObject(message.patterns[j], options);
          }
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              object.remainder = $root.Var.toObject(message.remainder, options);
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              object.freeCount = message.freeCount;
          return object;
      };

      /**
       * Converts this BindPattern to JSON.
       * @function toJSON
       * @memberof BindPattern
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BindPattern.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return BindPattern;
  })();

  $root.ListBindPatterns = (function() {

      /**
       * Properties of a ListBindPatterns.
       * @exports IListBindPatterns
       * @interface IListBindPatterns
       * @property {Array.<IBindPattern>|null} [patterns] ListBindPatterns patterns
       */

      /**
       * Constructs a new ListBindPatterns.
       * @exports ListBindPatterns
       * @classdesc Represents a ListBindPatterns.
       * @implements IListBindPatterns
       * @constructor
       * @param {IListBindPatterns=} [properties] Properties to set
       */
      function ListBindPatterns(properties) {
          this.patterns = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ListBindPatterns patterns.
       * @member {Array.<IBindPattern>} patterns
       * @memberof ListBindPatterns
       * @instance
       */
      ListBindPatterns.prototype.patterns = $util.emptyArray;

      /**
       * Creates a new ListBindPatterns instance using the specified properties.
       * @function create
       * @memberof ListBindPatterns
       * @static
       * @param {IListBindPatterns=} [properties] Properties to set
       * @returns {ListBindPatterns} ListBindPatterns instance
       */
      ListBindPatterns.create = function create(properties) {
          return new ListBindPatterns(properties);
      };

      /**
       * Encodes the specified ListBindPatterns message. Does not implicitly {@link ListBindPatterns.verify|verify} messages.
       * @function encode
       * @memberof ListBindPatterns
       * @static
       * @param {IListBindPatterns} message ListBindPatterns message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListBindPatterns.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.patterns != null && message.patterns.length)
              for (var i = 0; i < message.patterns.length; ++i)
                  $root.BindPattern.encode(message.patterns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ListBindPatterns message, length delimited. Does not implicitly {@link ListBindPatterns.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ListBindPatterns
       * @static
       * @param {IListBindPatterns} message ListBindPatterns message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListBindPatterns.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ListBindPatterns message from the specified reader or buffer.
       * @function decode
       * @memberof ListBindPatterns
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ListBindPatterns} ListBindPatterns
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListBindPatterns.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListBindPatterns();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.patterns && message.patterns.length))
                      message.patterns = [];
                  message.patterns.push($root.BindPattern.decode(reader, reader.uint32()));
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ListBindPatterns message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ListBindPatterns
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ListBindPatterns} ListBindPatterns
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListBindPatterns.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ListBindPatterns message.
       * @function verify
       * @memberof ListBindPatterns
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ListBindPatterns.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.patterns != null && message.hasOwnProperty("patterns")) {
              if (!Array.isArray(message.patterns))
                  return "patterns: array expected";
              for (var i = 0; i < message.patterns.length; ++i) {
                  var error = $root.BindPattern.verify(message.patterns[i]);
                  if (error)
                      return "patterns." + error;
              }
          }
          return null;
      };

      /**
       * Creates a ListBindPatterns message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ListBindPatterns
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ListBindPatterns} ListBindPatterns
       */
      ListBindPatterns.fromObject = function fromObject(object) {
          if (object instanceof $root.ListBindPatterns)
              return object;
          var message = new $root.ListBindPatterns();
          if (object.patterns) {
              if (!Array.isArray(object.patterns))
                  throw TypeError(".ListBindPatterns.patterns: array expected");
              message.patterns = [];
              for (var i = 0; i < object.patterns.length; ++i) {
                  if (typeof object.patterns[i] !== "object")
                      throw TypeError(".ListBindPatterns.patterns: object expected");
                  message.patterns[i] = $root.BindPattern.fromObject(object.patterns[i]);
              }
          }
          return message;
      };

      /**
       * Creates a plain object from a ListBindPatterns message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ListBindPatterns
       * @static
       * @param {ListBindPatterns} message ListBindPatterns
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ListBindPatterns.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.patterns = [];
          if (message.patterns && message.patterns.length) {
              object.patterns = [];
              for (var j = 0; j < message.patterns.length; ++j)
                  object.patterns[j] = $root.BindPattern.toObject(message.patterns[j], options);
          }
          return object;
      };

      /**
       * Converts this ListBindPatterns to JSON.
       * @function toJSON
       * @memberof ListBindPatterns
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ListBindPatterns.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ListBindPatterns;
  })();

  $root.Receive = (function() {

      /**
       * Properties of a Receive.
       * @exports IReceive
       * @interface IReceive
       * @property {Array.<IReceiveBind>|null} [binds] Receive binds
       * @property {IPar|null} [body] Receive body
       * @property {boolean|null} [persistent] Receive persistent
       * @property {boolean|null} [peek] Receive peek
       * @property {number|null} [bindCount] Receive bindCount
       * @property {Uint8Array|null} [locallyFree] Receive locallyFree
       * @property {boolean|null} [connective_used] Receive connective_used
       */

      /**
       * Constructs a new Receive.
       * @exports Receive
       * @classdesc A receive is written `for(binds) { body }`
       * i.e. `for(patterns <- source) { body }`
       * or for a persistent recieve: `for(patterns <= source) { body }`.
       * 
       * It's an error for free Variable to occur more than once in a pattern.
       * @implements IReceive
       * @constructor
       * @param {IReceive=} [properties] Properties to set
       */
      function Receive(properties) {
          this.binds = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Receive binds.
       * @member {Array.<IReceiveBind>} binds
       * @memberof Receive
       * @instance
       */
      Receive.prototype.binds = $util.emptyArray;

      /**
       * Receive body.
       * @member {IPar|null|undefined} body
       * @memberof Receive
       * @instance
       */
      Receive.prototype.body = null;

      /**
       * Receive persistent.
       * @member {boolean} persistent
       * @memberof Receive
       * @instance
       */
      Receive.prototype.persistent = false;

      /**
       * Receive peek.
       * @member {boolean} peek
       * @memberof Receive
       * @instance
       */
      Receive.prototype.peek = false;

      /**
       * Receive bindCount.
       * @member {number} bindCount
       * @memberof Receive
       * @instance
       */
      Receive.prototype.bindCount = 0;

      /**
       * Receive locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof Receive
       * @instance
       */
      Receive.prototype.locallyFree = $util.newBuffer([]);

      /**
       * Receive connective_used.
       * @member {boolean} connective_used
       * @memberof Receive
       * @instance
       */
      Receive.prototype.connective_used = false;

      /**
       * Creates a new Receive instance using the specified properties.
       * @function create
       * @memberof Receive
       * @static
       * @param {IReceive=} [properties] Properties to set
       * @returns {Receive} Receive instance
       */
      Receive.create = function create(properties) {
          return new Receive(properties);
      };

      /**
       * Encodes the specified Receive message. Does not implicitly {@link Receive.verify|verify} messages.
       * @function encode
       * @memberof Receive
       * @static
       * @param {IReceive} message Receive message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Receive.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.binds != null && message.binds.length)
              for (var i = 0; i < message.binds.length; ++i)
                  $root.ReceiveBind.encode(message.binds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.body != null && message.hasOwnProperty("body"))
              $root.Par.encode(message.body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.persistent != null && message.hasOwnProperty("persistent"))
              writer.uint32(/* id 3, wireType 0 =*/24).bool(message.persistent);
          if (message.peek != null && message.hasOwnProperty("peek"))
              writer.uint32(/* id 4, wireType 0 =*/32).bool(message.peek);
          if (message.bindCount != null && message.hasOwnProperty("bindCount"))
              writer.uint32(/* id 5, wireType 0 =*/40).int32(message.bindCount);
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 7, wireType 0 =*/56).bool(message.connective_used);
          return writer;
      };

      /**
       * Encodes the specified Receive message, length delimited. Does not implicitly {@link Receive.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Receive
       * @static
       * @param {IReceive} message Receive message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Receive.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Receive message from the specified reader or buffer.
       * @function decode
       * @memberof Receive
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Receive} Receive
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Receive.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Receive();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.binds && message.binds.length))
                      message.binds = [];
                  message.binds.push($root.ReceiveBind.decode(reader, reader.uint32()));
                  break;
              case 2:
                  message.body = $root.Par.decode(reader, reader.uint32());
                  break;
              case 3:
                  message.persistent = reader.bool();
                  break;
              case 4:
                  message.peek = reader.bool();
                  break;
              case 5:
                  message.bindCount = reader.int32();
                  break;
              case 6:
                  message.locallyFree = reader.bytes();
                  break;
              case 7:
                  message.connective_used = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Receive message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Receive
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Receive} Receive
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Receive.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Receive message.
       * @function verify
       * @memberof Receive
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Receive.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.binds != null && message.hasOwnProperty("binds")) {
              if (!Array.isArray(message.binds))
                  return "binds: array expected";
              for (var i = 0; i < message.binds.length; ++i) {
                  var error = $root.ReceiveBind.verify(message.binds[i]);
                  if (error)
                      return "binds." + error;
              }
          }
          if (message.body != null && message.hasOwnProperty("body")) {
              var error = $root.Par.verify(message.body);
              if (error)
                  return "body." + error;
          }
          if (message.persistent != null && message.hasOwnProperty("persistent"))
              if (typeof message.persistent !== "boolean")
                  return "persistent: boolean expected";
          if (message.peek != null && message.hasOwnProperty("peek"))
              if (typeof message.peek !== "boolean")
                  return "peek: boolean expected";
          if (message.bindCount != null && message.hasOwnProperty("bindCount"))
              if (!$util.isInteger(message.bindCount))
                  return "bindCount: integer expected";
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          return null;
      };

      /**
       * Creates a Receive message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Receive
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Receive} Receive
       */
      Receive.fromObject = function fromObject(object) {
          if (object instanceof $root.Receive)
              return object;
          var message = new $root.Receive();
          if (object.binds) {
              if (!Array.isArray(object.binds))
                  throw TypeError(".Receive.binds: array expected");
              message.binds = [];
              for (var i = 0; i < object.binds.length; ++i) {
                  if (typeof object.binds[i] !== "object")
                      throw TypeError(".Receive.binds: object expected");
                  message.binds[i] = $root.ReceiveBind.fromObject(object.binds[i]);
              }
          }
          if (object.body != null) {
              if (typeof object.body !== "object")
                  throw TypeError(".Receive.body: object expected");
              message.body = $root.Par.fromObject(object.body);
          }
          if (object.persistent != null)
              message.persistent = Boolean(object.persistent);
          if (object.peek != null)
              message.peek = Boolean(object.peek);
          if (object.bindCount != null)
              message.bindCount = object.bindCount | 0;
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          return message;
      };

      /**
       * Creates a plain object from a Receive message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Receive
       * @static
       * @param {Receive} message Receive
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Receive.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.binds = [];
          if (options.defaults) {
              object.body = null;
              object.persistent = false;
              object.peek = false;
              object.bindCount = 0;
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
          }
          if (message.binds && message.binds.length) {
              object.binds = [];
              for (var j = 0; j < message.binds.length; ++j)
                  object.binds[j] = $root.ReceiveBind.toObject(message.binds[j], options);
          }
          if (message.body != null && message.hasOwnProperty("body"))
              object.body = $root.Par.toObject(message.body, options);
          if (message.persistent != null && message.hasOwnProperty("persistent"))
              object.persistent = message.persistent;
          if (message.peek != null && message.hasOwnProperty("peek"))
              object.peek = message.peek;
          if (message.bindCount != null && message.hasOwnProperty("bindCount"))
              object.bindCount = message.bindCount;
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          return object;
      };

      /**
       * Converts this Receive to JSON.
       * @function toJSON
       * @memberof Receive
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Receive.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Receive;
  })();

  $root.New = (function() {

      /**
       * Properties of a New.
       * @exports INew
       * @interface INew
       * @property {number|null} [bindCount] New bindCount
       * @property {IPar|null} [p] New p
       * @property {Array.<string>|null} [uri] New uri
       * @property {Object.<string,IPar>|null} [injections] New injections
       * @property {Uint8Array|null} [locallyFree] New locallyFree
       */

      /**
       * Constructs a new New.
       * @exports New
       * @classdesc Represents a New.
       * @implements INew
       * @constructor
       * @param {INew=} [properties] Properties to set
       */
      function New(properties) {
          this.uri = [];
          this.injections = {};
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * New bindCount.
       * @member {number} bindCount
       * @memberof New
       * @instance
       */
      New.prototype.bindCount = 0;

      /**
       * New p.
       * @member {IPar|null|undefined} p
       * @memberof New
       * @instance
       */
      New.prototype.p = null;

      /**
       * New uri.
       * @member {Array.<string>} uri
       * @memberof New
       * @instance
       */
      New.prototype.uri = $util.emptyArray;

      /**
       * New injections.
       * @member {Object.<string,IPar>} injections
       * @memberof New
       * @instance
       */
      New.prototype.injections = $util.emptyObject;

      /**
       * New locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof New
       * @instance
       */
      New.prototype.locallyFree = $util.newBuffer([]);

      /**
       * Creates a new New instance using the specified properties.
       * @function create
       * @memberof New
       * @static
       * @param {INew=} [properties] Properties to set
       * @returns {New} New instance
       */
      New.create = function create(properties) {
          return new New(properties);
      };

      /**
       * Encodes the specified New message. Does not implicitly {@link New.verify|verify} messages.
       * @function encode
       * @memberof New
       * @static
       * @param {INew} message New message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      New.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.bindCount != null && message.hasOwnProperty("bindCount"))
              writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.bindCount);
          if (message.p != null && message.hasOwnProperty("p"))
              $root.Par.encode(message.p, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.uri != null && message.uri.length)
              for (var i = 0; i < message.uri.length; ++i)
                  writer.uint32(/* id 3, wireType 2 =*/26).string(message.uri[i]);
          if (message.injections != null && message.hasOwnProperty("injections"))
              for (var keys = Object.keys(message.injections), i = 0; i < keys.length; ++i) {
                  writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                  $root.Par.encode(message.injections[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
              }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.locallyFree);
          return writer;
      };

      /**
       * Encodes the specified New message, length delimited. Does not implicitly {@link New.verify|verify} messages.
       * @function encodeDelimited
       * @memberof New
       * @static
       * @param {INew} message New message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      New.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a New message from the specified reader or buffer.
       * @function decode
       * @memberof New
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {New} New
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      New.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.New(), key;
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.bindCount = reader.sint32();
                  break;
              case 2:
                  message.p = $root.Par.decode(reader, reader.uint32());
                  break;
              case 3:
                  if (!(message.uri && message.uri.length))
                      message.uri = [];
                  message.uri.push(reader.string());
                  break;
              case 4:
                  reader.skip().pos++;
                  if (message.injections === $util.emptyObject)
                      message.injections = {};
                  key = reader.string();
                  reader.pos++;
                  message.injections[key] = $root.Par.decode(reader, reader.uint32());
                  break;
              case 5:
                  message.locallyFree = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a New message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof New
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {New} New
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      New.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a New message.
       * @function verify
       * @memberof New
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      New.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.bindCount != null && message.hasOwnProperty("bindCount"))
              if (!$util.isInteger(message.bindCount))
                  return "bindCount: integer expected";
          if (message.p != null && message.hasOwnProperty("p")) {
              var error = $root.Par.verify(message.p);
              if (error)
                  return "p." + error;
          }
          if (message.uri != null && message.hasOwnProperty("uri")) {
              if (!Array.isArray(message.uri))
                  return "uri: array expected";
              for (var i = 0; i < message.uri.length; ++i)
                  if (!$util.isString(message.uri[i]))
                      return "uri: string[] expected";
          }
          if (message.injections != null && message.hasOwnProperty("injections")) {
              if (!$util.isObject(message.injections))
                  return "injections: object expected";
              var key = Object.keys(message.injections);
              for (var i = 0; i < key.length; ++i) {
                  var error = $root.Par.verify(message.injections[key[i]]);
                  if (error)
                      return "injections." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          return null;
      };

      /**
       * Creates a New message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof New
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {New} New
       */
      New.fromObject = function fromObject(object) {
          if (object instanceof $root.New)
              return object;
          var message = new $root.New();
          if (object.bindCount != null)
              message.bindCount = object.bindCount | 0;
          if (object.p != null) {
              if (typeof object.p !== "object")
                  throw TypeError(".New.p: object expected");
              message.p = $root.Par.fromObject(object.p);
          }
          if (object.uri) {
              if (!Array.isArray(object.uri))
                  throw TypeError(".New.uri: array expected");
              message.uri = [];
              for (var i = 0; i < object.uri.length; ++i)
                  message.uri[i] = String(object.uri[i]);
          }
          if (object.injections) {
              if (typeof object.injections !== "object")
                  throw TypeError(".New.injections: object expected");
              message.injections = {};
              for (var keys = Object.keys(object.injections), i = 0; i < keys.length; ++i) {
                  if (typeof object.injections[keys[i]] !== "object")
                      throw TypeError(".New.injections: object expected");
                  message.injections[keys[i]] = $root.Par.fromObject(object.injections[keys[i]]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          return message;
      };

      /**
       * Creates a plain object from a New message. Also converts values to other types if specified.
       * @function toObject
       * @memberof New
       * @static
       * @param {New} message New
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      New.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.uri = [];
          if (options.objects || options.defaults)
              object.injections = {};
          if (options.defaults) {
              object.bindCount = 0;
              object.p = null;
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
          }
          if (message.bindCount != null && message.hasOwnProperty("bindCount"))
              object.bindCount = message.bindCount;
          if (message.p != null && message.hasOwnProperty("p"))
              object.p = $root.Par.toObject(message.p, options);
          if (message.uri && message.uri.length) {
              object.uri = [];
              for (var j = 0; j < message.uri.length; ++j)
                  object.uri[j] = message.uri[j];
          }
          var keys2;
          if (message.injections && (keys2 = Object.keys(message.injections)).length) {
              object.injections = {};
              for (var j = 0; j < keys2.length; ++j)
                  object.injections[keys2[j]] = $root.Par.toObject(message.injections[keys2[j]], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          return object;
      };

      /**
       * Converts this New to JSON.
       * @function toJSON
       * @memberof New
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      New.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return New;
  })();

  $root.MatchCase = (function() {

      /**
       * Properties of a MatchCase.
       * @exports IMatchCase
       * @interface IMatchCase
       * @property {IPar|null} [pattern] MatchCase pattern
       * @property {IPar|null} [source] MatchCase source
       * @property {number|null} [freeCount] MatchCase freeCount
       */

      /**
       * Constructs a new MatchCase.
       * @exports MatchCase
       * @classdesc Represents a MatchCase.
       * @implements IMatchCase
       * @constructor
       * @param {IMatchCase=} [properties] Properties to set
       */
      function MatchCase(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * MatchCase pattern.
       * @member {IPar|null|undefined} pattern
       * @memberof MatchCase
       * @instance
       */
      MatchCase.prototype.pattern = null;

      /**
       * MatchCase source.
       * @member {IPar|null|undefined} source
       * @memberof MatchCase
       * @instance
       */
      MatchCase.prototype.source = null;

      /**
       * MatchCase freeCount.
       * @member {number} freeCount
       * @memberof MatchCase
       * @instance
       */
      MatchCase.prototype.freeCount = 0;

      /**
       * Creates a new MatchCase instance using the specified properties.
       * @function create
       * @memberof MatchCase
       * @static
       * @param {IMatchCase=} [properties] Properties to set
       * @returns {MatchCase} MatchCase instance
       */
      MatchCase.create = function create(properties) {
          return new MatchCase(properties);
      };

      /**
       * Encodes the specified MatchCase message. Does not implicitly {@link MatchCase.verify|verify} messages.
       * @function encode
       * @memberof MatchCase
       * @static
       * @param {IMatchCase} message MatchCase message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MatchCase.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.pattern != null && message.hasOwnProperty("pattern"))
              $root.Par.encode(message.pattern, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.source != null && message.hasOwnProperty("source"))
              $root.Par.encode(message.source, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              writer.uint32(/* id 3, wireType 0 =*/24).int32(message.freeCount);
          return writer;
      };

      /**
       * Encodes the specified MatchCase message, length delimited. Does not implicitly {@link MatchCase.verify|verify} messages.
       * @function encodeDelimited
       * @memberof MatchCase
       * @static
       * @param {IMatchCase} message MatchCase message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MatchCase.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MatchCase message from the specified reader or buffer.
       * @function decode
       * @memberof MatchCase
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {MatchCase} MatchCase
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MatchCase.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MatchCase();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.pattern = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.source = $root.Par.decode(reader, reader.uint32());
                  break;
              case 3:
                  message.freeCount = reader.int32();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a MatchCase message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof MatchCase
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {MatchCase} MatchCase
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MatchCase.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MatchCase message.
       * @function verify
       * @memberof MatchCase
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MatchCase.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.pattern != null && message.hasOwnProperty("pattern")) {
              var error = $root.Par.verify(message.pattern);
              if (error)
                  return "pattern." + error;
          }
          if (message.source != null && message.hasOwnProperty("source")) {
              var error = $root.Par.verify(message.source);
              if (error)
                  return "source." + error;
          }
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              if (!$util.isInteger(message.freeCount))
                  return "freeCount: integer expected";
          return null;
      };

      /**
       * Creates a MatchCase message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof MatchCase
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {MatchCase} MatchCase
       */
      MatchCase.fromObject = function fromObject(object) {
          if (object instanceof $root.MatchCase)
              return object;
          var message = new $root.MatchCase();
          if (object.pattern != null) {
              if (typeof object.pattern !== "object")
                  throw TypeError(".MatchCase.pattern: object expected");
              message.pattern = $root.Par.fromObject(object.pattern);
          }
          if (object.source != null) {
              if (typeof object.source !== "object")
                  throw TypeError(".MatchCase.source: object expected");
              message.source = $root.Par.fromObject(object.source);
          }
          if (object.freeCount != null)
              message.freeCount = object.freeCount | 0;
          return message;
      };

      /**
       * Creates a plain object from a MatchCase message. Also converts values to other types if specified.
       * @function toObject
       * @memberof MatchCase
       * @static
       * @param {MatchCase} message MatchCase
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MatchCase.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.pattern = null;
              object.source = null;
              object.freeCount = 0;
          }
          if (message.pattern != null && message.hasOwnProperty("pattern"))
              object.pattern = $root.Par.toObject(message.pattern, options);
          if (message.source != null && message.hasOwnProperty("source"))
              object.source = $root.Par.toObject(message.source, options);
          if (message.freeCount != null && message.hasOwnProperty("freeCount"))
              object.freeCount = message.freeCount;
          return object;
      };

      /**
       * Converts this MatchCase to JSON.
       * @function toJSON
       * @memberof MatchCase
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MatchCase.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return MatchCase;
  })();

  $root.Match = (function() {

      /**
       * Properties of a Match.
       * @exports IMatch
       * @interface IMatch
       * @property {IPar|null} [target] Match target
       * @property {Array.<IMatchCase>|null} [cases] Match cases
       * @property {Uint8Array|null} [locallyFree] Match locallyFree
       * @property {boolean|null} [connective_used] Match connective_used
       */

      /**
       * Constructs a new Match.
       * @exports Match
       * @classdesc Represents a Match.
       * @implements IMatch
       * @constructor
       * @param {IMatch=} [properties] Properties to set
       */
      function Match(properties) {
          this.cases = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Match target.
       * @member {IPar|null|undefined} target
       * @memberof Match
       * @instance
       */
      Match.prototype.target = null;

      /**
       * Match cases.
       * @member {Array.<IMatchCase>} cases
       * @memberof Match
       * @instance
       */
      Match.prototype.cases = $util.emptyArray;

      /**
       * Match locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof Match
       * @instance
       */
      Match.prototype.locallyFree = $util.newBuffer([]);

      /**
       * Match connective_used.
       * @member {boolean} connective_used
       * @memberof Match
       * @instance
       */
      Match.prototype.connective_used = false;

      /**
       * Creates a new Match instance using the specified properties.
       * @function create
       * @memberof Match
       * @static
       * @param {IMatch=} [properties] Properties to set
       * @returns {Match} Match instance
       */
      Match.create = function create(properties) {
          return new Match(properties);
      };

      /**
       * Encodes the specified Match message. Does not implicitly {@link Match.verify|verify} messages.
       * @function encode
       * @memberof Match
       * @static
       * @param {IMatch} message Match message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Match.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.target != null && message.hasOwnProperty("target"))
              $root.Par.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.cases != null && message.cases.length)
              for (var i = 0; i < message.cases.length; ++i)
                  $root.MatchCase.encode(message.cases[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 5, wireType 0 =*/40).bool(message.connective_used);
          return writer;
      };

      /**
       * Encodes the specified Match message, length delimited. Does not implicitly {@link Match.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Match
       * @static
       * @param {IMatch} message Match message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Match.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Match message from the specified reader or buffer.
       * @function decode
       * @memberof Match
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Match} Match
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Match.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Match();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.target = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  if (!(message.cases && message.cases.length))
                      message.cases = [];
                  message.cases.push($root.MatchCase.decode(reader, reader.uint32()));
                  break;
              case 4:
                  message.locallyFree = reader.bytes();
                  break;
              case 5:
                  message.connective_used = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Match message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Match
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Match} Match
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Match.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Match message.
       * @function verify
       * @memberof Match
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Match.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.target != null && message.hasOwnProperty("target")) {
              var error = $root.Par.verify(message.target);
              if (error)
                  return "target." + error;
          }
          if (message.cases != null && message.hasOwnProperty("cases")) {
              if (!Array.isArray(message.cases))
                  return "cases: array expected";
              for (var i = 0; i < message.cases.length; ++i) {
                  var error = $root.MatchCase.verify(message.cases[i]);
                  if (error)
                      return "cases." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          return null;
      };

      /**
       * Creates a Match message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Match
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Match} Match
       */
      Match.fromObject = function fromObject(object) {
          if (object instanceof $root.Match)
              return object;
          var message = new $root.Match();
          if (object.target != null) {
              if (typeof object.target !== "object")
                  throw TypeError(".Match.target: object expected");
              message.target = $root.Par.fromObject(object.target);
          }
          if (object.cases) {
              if (!Array.isArray(object.cases))
                  throw TypeError(".Match.cases: array expected");
              message.cases = [];
              for (var i = 0; i < object.cases.length; ++i) {
                  if (typeof object.cases[i] !== "object")
                      throw TypeError(".Match.cases: object expected");
                  message.cases[i] = $root.MatchCase.fromObject(object.cases[i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          return message;
      };

      /**
       * Creates a plain object from a Match message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Match
       * @static
       * @param {Match} message Match
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Match.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.cases = [];
          if (options.defaults) {
              object.target = null;
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
          }
          if (message.target != null && message.hasOwnProperty("target"))
              object.target = $root.Par.toObject(message.target, options);
          if (message.cases && message.cases.length) {
              object.cases = [];
              for (var j = 0; j < message.cases.length; ++j)
                  object.cases[j] = $root.MatchCase.toObject(message.cases[j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          return object;
      };

      /**
       * Converts this Match to JSON.
       * @function toJSON
       * @memberof Match
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Match.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Match;
  })();

  $root.Expr = (function() {

      /**
       * Properties of an Expr.
       * @exports IExpr
       * @interface IExpr
       * @property {boolean|null} [g_bool] Expr g_bool
       * @property {number|Long|null} [g_int] Expr g_int
       * @property {string|null} [g_string] Expr g_string
       * @property {string|null} [g_uri] Expr g_uri
       * @property {Uint8Array|null} [g_byte_array] Expr g_byte_array
       * @property {IENot|null} [e_not_body] Expr e_not_body
       * @property {IENeg|null} [e_neg_body] Expr e_neg_body
       * @property {IEMult|null} [e_mult_body] Expr e_mult_body
       * @property {IEDiv|null} [e_div_body] Expr e_div_body
       * @property {IEPlus|null} [e_plus_body] Expr e_plus_body
       * @property {IEMinus|null} [e_minus_body] Expr e_minus_body
       * @property {IELt|null} [e_lt_body] Expr e_lt_body
       * @property {IELte|null} [e_lte_body] Expr e_lte_body
       * @property {IEGt|null} [e_gt_body] Expr e_gt_body
       * @property {IEGte|null} [e_gte_body] Expr e_gte_body
       * @property {IEEq|null} [e_eq_body] Expr e_eq_body
       * @property {IENeq|null} [e_neq_body] Expr e_neq_body
       * @property {IEAnd|null} [e_and_body] Expr e_and_body
       * @property {IEOr|null} [e_or_body] Expr e_or_body
       * @property {IEVar|null} [e_var_body] Expr e_var_body
       * @property {IEList|null} [e_list_body] Expr e_list_body
       * @property {IETuple|null} [e_tuple_body] Expr e_tuple_body
       * @property {IESet|null} [e_set_body] Expr e_set_body
       * @property {IEMap|null} [e_map_body] Expr e_map_body
       * @property {IEMethod|null} [e_method_body] Expr e_method_body
       * @property {IEMatches|null} [e_matches_body] Expr e_matches_body
       * @property {IEPercentPercent|null} [e_percent_percent_body] Expr e_percent_percent_body
       * @property {IEPlusPlus|null} [e_plus_plus_body] Expr e_plus_plus_body
       * @property {IEMinusMinus|null} [e_minus_minus_body] Expr e_minus_minus_body
       * @property {IEMod|null} [e_mod_body] Expr e_mod_body
       */

      /**
       * Constructs a new Expr.
       * @exports Expr
       * @classdesc Represents an Expr.
       * @implements IExpr
       * @constructor
       * @param {IExpr=} [properties] Properties to set
       */
      function Expr(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Expr g_bool.
       * @member {boolean} g_bool
       * @memberof Expr
       * @instance
       */
      Expr.prototype.g_bool = false;

      /**
       * Expr g_int.
       * @member {number|Long} g_int
       * @memberof Expr
       * @instance
       */
      Expr.prototype.g_int = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

      /**
       * Expr g_string.
       * @member {string} g_string
       * @memberof Expr
       * @instance
       */
      Expr.prototype.g_string = "";

      /**
       * Expr g_uri.
       * @member {string} g_uri
       * @memberof Expr
       * @instance
       */
      Expr.prototype.g_uri = "";

      /**
       * Expr g_byte_array.
       * @member {Uint8Array} g_byte_array
       * @memberof Expr
       * @instance
       */
      Expr.prototype.g_byte_array = $util.newBuffer([]);

      /**
       * Expr e_not_body.
       * @member {IENot|null|undefined} e_not_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_not_body = null;

      /**
       * Expr e_neg_body.
       * @member {IENeg|null|undefined} e_neg_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_neg_body = null;

      /**
       * Expr e_mult_body.
       * @member {IEMult|null|undefined} e_mult_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_mult_body = null;

      /**
       * Expr e_div_body.
       * @member {IEDiv|null|undefined} e_div_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_div_body = null;

      /**
       * Expr e_plus_body.
       * @member {IEPlus|null|undefined} e_plus_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_plus_body = null;

      /**
       * Expr e_minus_body.
       * @member {IEMinus|null|undefined} e_minus_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_minus_body = null;

      /**
       * Expr e_lt_body.
       * @member {IELt|null|undefined} e_lt_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_lt_body = null;

      /**
       * Expr e_lte_body.
       * @member {IELte|null|undefined} e_lte_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_lte_body = null;

      /**
       * Expr e_gt_body.
       * @member {IEGt|null|undefined} e_gt_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_gt_body = null;

      /**
       * Expr e_gte_body.
       * @member {IEGte|null|undefined} e_gte_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_gte_body = null;

      /**
       * Expr e_eq_body.
       * @member {IEEq|null|undefined} e_eq_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_eq_body = null;

      /**
       * Expr e_neq_body.
       * @member {IENeq|null|undefined} e_neq_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_neq_body = null;

      /**
       * Expr e_and_body.
       * @member {IEAnd|null|undefined} e_and_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_and_body = null;

      /**
       * Expr e_or_body.
       * @member {IEOr|null|undefined} e_or_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_or_body = null;

      /**
       * Expr e_var_body.
       * @member {IEVar|null|undefined} e_var_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_var_body = null;

      /**
       * Expr e_list_body.
       * @member {IEList|null|undefined} e_list_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_list_body = null;

      /**
       * Expr e_tuple_body.
       * @member {IETuple|null|undefined} e_tuple_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_tuple_body = null;

      /**
       * Expr e_set_body.
       * @member {IESet|null|undefined} e_set_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_set_body = null;

      /**
       * Expr e_map_body.
       * @member {IEMap|null|undefined} e_map_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_map_body = null;

      /**
       * Expr e_method_body.
       * @member {IEMethod|null|undefined} e_method_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_method_body = null;

      /**
       * Expr e_matches_body.
       * @member {IEMatches|null|undefined} e_matches_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_matches_body = null;

      /**
       * Expr e_percent_percent_body.
       * @member {IEPercentPercent|null|undefined} e_percent_percent_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_percent_percent_body = null;

      /**
       * Expr e_plus_plus_body.
       * @member {IEPlusPlus|null|undefined} e_plus_plus_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_plus_plus_body = null;

      /**
       * Expr e_minus_minus_body.
       * @member {IEMinusMinus|null|undefined} e_minus_minus_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_minus_minus_body = null;

      /**
       * Expr e_mod_body.
       * @member {IEMod|null|undefined} e_mod_body
       * @memberof Expr
       * @instance
       */
      Expr.prototype.e_mod_body = null;

      // OneOf field names bound to virtual getters and setters
      var $oneOfFields;

      /**
       * Expr expr_instance.
       * @member {"g_bool"|"g_int"|"g_string"|"g_uri"|"g_byte_array"|"e_not_body"|"e_neg_body"|"e_mult_body"|"e_div_body"|"e_plus_body"|"e_minus_body"|"e_lt_body"|"e_lte_body"|"e_gt_body"|"e_gte_body"|"e_eq_body"|"e_neq_body"|"e_and_body"|"e_or_body"|"e_var_body"|"e_list_body"|"e_tuple_body"|"e_set_body"|"e_map_body"|"e_method_body"|"e_matches_body"|"e_percent_percent_body"|"e_plus_plus_body"|"e_minus_minus_body"|"e_mod_body"|undefined} expr_instance
       * @memberof Expr
       * @instance
       */
      Object.defineProperty(Expr.prototype, "expr_instance", {
          get: $util.oneOfGetter($oneOfFields = ["g_bool", "g_int", "g_string", "g_uri", "g_byte_array", "e_not_body", "e_neg_body", "e_mult_body", "e_div_body", "e_plus_body", "e_minus_body", "e_lt_body", "e_lte_body", "e_gt_body", "e_gte_body", "e_eq_body", "e_neq_body", "e_and_body", "e_or_body", "e_var_body", "e_list_body", "e_tuple_body", "e_set_body", "e_map_body", "e_method_body", "e_matches_body", "e_percent_percent_body", "e_plus_plus_body", "e_minus_minus_body", "e_mod_body"]),
          set: $util.oneOfSetter($oneOfFields)
      });

      /**
       * Creates a new Expr instance using the specified properties.
       * @function create
       * @memberof Expr
       * @static
       * @param {IExpr=} [properties] Properties to set
       * @returns {Expr} Expr instance
       */
      Expr.create = function create(properties) {
          return new Expr(properties);
      };

      /**
       * Encodes the specified Expr message. Does not implicitly {@link Expr.verify|verify} messages.
       * @function encode
       * @memberof Expr
       * @static
       * @param {IExpr} message Expr message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Expr.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.g_bool != null && message.hasOwnProperty("g_bool"))
              writer.uint32(/* id 1, wireType 0 =*/8).bool(message.g_bool);
          if (message.g_int != null && message.hasOwnProperty("g_int"))
              writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.g_int);
          if (message.g_string != null && message.hasOwnProperty("g_string"))
              writer.uint32(/* id 3, wireType 2 =*/26).string(message.g_string);
          if (message.g_uri != null && message.hasOwnProperty("g_uri"))
              writer.uint32(/* id 4, wireType 2 =*/34).string(message.g_uri);
          if (message.e_not_body != null && message.hasOwnProperty("e_not_body"))
              $root.ENot.encode(message.e_not_body, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
          if (message.e_neg_body != null && message.hasOwnProperty("e_neg_body"))
              $root.ENeg.encode(message.e_neg_body, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
          if (message.e_mult_body != null && message.hasOwnProperty("e_mult_body"))
              $root.EMult.encode(message.e_mult_body, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
          if (message.e_div_body != null && message.hasOwnProperty("e_div_body"))
              $root.EDiv.encode(message.e_div_body, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
          if (message.e_plus_body != null && message.hasOwnProperty("e_plus_body"))
              $root.EPlus.encode(message.e_plus_body, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
          if (message.e_minus_body != null && message.hasOwnProperty("e_minus_body"))
              $root.EMinus.encode(message.e_minus_body, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
          if (message.e_lt_body != null && message.hasOwnProperty("e_lt_body"))
              $root.ELt.encode(message.e_lt_body, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
          if (message.e_lte_body != null && message.hasOwnProperty("e_lte_body"))
              $root.ELte.encode(message.e_lte_body, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
          if (message.e_gt_body != null && message.hasOwnProperty("e_gt_body"))
              $root.EGt.encode(message.e_gt_body, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
          if (message.e_gte_body != null && message.hasOwnProperty("e_gte_body"))
              $root.EGte.encode(message.e_gte_body, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
          if (message.e_eq_body != null && message.hasOwnProperty("e_eq_body"))
              $root.EEq.encode(message.e_eq_body, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
          if (message.e_neq_body != null && message.hasOwnProperty("e_neq_body"))
              $root.ENeq.encode(message.e_neq_body, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
          if (message.e_and_body != null && message.hasOwnProperty("e_and_body"))
              $root.EAnd.encode(message.e_and_body, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
          if (message.e_or_body != null && message.hasOwnProperty("e_or_body"))
              $root.EOr.encode(message.e_or_body, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
          if (message.e_var_body != null && message.hasOwnProperty("e_var_body"))
              $root.EVar.encode(message.e_var_body, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
          if (message.e_list_body != null && message.hasOwnProperty("e_list_body"))
              $root.EList.encode(message.e_list_body, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
          if (message.e_tuple_body != null && message.hasOwnProperty("e_tuple_body"))
              $root.ETuple.encode(message.e_tuple_body, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
          if (message.e_set_body != null && message.hasOwnProperty("e_set_body"))
              $root.ESet.encode(message.e_set_body, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
          if (message.e_map_body != null && message.hasOwnProperty("e_map_body"))
              $root.EMap.encode(message.e_map_body, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
          if (message.e_method_body != null && message.hasOwnProperty("e_method_body"))
              $root.EMethod.encode(message.e_method_body, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
          if (message.g_byte_array != null && message.hasOwnProperty("g_byte_array"))
              writer.uint32(/* id 25, wireType 2 =*/202).bytes(message.g_byte_array);
          if (message.e_matches_body != null && message.hasOwnProperty("e_matches_body"))
              $root.EMatches.encode(message.e_matches_body, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
          if (message.e_percent_percent_body != null && message.hasOwnProperty("e_percent_percent_body"))
              $root.EPercentPercent.encode(message.e_percent_percent_body, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
          if (message.e_plus_plus_body != null && message.hasOwnProperty("e_plus_plus_body"))
              $root.EPlusPlus.encode(message.e_plus_plus_body, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
          if (message.e_minus_minus_body != null && message.hasOwnProperty("e_minus_minus_body"))
              $root.EMinusMinus.encode(message.e_minus_minus_body, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
          if (message.e_mod_body != null && message.hasOwnProperty("e_mod_body"))
              $root.EMod.encode(message.e_mod_body, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified Expr message, length delimited. Does not implicitly {@link Expr.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Expr
       * @static
       * @param {IExpr} message Expr message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Expr.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an Expr message from the specified reader or buffer.
       * @function decode
       * @memberof Expr
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Expr} Expr
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Expr.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Expr();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.g_bool = reader.bool();
                  break;
              case 2:
                  message.g_int = reader.sint64();
                  break;
              case 3:
                  message.g_string = reader.string();
                  break;
              case 4:
                  message.g_uri = reader.string();
                  break;
              case 25:
                  message.g_byte_array = reader.bytes();
                  break;
              case 5:
                  message.e_not_body = $root.ENot.decode(reader, reader.uint32());
                  break;
              case 6:
                  message.e_neg_body = $root.ENeg.decode(reader, reader.uint32());
                  break;
              case 7:
                  message.e_mult_body = $root.EMult.decode(reader, reader.uint32());
                  break;
              case 8:
                  message.e_div_body = $root.EDiv.decode(reader, reader.uint32());
                  break;
              case 9:
                  message.e_plus_body = $root.EPlus.decode(reader, reader.uint32());
                  break;
              case 10:
                  message.e_minus_body = $root.EMinus.decode(reader, reader.uint32());
                  break;
              case 11:
                  message.e_lt_body = $root.ELt.decode(reader, reader.uint32());
                  break;
              case 12:
                  message.e_lte_body = $root.ELte.decode(reader, reader.uint32());
                  break;
              case 13:
                  message.e_gt_body = $root.EGt.decode(reader, reader.uint32());
                  break;
              case 14:
                  message.e_gte_body = $root.EGte.decode(reader, reader.uint32());
                  break;
              case 15:
                  message.e_eq_body = $root.EEq.decode(reader, reader.uint32());
                  break;
              case 16:
                  message.e_neq_body = $root.ENeq.decode(reader, reader.uint32());
                  break;
              case 17:
                  message.e_and_body = $root.EAnd.decode(reader, reader.uint32());
                  break;
              case 18:
                  message.e_or_body = $root.EOr.decode(reader, reader.uint32());
                  break;
              case 19:
                  message.e_var_body = $root.EVar.decode(reader, reader.uint32());
                  break;
              case 20:
                  message.e_list_body = $root.EList.decode(reader, reader.uint32());
                  break;
              case 21:
                  message.e_tuple_body = $root.ETuple.decode(reader, reader.uint32());
                  break;
              case 22:
                  message.e_set_body = $root.ESet.decode(reader, reader.uint32());
                  break;
              case 23:
                  message.e_map_body = $root.EMap.decode(reader, reader.uint32());
                  break;
              case 24:
                  message.e_method_body = $root.EMethod.decode(reader, reader.uint32());
                  break;
              case 27:
                  message.e_matches_body = $root.EMatches.decode(reader, reader.uint32());
                  break;
              case 28:
                  message.e_percent_percent_body = $root.EPercentPercent.decode(reader, reader.uint32());
                  break;
              case 29:
                  message.e_plus_plus_body = $root.EPlusPlus.decode(reader, reader.uint32());
                  break;
              case 30:
                  message.e_minus_minus_body = $root.EMinusMinus.decode(reader, reader.uint32());
                  break;
              case 31:
                  message.e_mod_body = $root.EMod.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes an Expr message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Expr
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Expr} Expr
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Expr.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an Expr message.
       * @function verify
       * @memberof Expr
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Expr.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          var properties = {};
          if (message.g_bool != null && message.hasOwnProperty("g_bool")) {
              properties.expr_instance = 1;
              if (typeof message.g_bool !== "boolean")
                  return "g_bool: boolean expected";
          }
          if (message.g_int != null && message.hasOwnProperty("g_int")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              if (!$util.isInteger(message.g_int) && !(message.g_int && $util.isInteger(message.g_int.low) && $util.isInteger(message.g_int.high)))
                  return "g_int: integer|Long expected";
          }
          if (message.g_string != null && message.hasOwnProperty("g_string")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              if (!$util.isString(message.g_string))
                  return "g_string: string expected";
          }
          if (message.g_uri != null && message.hasOwnProperty("g_uri")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              if (!$util.isString(message.g_uri))
                  return "g_uri: string expected";
          }
          if (message.g_byte_array != null && message.hasOwnProperty("g_byte_array")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              if (!(message.g_byte_array && typeof message.g_byte_array.length === "number" || $util.isString(message.g_byte_array)))
                  return "g_byte_array: buffer expected";
          }
          if (message.e_not_body != null && message.hasOwnProperty("e_not_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ENot.verify(message.e_not_body);
                  if (error)
                      return "e_not_body." + error;
              }
          }
          if (message.e_neg_body != null && message.hasOwnProperty("e_neg_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ENeg.verify(message.e_neg_body);
                  if (error)
                      return "e_neg_body." + error;
              }
          }
          if (message.e_mult_body != null && message.hasOwnProperty("e_mult_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMult.verify(message.e_mult_body);
                  if (error)
                      return "e_mult_body." + error;
              }
          }
          if (message.e_div_body != null && message.hasOwnProperty("e_div_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EDiv.verify(message.e_div_body);
                  if (error)
                      return "e_div_body." + error;
              }
          }
          if (message.e_plus_body != null && message.hasOwnProperty("e_plus_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EPlus.verify(message.e_plus_body);
                  if (error)
                      return "e_plus_body." + error;
              }
          }
          if (message.e_minus_body != null && message.hasOwnProperty("e_minus_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMinus.verify(message.e_minus_body);
                  if (error)
                      return "e_minus_body." + error;
              }
          }
          if (message.e_lt_body != null && message.hasOwnProperty("e_lt_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ELt.verify(message.e_lt_body);
                  if (error)
                      return "e_lt_body." + error;
              }
          }
          if (message.e_lte_body != null && message.hasOwnProperty("e_lte_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ELte.verify(message.e_lte_body);
                  if (error)
                      return "e_lte_body." + error;
              }
          }
          if (message.e_gt_body != null && message.hasOwnProperty("e_gt_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EGt.verify(message.e_gt_body);
                  if (error)
                      return "e_gt_body." + error;
              }
          }
          if (message.e_gte_body != null && message.hasOwnProperty("e_gte_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EGte.verify(message.e_gte_body);
                  if (error)
                      return "e_gte_body." + error;
              }
          }
          if (message.e_eq_body != null && message.hasOwnProperty("e_eq_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EEq.verify(message.e_eq_body);
                  if (error)
                      return "e_eq_body." + error;
              }
          }
          if (message.e_neq_body != null && message.hasOwnProperty("e_neq_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ENeq.verify(message.e_neq_body);
                  if (error)
                      return "e_neq_body." + error;
              }
          }
          if (message.e_and_body != null && message.hasOwnProperty("e_and_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EAnd.verify(message.e_and_body);
                  if (error)
                      return "e_and_body." + error;
              }
          }
          if (message.e_or_body != null && message.hasOwnProperty("e_or_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EOr.verify(message.e_or_body);
                  if (error)
                      return "e_or_body." + error;
              }
          }
          if (message.e_var_body != null && message.hasOwnProperty("e_var_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EVar.verify(message.e_var_body);
                  if (error)
                      return "e_var_body." + error;
              }
          }
          if (message.e_list_body != null && message.hasOwnProperty("e_list_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EList.verify(message.e_list_body);
                  if (error)
                      return "e_list_body." + error;
              }
          }
          if (message.e_tuple_body != null && message.hasOwnProperty("e_tuple_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ETuple.verify(message.e_tuple_body);
                  if (error)
                      return "e_tuple_body." + error;
              }
          }
          if (message.e_set_body != null && message.hasOwnProperty("e_set_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.ESet.verify(message.e_set_body);
                  if (error)
                      return "e_set_body." + error;
              }
          }
          if (message.e_map_body != null && message.hasOwnProperty("e_map_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMap.verify(message.e_map_body);
                  if (error)
                      return "e_map_body." + error;
              }
          }
          if (message.e_method_body != null && message.hasOwnProperty("e_method_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMethod.verify(message.e_method_body);
                  if (error)
                      return "e_method_body." + error;
              }
          }
          if (message.e_matches_body != null && message.hasOwnProperty("e_matches_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMatches.verify(message.e_matches_body);
                  if (error)
                      return "e_matches_body." + error;
              }
          }
          if (message.e_percent_percent_body != null && message.hasOwnProperty("e_percent_percent_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EPercentPercent.verify(message.e_percent_percent_body);
                  if (error)
                      return "e_percent_percent_body." + error;
              }
          }
          if (message.e_plus_plus_body != null && message.hasOwnProperty("e_plus_plus_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EPlusPlus.verify(message.e_plus_plus_body);
                  if (error)
                      return "e_plus_plus_body." + error;
              }
          }
          if (message.e_minus_minus_body != null && message.hasOwnProperty("e_minus_minus_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMinusMinus.verify(message.e_minus_minus_body);
                  if (error)
                      return "e_minus_minus_body." + error;
              }
          }
          if (message.e_mod_body != null && message.hasOwnProperty("e_mod_body")) {
              if (properties.expr_instance === 1)
                  return "expr_instance: multiple values";
              properties.expr_instance = 1;
              {
                  var error = $root.EMod.verify(message.e_mod_body);
                  if (error)
                      return "e_mod_body." + error;
              }
          }
          return null;
      };

      /**
       * Creates an Expr message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Expr
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Expr} Expr
       */
      Expr.fromObject = function fromObject(object) {
          if (object instanceof $root.Expr)
              return object;
          var message = new $root.Expr();
          if (object.g_bool != null)
              message.g_bool = Boolean(object.g_bool);
          if (object.g_int != null)
              if ($util.Long)
                  (message.g_int = $util.Long.fromValue(object.g_int)).unsigned = false;
              else if (typeof object.g_int === "string")
                  message.g_int = parseInt(object.g_int, 10);
              else if (typeof object.g_int === "number")
                  message.g_int = object.g_int;
              else if (typeof object.g_int === "object")
                  message.g_int = new $util.LongBits(object.g_int.low >>> 0, object.g_int.high >>> 0).toNumber();
          if (object.g_string != null)
              message.g_string = String(object.g_string);
          if (object.g_uri != null)
              message.g_uri = String(object.g_uri);
          if (object.g_byte_array != null)
              if (typeof object.g_byte_array === "string")
                  $util.base64.decode(object.g_byte_array, message.g_byte_array = $util.newBuffer($util.base64.length(object.g_byte_array)), 0);
              else if (object.g_byte_array.length)
                  message.g_byte_array = object.g_byte_array;
          if (object.e_not_body != null) {
              if (typeof object.e_not_body !== "object")
                  throw TypeError(".Expr.e_not_body: object expected");
              message.e_not_body = $root.ENot.fromObject(object.e_not_body);
          }
          if (object.e_neg_body != null) {
              if (typeof object.e_neg_body !== "object")
                  throw TypeError(".Expr.e_neg_body: object expected");
              message.e_neg_body = $root.ENeg.fromObject(object.e_neg_body);
          }
          if (object.e_mult_body != null) {
              if (typeof object.e_mult_body !== "object")
                  throw TypeError(".Expr.e_mult_body: object expected");
              message.e_mult_body = $root.EMult.fromObject(object.e_mult_body);
          }
          if (object.e_div_body != null) {
              if (typeof object.e_div_body !== "object")
                  throw TypeError(".Expr.e_div_body: object expected");
              message.e_div_body = $root.EDiv.fromObject(object.e_div_body);
          }
          if (object.e_plus_body != null) {
              if (typeof object.e_plus_body !== "object")
                  throw TypeError(".Expr.e_plus_body: object expected");
              message.e_plus_body = $root.EPlus.fromObject(object.e_plus_body);
          }
          if (object.e_minus_body != null) {
              if (typeof object.e_minus_body !== "object")
                  throw TypeError(".Expr.e_minus_body: object expected");
              message.e_minus_body = $root.EMinus.fromObject(object.e_minus_body);
          }
          if (object.e_lt_body != null) {
              if (typeof object.e_lt_body !== "object")
                  throw TypeError(".Expr.e_lt_body: object expected");
              message.e_lt_body = $root.ELt.fromObject(object.e_lt_body);
          }
          if (object.e_lte_body != null) {
              if (typeof object.e_lte_body !== "object")
                  throw TypeError(".Expr.e_lte_body: object expected");
              message.e_lte_body = $root.ELte.fromObject(object.e_lte_body);
          }
          if (object.e_gt_body != null) {
              if (typeof object.e_gt_body !== "object")
                  throw TypeError(".Expr.e_gt_body: object expected");
              message.e_gt_body = $root.EGt.fromObject(object.e_gt_body);
          }
          if (object.e_gte_body != null) {
              if (typeof object.e_gte_body !== "object")
                  throw TypeError(".Expr.e_gte_body: object expected");
              message.e_gte_body = $root.EGte.fromObject(object.e_gte_body);
          }
          if (object.e_eq_body != null) {
              if (typeof object.e_eq_body !== "object")
                  throw TypeError(".Expr.e_eq_body: object expected");
              message.e_eq_body = $root.EEq.fromObject(object.e_eq_body);
          }
          if (object.e_neq_body != null) {
              if (typeof object.e_neq_body !== "object")
                  throw TypeError(".Expr.e_neq_body: object expected");
              message.e_neq_body = $root.ENeq.fromObject(object.e_neq_body);
          }
          if (object.e_and_body != null) {
              if (typeof object.e_and_body !== "object")
                  throw TypeError(".Expr.e_and_body: object expected");
              message.e_and_body = $root.EAnd.fromObject(object.e_and_body);
          }
          if (object.e_or_body != null) {
              if (typeof object.e_or_body !== "object")
                  throw TypeError(".Expr.e_or_body: object expected");
              message.e_or_body = $root.EOr.fromObject(object.e_or_body);
          }
          if (object.e_var_body != null) {
              if (typeof object.e_var_body !== "object")
                  throw TypeError(".Expr.e_var_body: object expected");
              message.e_var_body = $root.EVar.fromObject(object.e_var_body);
          }
          if (object.e_list_body != null) {
              if (typeof object.e_list_body !== "object")
                  throw TypeError(".Expr.e_list_body: object expected");
              message.e_list_body = $root.EList.fromObject(object.e_list_body);
          }
          if (object.e_tuple_body != null) {
              if (typeof object.e_tuple_body !== "object")
                  throw TypeError(".Expr.e_tuple_body: object expected");
              message.e_tuple_body = $root.ETuple.fromObject(object.e_tuple_body);
          }
          if (object.e_set_body != null) {
              if (typeof object.e_set_body !== "object")
                  throw TypeError(".Expr.e_set_body: object expected");
              message.e_set_body = $root.ESet.fromObject(object.e_set_body);
          }
          if (object.e_map_body != null) {
              if (typeof object.e_map_body !== "object")
                  throw TypeError(".Expr.e_map_body: object expected");
              message.e_map_body = $root.EMap.fromObject(object.e_map_body);
          }
          if (object.e_method_body != null) {
              if (typeof object.e_method_body !== "object")
                  throw TypeError(".Expr.e_method_body: object expected");
              message.e_method_body = $root.EMethod.fromObject(object.e_method_body);
          }
          if (object.e_matches_body != null) {
              if (typeof object.e_matches_body !== "object")
                  throw TypeError(".Expr.e_matches_body: object expected");
              message.e_matches_body = $root.EMatches.fromObject(object.e_matches_body);
          }
          if (object.e_percent_percent_body != null) {
              if (typeof object.e_percent_percent_body !== "object")
                  throw TypeError(".Expr.e_percent_percent_body: object expected");
              message.e_percent_percent_body = $root.EPercentPercent.fromObject(object.e_percent_percent_body);
          }
          if (object.e_plus_plus_body != null) {
              if (typeof object.e_plus_plus_body !== "object")
                  throw TypeError(".Expr.e_plus_plus_body: object expected");
              message.e_plus_plus_body = $root.EPlusPlus.fromObject(object.e_plus_plus_body);
          }
          if (object.e_minus_minus_body != null) {
              if (typeof object.e_minus_minus_body !== "object")
                  throw TypeError(".Expr.e_minus_minus_body: object expected");
              message.e_minus_minus_body = $root.EMinusMinus.fromObject(object.e_minus_minus_body);
          }
          if (object.e_mod_body != null) {
              if (typeof object.e_mod_body !== "object")
                  throw TypeError(".Expr.e_mod_body: object expected");
              message.e_mod_body = $root.EMod.fromObject(object.e_mod_body);
          }
          return message;
      };

      /**
       * Creates a plain object from an Expr message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Expr
       * @static
       * @param {Expr} message Expr
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Expr.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (message.g_bool != null && message.hasOwnProperty("g_bool")) {
              object.g_bool = message.g_bool;
              if (options.oneofs)
                  object.expr_instance = "g_bool";
          }
          if (message.g_int != null && message.hasOwnProperty("g_int")) {
              if (typeof message.g_int === "number")
                  object.g_int = options.longs === String ? String(message.g_int) : message.g_int;
              else
                  object.g_int = options.longs === String ? $util.Long.prototype.toString.call(message.g_int) : options.longs === Number ? new $util.LongBits(message.g_int.low >>> 0, message.g_int.high >>> 0).toNumber() : message.g_int;
              if (options.oneofs)
                  object.expr_instance = "g_int";
          }
          if (message.g_string != null && message.hasOwnProperty("g_string")) {
              object.g_string = message.g_string;
              if (options.oneofs)
                  object.expr_instance = "g_string";
          }
          if (message.g_uri != null && message.hasOwnProperty("g_uri")) {
              object.g_uri = message.g_uri;
              if (options.oneofs)
                  object.expr_instance = "g_uri";
          }
          if (message.e_not_body != null && message.hasOwnProperty("e_not_body")) {
              object.e_not_body = $root.ENot.toObject(message.e_not_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_not_body";
          }
          if (message.e_neg_body != null && message.hasOwnProperty("e_neg_body")) {
              object.e_neg_body = $root.ENeg.toObject(message.e_neg_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_neg_body";
          }
          if (message.e_mult_body != null && message.hasOwnProperty("e_mult_body")) {
              object.e_mult_body = $root.EMult.toObject(message.e_mult_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_mult_body";
          }
          if (message.e_div_body != null && message.hasOwnProperty("e_div_body")) {
              object.e_div_body = $root.EDiv.toObject(message.e_div_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_div_body";
          }
          if (message.e_plus_body != null && message.hasOwnProperty("e_plus_body")) {
              object.e_plus_body = $root.EPlus.toObject(message.e_plus_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_plus_body";
          }
          if (message.e_minus_body != null && message.hasOwnProperty("e_minus_body")) {
              object.e_minus_body = $root.EMinus.toObject(message.e_minus_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_minus_body";
          }
          if (message.e_lt_body != null && message.hasOwnProperty("e_lt_body")) {
              object.e_lt_body = $root.ELt.toObject(message.e_lt_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_lt_body";
          }
          if (message.e_lte_body != null && message.hasOwnProperty("e_lte_body")) {
              object.e_lte_body = $root.ELte.toObject(message.e_lte_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_lte_body";
          }
          if (message.e_gt_body != null && message.hasOwnProperty("e_gt_body")) {
              object.e_gt_body = $root.EGt.toObject(message.e_gt_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_gt_body";
          }
          if (message.e_gte_body != null && message.hasOwnProperty("e_gte_body")) {
              object.e_gte_body = $root.EGte.toObject(message.e_gte_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_gte_body";
          }
          if (message.e_eq_body != null && message.hasOwnProperty("e_eq_body")) {
              object.e_eq_body = $root.EEq.toObject(message.e_eq_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_eq_body";
          }
          if (message.e_neq_body != null && message.hasOwnProperty("e_neq_body")) {
              object.e_neq_body = $root.ENeq.toObject(message.e_neq_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_neq_body";
          }
          if (message.e_and_body != null && message.hasOwnProperty("e_and_body")) {
              object.e_and_body = $root.EAnd.toObject(message.e_and_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_and_body";
          }
          if (message.e_or_body != null && message.hasOwnProperty("e_or_body")) {
              object.e_or_body = $root.EOr.toObject(message.e_or_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_or_body";
          }
          if (message.e_var_body != null && message.hasOwnProperty("e_var_body")) {
              object.e_var_body = $root.EVar.toObject(message.e_var_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_var_body";
          }
          if (message.e_list_body != null && message.hasOwnProperty("e_list_body")) {
              object.e_list_body = $root.EList.toObject(message.e_list_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_list_body";
          }
          if (message.e_tuple_body != null && message.hasOwnProperty("e_tuple_body")) {
              object.e_tuple_body = $root.ETuple.toObject(message.e_tuple_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_tuple_body";
          }
          if (message.e_set_body != null && message.hasOwnProperty("e_set_body")) {
              object.e_set_body = $root.ESet.toObject(message.e_set_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_set_body";
          }
          if (message.e_map_body != null && message.hasOwnProperty("e_map_body")) {
              object.e_map_body = $root.EMap.toObject(message.e_map_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_map_body";
          }
          if (message.e_method_body != null && message.hasOwnProperty("e_method_body")) {
              object.e_method_body = $root.EMethod.toObject(message.e_method_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_method_body";
          }
          if (message.g_byte_array != null && message.hasOwnProperty("g_byte_array")) {
              object.g_byte_array = options.bytes === String ? $util.base64.encode(message.g_byte_array, 0, message.g_byte_array.length) : options.bytes === Array ? Array.prototype.slice.call(message.g_byte_array) : message.g_byte_array;
              if (options.oneofs)
                  object.expr_instance = "g_byte_array";
          }
          if (message.e_matches_body != null && message.hasOwnProperty("e_matches_body")) {
              object.e_matches_body = $root.EMatches.toObject(message.e_matches_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_matches_body";
          }
          if (message.e_percent_percent_body != null && message.hasOwnProperty("e_percent_percent_body")) {
              object.e_percent_percent_body = $root.EPercentPercent.toObject(message.e_percent_percent_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_percent_percent_body";
          }
          if (message.e_plus_plus_body != null && message.hasOwnProperty("e_plus_plus_body")) {
              object.e_plus_plus_body = $root.EPlusPlus.toObject(message.e_plus_plus_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_plus_plus_body";
          }
          if (message.e_minus_minus_body != null && message.hasOwnProperty("e_minus_minus_body")) {
              object.e_minus_minus_body = $root.EMinusMinus.toObject(message.e_minus_minus_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_minus_minus_body";
          }
          if (message.e_mod_body != null && message.hasOwnProperty("e_mod_body")) {
              object.e_mod_body = $root.EMod.toObject(message.e_mod_body, options);
              if (options.oneofs)
                  object.expr_instance = "e_mod_body";
          }
          return object;
      };

      /**
       * Converts this Expr to JSON.
       * @function toJSON
       * @memberof Expr
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Expr.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Expr;
  })();

  $root.EList = (function() {

      /**
       * Properties of a EList.
       * @exports IEList
       * @interface IEList
       * @property {Array.<IPar>|null} [ps] EList ps
       * @property {Uint8Array|null} [locallyFree] EList locallyFree
       * @property {boolean|null} [connective_used] EList connective_used
       * @property {IVar|null} [remainder] EList remainder
       */

      /**
       * Constructs a new EList.
       * @exports EList
       * @classdesc Represents a EList.
       * @implements IEList
       * @constructor
       * @param {IEList=} [properties] Properties to set
       */
      function EList(properties) {
          this.ps = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EList ps.
       * @member {Array.<IPar>} ps
       * @memberof EList
       * @instance
       */
      EList.prototype.ps = $util.emptyArray;

      /**
       * EList locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof EList
       * @instance
       */
      EList.prototype.locallyFree = $util.newBuffer([]);

      /**
       * EList connective_used.
       * @member {boolean} connective_used
       * @memberof EList
       * @instance
       */
      EList.prototype.connective_used = false;

      /**
       * EList remainder.
       * @member {IVar|null|undefined} remainder
       * @memberof EList
       * @instance
       */
      EList.prototype.remainder = null;

      /**
       * Creates a new EList instance using the specified properties.
       * @function create
       * @memberof EList
       * @static
       * @param {IEList=} [properties] Properties to set
       * @returns {EList} EList instance
       */
      EList.create = function create(properties) {
          return new EList(properties);
      };

      /**
       * Encodes the specified EList message. Does not implicitly {@link EList.verify|verify} messages.
       * @function encode
       * @memberof EList
       * @static
       * @param {IEList} message EList message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EList.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.ps != null && message.ps.length)
              for (var i = 0; i < message.ps.length; ++i)
                  $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              $root.Var.encode(message.remainder, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EList message, length delimited. Does not implicitly {@link EList.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EList
       * @static
       * @param {IEList} message EList message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EList.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EList message from the specified reader or buffer.
       * @function decode
       * @memberof EList
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EList} EList
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EList.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EList();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.ps && message.ps.length))
                      message.ps = [];
                  message.ps.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 3:
                  message.locallyFree = reader.bytes();
                  break;
              case 4:
                  message.connective_used = reader.bool();
                  break;
              case 5:
                  message.remainder = $root.Var.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EList message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EList
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EList} EList
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EList.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EList message.
       * @function verify
       * @memberof EList
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EList.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.ps != null && message.hasOwnProperty("ps")) {
              if (!Array.isArray(message.ps))
                  return "ps: array expected";
              for (var i = 0; i < message.ps.length; ++i) {
                  var error = $root.Par.verify(message.ps[i]);
                  if (error)
                      return "ps." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          if (message.remainder != null && message.hasOwnProperty("remainder")) {
              var error = $root.Var.verify(message.remainder);
              if (error)
                  return "remainder." + error;
          }
          return null;
      };

      /**
       * Creates a EList message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EList
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EList} EList
       */
      EList.fromObject = function fromObject(object) {
          if (object instanceof $root.EList)
              return object;
          var message = new $root.EList();
          if (object.ps) {
              if (!Array.isArray(object.ps))
                  throw TypeError(".EList.ps: array expected");
              message.ps = [];
              for (var i = 0; i < object.ps.length; ++i) {
                  if (typeof object.ps[i] !== "object")
                      throw TypeError(".EList.ps: object expected");
                  message.ps[i] = $root.Par.fromObject(object.ps[i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          if (object.remainder != null) {
              if (typeof object.remainder !== "object")
                  throw TypeError(".EList.remainder: object expected");
              message.remainder = $root.Var.fromObject(object.remainder);
          }
          return message;
      };

      /**
       * Creates a plain object from a EList message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EList
       * @static
       * @param {EList} message EList
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EList.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.ps = [];
          if (options.defaults) {
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
              object.remainder = null;
          }
          if (message.ps && message.ps.length) {
              object.ps = [];
              for (var j = 0; j < message.ps.length; ++j)
                  object.ps[j] = $root.Par.toObject(message.ps[j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              object.remainder = $root.Var.toObject(message.remainder, options);
          return object;
      };

      /**
       * Converts this EList to JSON.
       * @function toJSON
       * @memberof EList
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EList.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EList;
  })();

  $root.ETuple = (function() {

      /**
       * Properties of a ETuple.
       * @exports IETuple
       * @interface IETuple
       * @property {Array.<IPar>|null} [ps] ETuple ps
       * @property {Uint8Array|null} [locallyFree] ETuple locallyFree
       * @property {boolean|null} [connective_used] ETuple connective_used
       */

      /**
       * Constructs a new ETuple.
       * @exports ETuple
       * @classdesc Represents a ETuple.
       * @implements IETuple
       * @constructor
       * @param {IETuple=} [properties] Properties to set
       */
      function ETuple(properties) {
          this.ps = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ETuple ps.
       * @member {Array.<IPar>} ps
       * @memberof ETuple
       * @instance
       */
      ETuple.prototype.ps = $util.emptyArray;

      /**
       * ETuple locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof ETuple
       * @instance
       */
      ETuple.prototype.locallyFree = $util.newBuffer([]);

      /**
       * ETuple connective_used.
       * @member {boolean} connective_used
       * @memberof ETuple
       * @instance
       */
      ETuple.prototype.connective_used = false;

      /**
       * Creates a new ETuple instance using the specified properties.
       * @function create
       * @memberof ETuple
       * @static
       * @param {IETuple=} [properties] Properties to set
       * @returns {ETuple} ETuple instance
       */
      ETuple.create = function create(properties) {
          return new ETuple(properties);
      };

      /**
       * Encodes the specified ETuple message. Does not implicitly {@link ETuple.verify|verify} messages.
       * @function encode
       * @memberof ETuple
       * @static
       * @param {IETuple} message ETuple message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ETuple.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.ps != null && message.ps.length)
              for (var i = 0; i < message.ps.length; ++i)
                  $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
          return writer;
      };

      /**
       * Encodes the specified ETuple message, length delimited. Does not implicitly {@link ETuple.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ETuple
       * @static
       * @param {IETuple} message ETuple message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ETuple.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ETuple message from the specified reader or buffer.
       * @function decode
       * @memberof ETuple
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ETuple} ETuple
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ETuple.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ETuple();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.ps && message.ps.length))
                      message.ps = [];
                  message.ps.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 3:
                  message.locallyFree = reader.bytes();
                  break;
              case 4:
                  message.connective_used = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ETuple message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ETuple
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ETuple} ETuple
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ETuple.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ETuple message.
       * @function verify
       * @memberof ETuple
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ETuple.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.ps != null && message.hasOwnProperty("ps")) {
              if (!Array.isArray(message.ps))
                  return "ps: array expected";
              for (var i = 0; i < message.ps.length; ++i) {
                  var error = $root.Par.verify(message.ps[i]);
                  if (error)
                      return "ps." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          return null;
      };

      /**
       * Creates a ETuple message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ETuple
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ETuple} ETuple
       */
      ETuple.fromObject = function fromObject(object) {
          if (object instanceof $root.ETuple)
              return object;
          var message = new $root.ETuple();
          if (object.ps) {
              if (!Array.isArray(object.ps))
                  throw TypeError(".ETuple.ps: array expected");
              message.ps = [];
              for (var i = 0; i < object.ps.length; ++i) {
                  if (typeof object.ps[i] !== "object")
                      throw TypeError(".ETuple.ps: object expected");
                  message.ps[i] = $root.Par.fromObject(object.ps[i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          return message;
      };

      /**
       * Creates a plain object from a ETuple message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ETuple
       * @static
       * @param {ETuple} message ETuple
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ETuple.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.ps = [];
          if (options.defaults) {
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
          }
          if (message.ps && message.ps.length) {
              object.ps = [];
              for (var j = 0; j < message.ps.length; ++j)
                  object.ps[j] = $root.Par.toObject(message.ps[j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          return object;
      };

      /**
       * Converts this ETuple to JSON.
       * @function toJSON
       * @memberof ETuple
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ETuple.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ETuple;
  })();

  $root.ESet = (function() {

      /**
       * Properties of a ESet.
       * @exports IESet
       * @interface IESet
       * @property {Array.<IPar>|null} [ps] ESet ps
       * @property {Uint8Array|null} [locallyFree] ESet locallyFree
       * @property {boolean|null} [connective_used] ESet connective_used
       * @property {IVar|null} [remainder] ESet remainder
       */

      /**
       * Constructs a new ESet.
       * @exports ESet
       * @classdesc Represents a ESet.
       * @implements IESet
       * @constructor
       * @param {IESet=} [properties] Properties to set
       */
      function ESet(properties) {
          this.ps = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ESet ps.
       * @member {Array.<IPar>} ps
       * @memberof ESet
       * @instance
       */
      ESet.prototype.ps = $util.emptyArray;

      /**
       * ESet locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof ESet
       * @instance
       */
      ESet.prototype.locallyFree = $util.newBuffer([]);

      /**
       * ESet connective_used.
       * @member {boolean} connective_used
       * @memberof ESet
       * @instance
       */
      ESet.prototype.connective_used = false;

      /**
       * ESet remainder.
       * @member {IVar|null|undefined} remainder
       * @memberof ESet
       * @instance
       */
      ESet.prototype.remainder = null;

      /**
       * Creates a new ESet instance using the specified properties.
       * @function create
       * @memberof ESet
       * @static
       * @param {IESet=} [properties] Properties to set
       * @returns {ESet} ESet instance
       */
      ESet.create = function create(properties) {
          return new ESet(properties);
      };

      /**
       * Encodes the specified ESet message. Does not implicitly {@link ESet.verify|verify} messages.
       * @function encode
       * @memberof ESet
       * @static
       * @param {IESet} message ESet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ESet.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.ps != null && message.ps.length)
              for (var i = 0; i < message.ps.length; ++i)
                  $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              $root.Var.encode(message.remainder, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ESet message, length delimited. Does not implicitly {@link ESet.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ESet
       * @static
       * @param {IESet} message ESet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ESet.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ESet message from the specified reader or buffer.
       * @function decode
       * @memberof ESet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ESet} ESet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ESet.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ESet();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.ps && message.ps.length))
                      message.ps = [];
                  message.ps.push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 3:
                  message.locallyFree = reader.bytes();
                  break;
              case 4:
                  message.connective_used = reader.bool();
                  break;
              case 5:
                  message.remainder = $root.Var.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ESet message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ESet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ESet} ESet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ESet.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ESet message.
       * @function verify
       * @memberof ESet
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ESet.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.ps != null && message.hasOwnProperty("ps")) {
              if (!Array.isArray(message.ps))
                  return "ps: array expected";
              for (var i = 0; i < message.ps.length; ++i) {
                  var error = $root.Par.verify(message.ps[i]);
                  if (error)
                      return "ps." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          if (message.remainder != null && message.hasOwnProperty("remainder")) {
              var error = $root.Var.verify(message.remainder);
              if (error)
                  return "remainder." + error;
          }
          return null;
      };

      /**
       * Creates a ESet message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ESet
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ESet} ESet
       */
      ESet.fromObject = function fromObject(object) {
          if (object instanceof $root.ESet)
              return object;
          var message = new $root.ESet();
          if (object.ps) {
              if (!Array.isArray(object.ps))
                  throw TypeError(".ESet.ps: array expected");
              message.ps = [];
              for (var i = 0; i < object.ps.length; ++i) {
                  if (typeof object.ps[i] !== "object")
                      throw TypeError(".ESet.ps: object expected");
                  message.ps[i] = $root.Par.fromObject(object.ps[i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          if (object.remainder != null) {
              if (typeof object.remainder !== "object")
                  throw TypeError(".ESet.remainder: object expected");
              message.remainder = $root.Var.fromObject(object.remainder);
          }
          return message;
      };

      /**
       * Creates a plain object from a ESet message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ESet
       * @static
       * @param {ESet} message ESet
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ESet.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.ps = [];
          if (options.defaults) {
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
              object.remainder = null;
          }
          if (message.ps && message.ps.length) {
              object.ps = [];
              for (var j = 0; j < message.ps.length; ++j)
                  object.ps[j] = $root.Par.toObject(message.ps[j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              object.remainder = $root.Var.toObject(message.remainder, options);
          return object;
      };

      /**
       * Converts this ESet to JSON.
       * @function toJSON
       * @memberof ESet
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ESet.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ESet;
  })();

  $root.EMap = (function() {

      /**
       * Properties of a EMap.
       * @exports IEMap
       * @interface IEMap
       * @property {Array.<IKeyValuePair>|null} [kvs] EMap kvs
       * @property {Uint8Array|null} [locallyFree] EMap locallyFree
       * @property {boolean|null} [connective_used] EMap connective_used
       * @property {IVar|null} [remainder] EMap remainder
       */

      /**
       * Constructs a new EMap.
       * @exports EMap
       * @classdesc Represents a EMap.
       * @implements IEMap
       * @constructor
       * @param {IEMap=} [properties] Properties to set
       */
      function EMap(properties) {
          this.kvs = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMap kvs.
       * @member {Array.<IKeyValuePair>} kvs
       * @memberof EMap
       * @instance
       */
      EMap.prototype.kvs = $util.emptyArray;

      /**
       * EMap locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof EMap
       * @instance
       */
      EMap.prototype.locallyFree = $util.newBuffer([]);

      /**
       * EMap connective_used.
       * @member {boolean} connective_used
       * @memberof EMap
       * @instance
       */
      EMap.prototype.connective_used = false;

      /**
       * EMap remainder.
       * @member {IVar|null|undefined} remainder
       * @memberof EMap
       * @instance
       */
      EMap.prototype.remainder = null;

      /**
       * Creates a new EMap instance using the specified properties.
       * @function create
       * @memberof EMap
       * @static
       * @param {IEMap=} [properties] Properties to set
       * @returns {EMap} EMap instance
       */
      EMap.create = function create(properties) {
          return new EMap(properties);
      };

      /**
       * Encodes the specified EMap message. Does not implicitly {@link EMap.verify|verify} messages.
       * @function encode
       * @memberof EMap
       * @static
       * @param {IEMap} message EMap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMap.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.kvs != null && message.kvs.length)
              for (var i = 0; i < message.kvs.length; ++i)
                  $root.KeyValuePair.encode(message.kvs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 4, wireType 0 =*/32).bool(message.connective_used);
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              $root.Var.encode(message.remainder, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EMap message, length delimited. Does not implicitly {@link EMap.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMap
       * @static
       * @param {IEMap} message EMap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMap.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMap message from the specified reader or buffer.
       * @function decode
       * @memberof EMap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMap} EMap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMap.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMap();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.kvs && message.kvs.length))
                      message.kvs = [];
                  message.kvs.push($root.KeyValuePair.decode(reader, reader.uint32()));
                  break;
              case 3:
                  message.locallyFree = reader.bytes();
                  break;
              case 4:
                  message.connective_used = reader.bool();
                  break;
              case 5:
                  message.remainder = $root.Var.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMap message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMap} EMap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMap.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMap message.
       * @function verify
       * @memberof EMap
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMap.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.kvs != null && message.hasOwnProperty("kvs")) {
              if (!Array.isArray(message.kvs))
                  return "kvs: array expected";
              for (var i = 0; i < message.kvs.length; ++i) {
                  var error = $root.KeyValuePair.verify(message.kvs[i]);
                  if (error)
                      return "kvs." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          if (message.remainder != null && message.hasOwnProperty("remainder")) {
              var error = $root.Var.verify(message.remainder);
              if (error)
                  return "remainder." + error;
          }
          return null;
      };

      /**
       * Creates a EMap message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMap
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMap} EMap
       */
      EMap.fromObject = function fromObject(object) {
          if (object instanceof $root.EMap)
              return object;
          var message = new $root.EMap();
          if (object.kvs) {
              if (!Array.isArray(object.kvs))
                  throw TypeError(".EMap.kvs: array expected");
              message.kvs = [];
              for (var i = 0; i < object.kvs.length; ++i) {
                  if (typeof object.kvs[i] !== "object")
                      throw TypeError(".EMap.kvs: object expected");
                  message.kvs[i] = $root.KeyValuePair.fromObject(object.kvs[i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          if (object.remainder != null) {
              if (typeof object.remainder !== "object")
                  throw TypeError(".EMap.remainder: object expected");
              message.remainder = $root.Var.fromObject(object.remainder);
          }
          return message;
      };

      /**
       * Creates a plain object from a EMap message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMap
       * @static
       * @param {EMap} message EMap
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMap.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.kvs = [];
          if (options.defaults) {
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
              object.remainder = null;
          }
          if (message.kvs && message.kvs.length) {
              object.kvs = [];
              for (var j = 0; j < message.kvs.length; ++j)
                  object.kvs[j] = $root.KeyValuePair.toObject(message.kvs[j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          if (message.remainder != null && message.hasOwnProperty("remainder"))
              object.remainder = $root.Var.toObject(message.remainder, options);
          return object;
      };

      /**
       * Converts this EMap to JSON.
       * @function toJSON
       * @memberof EMap
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMap.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMap;
  })();

  $root.EMethod = (function() {

      /**
       * Properties of a EMethod.
       * @exports IEMethod
       * @interface IEMethod
       * @property {string|null} [methodName] EMethod methodName
       * @property {IPar|null} [target] EMethod target
       * @property {Array.<IPar>|null} ["arguments"] EMethod arguments
       * @property {Uint8Array|null} [locallyFree] EMethod locallyFree
       * @property {boolean|null} [connective_used] EMethod connective_used
       */

      /**
       * Constructs a new EMethod.
       * @exports EMethod
       * @classdesc `target.method(arguments)`
       * @implements IEMethod
       * @constructor
       * @param {IEMethod=} [properties] Properties to set
       */
      function EMethod(properties) {
          this["arguments"] = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMethod methodName.
       * @member {string} methodName
       * @memberof EMethod
       * @instance
       */
      EMethod.prototype.methodName = "";

      /**
       * EMethod target.
       * @member {IPar|null|undefined} target
       * @memberof EMethod
       * @instance
       */
      EMethod.prototype.target = null;

      /**
       * EMethod arguments.
       * @member {Array.<IPar>} arguments
       * @memberof EMethod
       * @instance
       */
      EMethod.prototype["arguments"] = $util.emptyArray;

      /**
       * EMethod locallyFree.
       * @member {Uint8Array} locallyFree
       * @memberof EMethod
       * @instance
       */
      EMethod.prototype.locallyFree = $util.newBuffer([]);

      /**
       * EMethod connective_used.
       * @member {boolean} connective_used
       * @memberof EMethod
       * @instance
       */
      EMethod.prototype.connective_used = false;

      /**
       * Creates a new EMethod instance using the specified properties.
       * @function create
       * @memberof EMethod
       * @static
       * @param {IEMethod=} [properties] Properties to set
       * @returns {EMethod} EMethod instance
       */
      EMethod.create = function create(properties) {
          return new EMethod(properties);
      };

      /**
       * Encodes the specified EMethod message. Does not implicitly {@link EMethod.verify|verify} messages.
       * @function encode
       * @memberof EMethod
       * @static
       * @param {IEMethod} message EMethod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMethod.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.methodName != null && message.hasOwnProperty("methodName"))
              writer.uint32(/* id 1, wireType 2 =*/10).string(message.methodName);
          if (message.target != null && message.hasOwnProperty("target"))
              $root.Par.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message["arguments"] != null && message["arguments"].length)
              for (var i = 0; i < message["arguments"].length; ++i)
                  $root.Par.encode(message["arguments"][i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.locallyFree);
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              writer.uint32(/* id 6, wireType 0 =*/48).bool(message.connective_used);
          return writer;
      };

      /**
       * Encodes the specified EMethod message, length delimited. Does not implicitly {@link EMethod.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMethod
       * @static
       * @param {IEMethod} message EMethod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMethod.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMethod message from the specified reader or buffer.
       * @function decode
       * @memberof EMethod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMethod} EMethod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMethod.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMethod();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.methodName = reader.string();
                  break;
              case 2:
                  message.target = $root.Par.decode(reader, reader.uint32());
                  break;
              case 3:
                  if (!(message["arguments"] && message["arguments"].length))
                      message["arguments"] = [];
                  message["arguments"].push($root.Par.decode(reader, reader.uint32()));
                  break;
              case 5:
                  message.locallyFree = reader.bytes();
                  break;
              case 6:
                  message.connective_used = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMethod message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMethod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMethod} EMethod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMethod.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMethod message.
       * @function verify
       * @memberof EMethod
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMethod.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.methodName != null && message.hasOwnProperty("methodName"))
              if (!$util.isString(message.methodName))
                  return "methodName: string expected";
          if (message.target != null && message.hasOwnProperty("target")) {
              var error = $root.Par.verify(message.target);
              if (error)
                  return "target." + error;
          }
          if (message["arguments"] != null && message.hasOwnProperty("arguments")) {
              if (!Array.isArray(message["arguments"]))
                  return "arguments: array expected";
              for (var i = 0; i < message["arguments"].length; ++i) {
                  var error = $root.Par.verify(message["arguments"][i]);
                  if (error)
                      return "arguments." + error;
              }
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              if (!(message.locallyFree && typeof message.locallyFree.length === "number" || $util.isString(message.locallyFree)))
                  return "locallyFree: buffer expected";
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              if (typeof message.connective_used !== "boolean")
                  return "connective_used: boolean expected";
          return null;
      };

      /**
       * Creates a EMethod message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMethod
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMethod} EMethod
       */
      EMethod.fromObject = function fromObject(object) {
          if (object instanceof $root.EMethod)
              return object;
          var message = new $root.EMethod();
          if (object.methodName != null)
              message.methodName = String(object.methodName);
          if (object.target != null) {
              if (typeof object.target !== "object")
                  throw TypeError(".EMethod.target: object expected");
              message.target = $root.Par.fromObject(object.target);
          }
          if (object["arguments"]) {
              if (!Array.isArray(object["arguments"]))
                  throw TypeError(".EMethod.arguments: array expected");
              message["arguments"] = [];
              for (var i = 0; i < object["arguments"].length; ++i) {
                  if (typeof object["arguments"][i] !== "object")
                      throw TypeError(".EMethod.arguments: object expected");
                  message["arguments"][i] = $root.Par.fromObject(object["arguments"][i]);
              }
          }
          if (object.locallyFree != null)
              if (typeof object.locallyFree === "string")
                  $util.base64.decode(object.locallyFree, message.locallyFree = $util.newBuffer($util.base64.length(object.locallyFree)), 0);
              else if (object.locallyFree.length)
                  message.locallyFree = object.locallyFree;
          if (object.connective_used != null)
              message.connective_used = Boolean(object.connective_used);
          return message;
      };

      /**
       * Creates a plain object from a EMethod message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMethod
       * @static
       * @param {EMethod} message EMethod
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMethod.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object["arguments"] = [];
          if (options.defaults) {
              object.methodName = "";
              object.target = null;
              if (options.bytes === String)
                  object.locallyFree = "";
              else {
                  object.locallyFree = [];
                  if (options.bytes !== Array)
                      object.locallyFree = $util.newBuffer(object.locallyFree);
              }
              object.connective_used = false;
          }
          if (message.methodName != null && message.hasOwnProperty("methodName"))
              object.methodName = message.methodName;
          if (message.target != null && message.hasOwnProperty("target"))
              object.target = $root.Par.toObject(message.target, options);
          if (message["arguments"] && message["arguments"].length) {
              object["arguments"] = [];
              for (var j = 0; j < message["arguments"].length; ++j)
                  object["arguments"][j] = $root.Par.toObject(message["arguments"][j], options);
          }
          if (message.locallyFree != null && message.hasOwnProperty("locallyFree"))
              object.locallyFree = options.bytes === String ? $util.base64.encode(message.locallyFree, 0, message.locallyFree.length) : options.bytes === Array ? Array.prototype.slice.call(message.locallyFree) : message.locallyFree;
          if (message.connective_used != null && message.hasOwnProperty("connective_used"))
              object.connective_used = message.connective_used;
          return object;
      };

      /**
       * Converts this EMethod to JSON.
       * @function toJSON
       * @memberof EMethod
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMethod.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMethod;
  })();

  $root.KeyValuePair = (function() {

      /**
       * Properties of a KeyValuePair.
       * @exports IKeyValuePair
       * @interface IKeyValuePair
       * @property {IPar|null} [key] KeyValuePair key
       * @property {IPar|null} [value] KeyValuePair value
       */

      /**
       * Constructs a new KeyValuePair.
       * @exports KeyValuePair
       * @classdesc Represents a KeyValuePair.
       * @implements IKeyValuePair
       * @constructor
       * @param {IKeyValuePair=} [properties] Properties to set
       */
      function KeyValuePair(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * KeyValuePair key.
       * @member {IPar|null|undefined} key
       * @memberof KeyValuePair
       * @instance
       */
      KeyValuePair.prototype.key = null;

      /**
       * KeyValuePair value.
       * @member {IPar|null|undefined} value
       * @memberof KeyValuePair
       * @instance
       */
      KeyValuePair.prototype.value = null;

      /**
       * Creates a new KeyValuePair instance using the specified properties.
       * @function create
       * @memberof KeyValuePair
       * @static
       * @param {IKeyValuePair=} [properties] Properties to set
       * @returns {KeyValuePair} KeyValuePair instance
       */
      KeyValuePair.create = function create(properties) {
          return new KeyValuePair(properties);
      };

      /**
       * Encodes the specified KeyValuePair message. Does not implicitly {@link KeyValuePair.verify|verify} messages.
       * @function encode
       * @memberof KeyValuePair
       * @static
       * @param {IKeyValuePair} message KeyValuePair message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      KeyValuePair.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
              $root.Par.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.value != null && message.hasOwnProperty("value"))
              $root.Par.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified KeyValuePair message, length delimited. Does not implicitly {@link KeyValuePair.verify|verify} messages.
       * @function encodeDelimited
       * @memberof KeyValuePair
       * @static
       * @param {IKeyValuePair} message KeyValuePair message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      KeyValuePair.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a KeyValuePair message from the specified reader or buffer.
       * @function decode
       * @memberof KeyValuePair
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {KeyValuePair} KeyValuePair
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      KeyValuePair.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeyValuePair();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.key = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.value = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a KeyValuePair message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof KeyValuePair
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {KeyValuePair} KeyValuePair
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      KeyValuePair.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a KeyValuePair message.
       * @function verify
       * @memberof KeyValuePair
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      KeyValuePair.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
              var error = $root.Par.verify(message.key);
              if (error)
                  return "key." + error;
          }
          if (message.value != null && message.hasOwnProperty("value")) {
              var error = $root.Par.verify(message.value);
              if (error)
                  return "value." + error;
          }
          return null;
      };

      /**
       * Creates a KeyValuePair message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof KeyValuePair
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {KeyValuePair} KeyValuePair
       */
      KeyValuePair.fromObject = function fromObject(object) {
          if (object instanceof $root.KeyValuePair)
              return object;
          var message = new $root.KeyValuePair();
          if (object.key != null) {
              if (typeof object.key !== "object")
                  throw TypeError(".KeyValuePair.key: object expected");
              message.key = $root.Par.fromObject(object.key);
          }
          if (object.value != null) {
              if (typeof object.value !== "object")
                  throw TypeError(".KeyValuePair.value: object expected");
              message.value = $root.Par.fromObject(object.value);
          }
          return message;
      };

      /**
       * Creates a plain object from a KeyValuePair message. Also converts values to other types if specified.
       * @function toObject
       * @memberof KeyValuePair
       * @static
       * @param {KeyValuePair} message KeyValuePair
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      KeyValuePair.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.key = null;
              object.value = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
              object.key = $root.Par.toObject(message.key, options);
          if (message.value != null && message.hasOwnProperty("value"))
              object.value = $root.Par.toObject(message.value, options);
          return object;
      };

      /**
       * Converts this KeyValuePair to JSON.
       * @function toJSON
       * @memberof KeyValuePair
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      KeyValuePair.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return KeyValuePair;
  })();

  $root.EVar = (function() {

      /**
       * Properties of a EVar.
       * @exports IEVar
       * @interface IEVar
       * @property {IVar|null} [v] EVar v
       */

      /**
       * Constructs a new EVar.
       * @exports EVar
       * @classdesc Represents a EVar.
       * @implements IEVar
       * @constructor
       * @param {IEVar=} [properties] Properties to set
       */
      function EVar(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EVar v.
       * @member {IVar|null|undefined} v
       * @memberof EVar
       * @instance
       */
      EVar.prototype.v = null;

      /**
       * Creates a new EVar instance using the specified properties.
       * @function create
       * @memberof EVar
       * @static
       * @param {IEVar=} [properties] Properties to set
       * @returns {EVar} EVar instance
       */
      EVar.create = function create(properties) {
          return new EVar(properties);
      };

      /**
       * Encodes the specified EVar message. Does not implicitly {@link EVar.verify|verify} messages.
       * @function encode
       * @memberof EVar
       * @static
       * @param {IEVar} message EVar message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EVar.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.v != null && message.hasOwnProperty("v"))
              $root.Var.encode(message.v, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EVar message, length delimited. Does not implicitly {@link EVar.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EVar
       * @static
       * @param {IEVar} message EVar message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EVar.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EVar message from the specified reader or buffer.
       * @function decode
       * @memberof EVar
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EVar} EVar
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EVar.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EVar();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.v = $root.Var.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EVar message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EVar
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EVar} EVar
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EVar.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EVar message.
       * @function verify
       * @memberof EVar
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EVar.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.v != null && message.hasOwnProperty("v")) {
              var error = $root.Var.verify(message.v);
              if (error)
                  return "v." + error;
          }
          return null;
      };

      /**
       * Creates a EVar message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EVar
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EVar} EVar
       */
      EVar.fromObject = function fromObject(object) {
          if (object instanceof $root.EVar)
              return object;
          var message = new $root.EVar();
          if (object.v != null) {
              if (typeof object.v !== "object")
                  throw TypeError(".EVar.v: object expected");
              message.v = $root.Var.fromObject(object.v);
          }
          return message;
      };

      /**
       * Creates a plain object from a EVar message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EVar
       * @static
       * @param {EVar} message EVar
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EVar.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              object.v = null;
          if (message.v != null && message.hasOwnProperty("v"))
              object.v = $root.Var.toObject(message.v, options);
          return object;
      };

      /**
       * Converts this EVar to JSON.
       * @function toJSON
       * @memberof EVar
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EVar.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EVar;
  })();

  $root.ENot = (function() {

      /**
       * Properties of a ENot.
       * @exports IENot
       * @interface IENot
       * @property {IPar|null} [p] ENot p
       */

      /**
       * Constructs a new ENot.
       * @exports ENot
       * @classdesc Represents a ENot.
       * @implements IENot
       * @constructor
       * @param {IENot=} [properties] Properties to set
       */
      function ENot(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ENot p.
       * @member {IPar|null|undefined} p
       * @memberof ENot
       * @instance
       */
      ENot.prototype.p = null;

      /**
       * Creates a new ENot instance using the specified properties.
       * @function create
       * @memberof ENot
       * @static
       * @param {IENot=} [properties] Properties to set
       * @returns {ENot} ENot instance
       */
      ENot.create = function create(properties) {
          return new ENot(properties);
      };

      /**
       * Encodes the specified ENot message. Does not implicitly {@link ENot.verify|verify} messages.
       * @function encode
       * @memberof ENot
       * @static
       * @param {IENot} message ENot message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ENot.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p != null && message.hasOwnProperty("p"))
              $root.Par.encode(message.p, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ENot message, length delimited. Does not implicitly {@link ENot.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ENot
       * @static
       * @param {IENot} message ENot message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ENot.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ENot message from the specified reader or buffer.
       * @function decode
       * @memberof ENot
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ENot} ENot
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ENot.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ENot();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ENot message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ENot
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ENot} ENot
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ENot.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ENot message.
       * @function verify
       * @memberof ENot
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ENot.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p != null && message.hasOwnProperty("p")) {
              var error = $root.Par.verify(message.p);
              if (error)
                  return "p." + error;
          }
          return null;
      };

      /**
       * Creates a ENot message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ENot
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ENot} ENot
       */
      ENot.fromObject = function fromObject(object) {
          if (object instanceof $root.ENot)
              return object;
          var message = new $root.ENot();
          if (object.p != null) {
              if (typeof object.p !== "object")
                  throw TypeError(".ENot.p: object expected");
              message.p = $root.Par.fromObject(object.p);
          }
          return message;
      };

      /**
       * Creates a plain object from a ENot message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ENot
       * @static
       * @param {ENot} message ENot
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ENot.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              object.p = null;
          if (message.p != null && message.hasOwnProperty("p"))
              object.p = $root.Par.toObject(message.p, options);
          return object;
      };

      /**
       * Converts this ENot to JSON.
       * @function toJSON
       * @memberof ENot
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ENot.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ENot;
  })();

  $root.ENeg = (function() {

      /**
       * Properties of a ENeg.
       * @exports IENeg
       * @interface IENeg
       * @property {IPar|null} [p] ENeg p
       */

      /**
       * Constructs a new ENeg.
       * @exports ENeg
       * @classdesc Represents a ENeg.
       * @implements IENeg
       * @constructor
       * @param {IENeg=} [properties] Properties to set
       */
      function ENeg(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ENeg p.
       * @member {IPar|null|undefined} p
       * @memberof ENeg
       * @instance
       */
      ENeg.prototype.p = null;

      /**
       * Creates a new ENeg instance using the specified properties.
       * @function create
       * @memberof ENeg
       * @static
       * @param {IENeg=} [properties] Properties to set
       * @returns {ENeg} ENeg instance
       */
      ENeg.create = function create(properties) {
          return new ENeg(properties);
      };

      /**
       * Encodes the specified ENeg message. Does not implicitly {@link ENeg.verify|verify} messages.
       * @function encode
       * @memberof ENeg
       * @static
       * @param {IENeg} message ENeg message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ENeg.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p != null && message.hasOwnProperty("p"))
              $root.Par.encode(message.p, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ENeg message, length delimited. Does not implicitly {@link ENeg.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ENeg
       * @static
       * @param {IENeg} message ENeg message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ENeg.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ENeg message from the specified reader or buffer.
       * @function decode
       * @memberof ENeg
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ENeg} ENeg
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ENeg.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ENeg();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ENeg message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ENeg
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ENeg} ENeg
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ENeg.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ENeg message.
       * @function verify
       * @memberof ENeg
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ENeg.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p != null && message.hasOwnProperty("p")) {
              var error = $root.Par.verify(message.p);
              if (error)
                  return "p." + error;
          }
          return null;
      };

      /**
       * Creates a ENeg message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ENeg
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ENeg} ENeg
       */
      ENeg.fromObject = function fromObject(object) {
          if (object instanceof $root.ENeg)
              return object;
          var message = new $root.ENeg();
          if (object.p != null) {
              if (typeof object.p !== "object")
                  throw TypeError(".ENeg.p: object expected");
              message.p = $root.Par.fromObject(object.p);
          }
          return message;
      };

      /**
       * Creates a plain object from a ENeg message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ENeg
       * @static
       * @param {ENeg} message ENeg
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ENeg.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              object.p = null;
          if (message.p != null && message.hasOwnProperty("p"))
              object.p = $root.Par.toObject(message.p, options);
          return object;
      };

      /**
       * Converts this ENeg to JSON.
       * @function toJSON
       * @memberof ENeg
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ENeg.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ENeg;
  })();

  $root.EMult = (function() {

      /**
       * Properties of a EMult.
       * @exports IEMult
       * @interface IEMult
       * @property {IPar|null} [p1] EMult p1
       * @property {IPar|null} [p2] EMult p2
       */

      /**
       * Constructs a new EMult.
       * @exports EMult
       * @classdesc Represents a EMult.
       * @implements IEMult
       * @constructor
       * @param {IEMult=} [properties] Properties to set
       */
      function EMult(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMult p1.
       * @member {IPar|null|undefined} p1
       * @memberof EMult
       * @instance
       */
      EMult.prototype.p1 = null;

      /**
       * EMult p2.
       * @member {IPar|null|undefined} p2
       * @memberof EMult
       * @instance
       */
      EMult.prototype.p2 = null;

      /**
       * Creates a new EMult instance using the specified properties.
       * @function create
       * @memberof EMult
       * @static
       * @param {IEMult=} [properties] Properties to set
       * @returns {EMult} EMult instance
       */
      EMult.create = function create(properties) {
          return new EMult(properties);
      };

      /**
       * Encodes the specified EMult message. Does not implicitly {@link EMult.verify|verify} messages.
       * @function encode
       * @memberof EMult
       * @static
       * @param {IEMult} message EMult message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMult.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EMult message, length delimited. Does not implicitly {@link EMult.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMult
       * @static
       * @param {IEMult} message EMult message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMult.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMult message from the specified reader or buffer.
       * @function decode
       * @memberof EMult
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMult} EMult
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMult.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMult();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMult message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMult
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMult} EMult
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMult.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMult message.
       * @function verify
       * @memberof EMult
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMult.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EMult message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMult
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMult} EMult
       */
      EMult.fromObject = function fromObject(object) {
          if (object instanceof $root.EMult)
              return object;
          var message = new $root.EMult();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EMult.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EMult.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EMult message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMult
       * @static
       * @param {EMult} message EMult
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMult.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EMult to JSON.
       * @function toJSON
       * @memberof EMult
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMult.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMult;
  })();

  $root.EDiv = (function() {

      /**
       * Properties of a EDiv.
       * @exports IEDiv
       * @interface IEDiv
       * @property {IPar|null} [p1] EDiv p1
       * @property {IPar|null} [p2] EDiv p2
       */

      /**
       * Constructs a new EDiv.
       * @exports EDiv
       * @classdesc Represents a EDiv.
       * @implements IEDiv
       * @constructor
       * @param {IEDiv=} [properties] Properties to set
       */
      function EDiv(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EDiv p1.
       * @member {IPar|null|undefined} p1
       * @memberof EDiv
       * @instance
       */
      EDiv.prototype.p1 = null;

      /**
       * EDiv p2.
       * @member {IPar|null|undefined} p2
       * @memberof EDiv
       * @instance
       */
      EDiv.prototype.p2 = null;

      /**
       * Creates a new EDiv instance using the specified properties.
       * @function create
       * @memberof EDiv
       * @static
       * @param {IEDiv=} [properties] Properties to set
       * @returns {EDiv} EDiv instance
       */
      EDiv.create = function create(properties) {
          return new EDiv(properties);
      };

      /**
       * Encodes the specified EDiv message. Does not implicitly {@link EDiv.verify|verify} messages.
       * @function encode
       * @memberof EDiv
       * @static
       * @param {IEDiv} message EDiv message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EDiv.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EDiv message, length delimited. Does not implicitly {@link EDiv.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EDiv
       * @static
       * @param {IEDiv} message EDiv message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EDiv.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EDiv message from the specified reader or buffer.
       * @function decode
       * @memberof EDiv
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EDiv} EDiv
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EDiv.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EDiv();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EDiv message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EDiv
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EDiv} EDiv
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EDiv.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EDiv message.
       * @function verify
       * @memberof EDiv
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EDiv.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EDiv message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EDiv
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EDiv} EDiv
       */
      EDiv.fromObject = function fromObject(object) {
          if (object instanceof $root.EDiv)
              return object;
          var message = new $root.EDiv();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EDiv.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EDiv.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EDiv message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EDiv
       * @static
       * @param {EDiv} message EDiv
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EDiv.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EDiv to JSON.
       * @function toJSON
       * @memberof EDiv
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EDiv.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EDiv;
  })();

  $root.EMod = (function() {

      /**
       * Properties of a EMod.
       * @exports IEMod
       * @interface IEMod
       * @property {IPar|null} [p1] EMod p1
       * @property {IPar|null} [p2] EMod p2
       */

      /**
       * Constructs a new EMod.
       * @exports EMod
       * @classdesc Represents a EMod.
       * @implements IEMod
       * @constructor
       * @param {IEMod=} [properties] Properties to set
       */
      function EMod(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMod p1.
       * @member {IPar|null|undefined} p1
       * @memberof EMod
       * @instance
       */
      EMod.prototype.p1 = null;

      /**
       * EMod p2.
       * @member {IPar|null|undefined} p2
       * @memberof EMod
       * @instance
       */
      EMod.prototype.p2 = null;

      /**
       * Creates a new EMod instance using the specified properties.
       * @function create
       * @memberof EMod
       * @static
       * @param {IEMod=} [properties] Properties to set
       * @returns {EMod} EMod instance
       */
      EMod.create = function create(properties) {
          return new EMod(properties);
      };

      /**
       * Encodes the specified EMod message. Does not implicitly {@link EMod.verify|verify} messages.
       * @function encode
       * @memberof EMod
       * @static
       * @param {IEMod} message EMod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMod.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EMod message, length delimited. Does not implicitly {@link EMod.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMod
       * @static
       * @param {IEMod} message EMod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMod.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMod message from the specified reader or buffer.
       * @function decode
       * @memberof EMod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMod} EMod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMod.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMod();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMod message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMod} EMod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMod.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMod message.
       * @function verify
       * @memberof EMod
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMod.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EMod message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMod
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMod} EMod
       */
      EMod.fromObject = function fromObject(object) {
          if (object instanceof $root.EMod)
              return object;
          var message = new $root.EMod();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EMod.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EMod.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EMod message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMod
       * @static
       * @param {EMod} message EMod
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMod.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EMod to JSON.
       * @function toJSON
       * @memberof EMod
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMod.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMod;
  })();

  $root.EPlus = (function() {

      /**
       * Properties of a EPlus.
       * @exports IEPlus
       * @interface IEPlus
       * @property {IPar|null} [p1] EPlus p1
       * @property {IPar|null} [p2] EPlus p2
       */

      /**
       * Constructs a new EPlus.
       * @exports EPlus
       * @classdesc Represents a EPlus.
       * @implements IEPlus
       * @constructor
       * @param {IEPlus=} [properties] Properties to set
       */
      function EPlus(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EPlus p1.
       * @member {IPar|null|undefined} p1
       * @memberof EPlus
       * @instance
       */
      EPlus.prototype.p1 = null;

      /**
       * EPlus p2.
       * @member {IPar|null|undefined} p2
       * @memberof EPlus
       * @instance
       */
      EPlus.prototype.p2 = null;

      /**
       * Creates a new EPlus instance using the specified properties.
       * @function create
       * @memberof EPlus
       * @static
       * @param {IEPlus=} [properties] Properties to set
       * @returns {EPlus} EPlus instance
       */
      EPlus.create = function create(properties) {
          return new EPlus(properties);
      };

      /**
       * Encodes the specified EPlus message. Does not implicitly {@link EPlus.verify|verify} messages.
       * @function encode
       * @memberof EPlus
       * @static
       * @param {IEPlus} message EPlus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EPlus.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EPlus message, length delimited. Does not implicitly {@link EPlus.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EPlus
       * @static
       * @param {IEPlus} message EPlus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EPlus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EPlus message from the specified reader or buffer.
       * @function decode
       * @memberof EPlus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EPlus} EPlus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EPlus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EPlus();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EPlus message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EPlus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EPlus} EPlus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EPlus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EPlus message.
       * @function verify
       * @memberof EPlus
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EPlus.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EPlus message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EPlus
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EPlus} EPlus
       */
      EPlus.fromObject = function fromObject(object) {
          if (object instanceof $root.EPlus)
              return object;
          var message = new $root.EPlus();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EPlus.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EPlus.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EPlus message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EPlus
       * @static
       * @param {EPlus} message EPlus
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EPlus.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EPlus to JSON.
       * @function toJSON
       * @memberof EPlus
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EPlus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EPlus;
  })();

  $root.EMinus = (function() {

      /**
       * Properties of a EMinus.
       * @exports IEMinus
       * @interface IEMinus
       * @property {IPar|null} [p1] EMinus p1
       * @property {IPar|null} [p2] EMinus p2
       */

      /**
       * Constructs a new EMinus.
       * @exports EMinus
       * @classdesc Represents a EMinus.
       * @implements IEMinus
       * @constructor
       * @param {IEMinus=} [properties] Properties to set
       */
      function EMinus(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMinus p1.
       * @member {IPar|null|undefined} p1
       * @memberof EMinus
       * @instance
       */
      EMinus.prototype.p1 = null;

      /**
       * EMinus p2.
       * @member {IPar|null|undefined} p2
       * @memberof EMinus
       * @instance
       */
      EMinus.prototype.p2 = null;

      /**
       * Creates a new EMinus instance using the specified properties.
       * @function create
       * @memberof EMinus
       * @static
       * @param {IEMinus=} [properties] Properties to set
       * @returns {EMinus} EMinus instance
       */
      EMinus.create = function create(properties) {
          return new EMinus(properties);
      };

      /**
       * Encodes the specified EMinus message. Does not implicitly {@link EMinus.verify|verify} messages.
       * @function encode
       * @memberof EMinus
       * @static
       * @param {IEMinus} message EMinus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMinus.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EMinus message, length delimited. Does not implicitly {@link EMinus.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMinus
       * @static
       * @param {IEMinus} message EMinus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMinus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMinus message from the specified reader or buffer.
       * @function decode
       * @memberof EMinus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMinus} EMinus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMinus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMinus();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMinus message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMinus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMinus} EMinus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMinus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMinus message.
       * @function verify
       * @memberof EMinus
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMinus.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EMinus message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMinus
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMinus} EMinus
       */
      EMinus.fromObject = function fromObject(object) {
          if (object instanceof $root.EMinus)
              return object;
          var message = new $root.EMinus();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EMinus.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EMinus.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EMinus message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMinus
       * @static
       * @param {EMinus} message EMinus
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMinus.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EMinus to JSON.
       * @function toJSON
       * @memberof EMinus
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMinus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMinus;
  })();

  $root.ELt = (function() {

      /**
       * Properties of a ELt.
       * @exports IELt
       * @interface IELt
       * @property {IPar|null} [p1] ELt p1
       * @property {IPar|null} [p2] ELt p2
       */

      /**
       * Constructs a new ELt.
       * @exports ELt
       * @classdesc Represents a ELt.
       * @implements IELt
       * @constructor
       * @param {IELt=} [properties] Properties to set
       */
      function ELt(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ELt p1.
       * @member {IPar|null|undefined} p1
       * @memberof ELt
       * @instance
       */
      ELt.prototype.p1 = null;

      /**
       * ELt p2.
       * @member {IPar|null|undefined} p2
       * @memberof ELt
       * @instance
       */
      ELt.prototype.p2 = null;

      /**
       * Creates a new ELt instance using the specified properties.
       * @function create
       * @memberof ELt
       * @static
       * @param {IELt=} [properties] Properties to set
       * @returns {ELt} ELt instance
       */
      ELt.create = function create(properties) {
          return new ELt(properties);
      };

      /**
       * Encodes the specified ELt message. Does not implicitly {@link ELt.verify|verify} messages.
       * @function encode
       * @memberof ELt
       * @static
       * @param {IELt} message ELt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ELt.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ELt message, length delimited. Does not implicitly {@link ELt.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ELt
       * @static
       * @param {IELt} message ELt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ELt.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ELt message from the specified reader or buffer.
       * @function decode
       * @memberof ELt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ELt} ELt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ELt.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ELt();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ELt message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ELt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ELt} ELt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ELt.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ELt message.
       * @function verify
       * @memberof ELt
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ELt.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a ELt message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ELt
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ELt} ELt
       */
      ELt.fromObject = function fromObject(object) {
          if (object instanceof $root.ELt)
              return object;
          var message = new $root.ELt();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".ELt.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".ELt.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a ELt message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ELt
       * @static
       * @param {ELt} message ELt
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ELt.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this ELt to JSON.
       * @function toJSON
       * @memberof ELt
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ELt.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ELt;
  })();

  $root.ELte = (function() {

      /**
       * Properties of a ELte.
       * @exports IELte
       * @interface IELte
       * @property {IPar|null} [p1] ELte p1
       * @property {IPar|null} [p2] ELte p2
       */

      /**
       * Constructs a new ELte.
       * @exports ELte
       * @classdesc Represents a ELte.
       * @implements IELte
       * @constructor
       * @param {IELte=} [properties] Properties to set
       */
      function ELte(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ELte p1.
       * @member {IPar|null|undefined} p1
       * @memberof ELte
       * @instance
       */
      ELte.prototype.p1 = null;

      /**
       * ELte p2.
       * @member {IPar|null|undefined} p2
       * @memberof ELte
       * @instance
       */
      ELte.prototype.p2 = null;

      /**
       * Creates a new ELte instance using the specified properties.
       * @function create
       * @memberof ELte
       * @static
       * @param {IELte=} [properties] Properties to set
       * @returns {ELte} ELte instance
       */
      ELte.create = function create(properties) {
          return new ELte(properties);
      };

      /**
       * Encodes the specified ELte message. Does not implicitly {@link ELte.verify|verify} messages.
       * @function encode
       * @memberof ELte
       * @static
       * @param {IELte} message ELte message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ELte.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ELte message, length delimited. Does not implicitly {@link ELte.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ELte
       * @static
       * @param {IELte} message ELte message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ELte.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ELte message from the specified reader or buffer.
       * @function decode
       * @memberof ELte
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ELte} ELte
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ELte.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ELte();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ELte message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ELte
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ELte} ELte
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ELte.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ELte message.
       * @function verify
       * @memberof ELte
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ELte.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a ELte message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ELte
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ELte} ELte
       */
      ELte.fromObject = function fromObject(object) {
          if (object instanceof $root.ELte)
              return object;
          var message = new $root.ELte();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".ELte.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".ELte.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a ELte message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ELte
       * @static
       * @param {ELte} message ELte
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ELte.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this ELte to JSON.
       * @function toJSON
       * @memberof ELte
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ELte.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ELte;
  })();

  $root.EGt = (function() {

      /**
       * Properties of a EGt.
       * @exports IEGt
       * @interface IEGt
       * @property {IPar|null} [p1] EGt p1
       * @property {IPar|null} [p2] EGt p2
       */

      /**
       * Constructs a new EGt.
       * @exports EGt
       * @classdesc Represents a EGt.
       * @implements IEGt
       * @constructor
       * @param {IEGt=} [properties] Properties to set
       */
      function EGt(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EGt p1.
       * @member {IPar|null|undefined} p1
       * @memberof EGt
       * @instance
       */
      EGt.prototype.p1 = null;

      /**
       * EGt p2.
       * @member {IPar|null|undefined} p2
       * @memberof EGt
       * @instance
       */
      EGt.prototype.p2 = null;

      /**
       * Creates a new EGt instance using the specified properties.
       * @function create
       * @memberof EGt
       * @static
       * @param {IEGt=} [properties] Properties to set
       * @returns {EGt} EGt instance
       */
      EGt.create = function create(properties) {
          return new EGt(properties);
      };

      /**
       * Encodes the specified EGt message. Does not implicitly {@link EGt.verify|verify} messages.
       * @function encode
       * @memberof EGt
       * @static
       * @param {IEGt} message EGt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EGt.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EGt message, length delimited. Does not implicitly {@link EGt.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EGt
       * @static
       * @param {IEGt} message EGt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EGt.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EGt message from the specified reader or buffer.
       * @function decode
       * @memberof EGt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EGt} EGt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EGt.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EGt();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EGt message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EGt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EGt} EGt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EGt.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EGt message.
       * @function verify
       * @memberof EGt
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EGt.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EGt message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EGt
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EGt} EGt
       */
      EGt.fromObject = function fromObject(object) {
          if (object instanceof $root.EGt)
              return object;
          var message = new $root.EGt();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EGt.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EGt.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EGt message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EGt
       * @static
       * @param {EGt} message EGt
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EGt.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EGt to JSON.
       * @function toJSON
       * @memberof EGt
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EGt.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EGt;
  })();

  $root.EGte = (function() {

      /**
       * Properties of a EGte.
       * @exports IEGte
       * @interface IEGte
       * @property {IPar|null} [p1] EGte p1
       * @property {IPar|null} [p2] EGte p2
       */

      /**
       * Constructs a new EGte.
       * @exports EGte
       * @classdesc Represents a EGte.
       * @implements IEGte
       * @constructor
       * @param {IEGte=} [properties] Properties to set
       */
      function EGte(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EGte p1.
       * @member {IPar|null|undefined} p1
       * @memberof EGte
       * @instance
       */
      EGte.prototype.p1 = null;

      /**
       * EGte p2.
       * @member {IPar|null|undefined} p2
       * @memberof EGte
       * @instance
       */
      EGte.prototype.p2 = null;

      /**
       * Creates a new EGte instance using the specified properties.
       * @function create
       * @memberof EGte
       * @static
       * @param {IEGte=} [properties] Properties to set
       * @returns {EGte} EGte instance
       */
      EGte.create = function create(properties) {
          return new EGte(properties);
      };

      /**
       * Encodes the specified EGte message. Does not implicitly {@link EGte.verify|verify} messages.
       * @function encode
       * @memberof EGte
       * @static
       * @param {IEGte} message EGte message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EGte.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EGte message, length delimited. Does not implicitly {@link EGte.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EGte
       * @static
       * @param {IEGte} message EGte message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EGte.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EGte message from the specified reader or buffer.
       * @function decode
       * @memberof EGte
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EGte} EGte
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EGte.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EGte();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EGte message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EGte
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EGte} EGte
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EGte.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EGte message.
       * @function verify
       * @memberof EGte
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EGte.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EGte message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EGte
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EGte} EGte
       */
      EGte.fromObject = function fromObject(object) {
          if (object instanceof $root.EGte)
              return object;
          var message = new $root.EGte();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EGte.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EGte.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EGte message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EGte
       * @static
       * @param {EGte} message EGte
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EGte.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EGte to JSON.
       * @function toJSON
       * @memberof EGte
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EGte.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EGte;
  })();

  $root.EEq = (function() {

      /**
       * Properties of a EEq.
       * @exports IEEq
       * @interface IEEq
       * @property {IPar|null} [p1] EEq p1
       * @property {IPar|null} [p2] EEq p2
       */

      /**
       * Constructs a new EEq.
       * @exports EEq
       * @classdesc Represents a EEq.
       * @implements IEEq
       * @constructor
       * @param {IEEq=} [properties] Properties to set
       */
      function EEq(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EEq p1.
       * @member {IPar|null|undefined} p1
       * @memberof EEq
       * @instance
       */
      EEq.prototype.p1 = null;

      /**
       * EEq p2.
       * @member {IPar|null|undefined} p2
       * @memberof EEq
       * @instance
       */
      EEq.prototype.p2 = null;

      /**
       * Creates a new EEq instance using the specified properties.
       * @function create
       * @memberof EEq
       * @static
       * @param {IEEq=} [properties] Properties to set
       * @returns {EEq} EEq instance
       */
      EEq.create = function create(properties) {
          return new EEq(properties);
      };

      /**
       * Encodes the specified EEq message. Does not implicitly {@link EEq.verify|verify} messages.
       * @function encode
       * @memberof EEq
       * @static
       * @param {IEEq} message EEq message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EEq.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EEq message, length delimited. Does not implicitly {@link EEq.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EEq
       * @static
       * @param {IEEq} message EEq message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EEq.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EEq message from the specified reader or buffer.
       * @function decode
       * @memberof EEq
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EEq} EEq
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EEq.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EEq();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EEq message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EEq
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EEq} EEq
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EEq.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EEq message.
       * @function verify
       * @memberof EEq
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EEq.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EEq message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EEq
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EEq} EEq
       */
      EEq.fromObject = function fromObject(object) {
          if (object instanceof $root.EEq)
              return object;
          var message = new $root.EEq();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EEq.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EEq.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EEq message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EEq
       * @static
       * @param {EEq} message EEq
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EEq.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EEq to JSON.
       * @function toJSON
       * @memberof EEq
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EEq.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EEq;
  })();

  $root.ENeq = (function() {

      /**
       * Properties of a ENeq.
       * @exports IENeq
       * @interface IENeq
       * @property {IPar|null} [p1] ENeq p1
       * @property {IPar|null} [p2] ENeq p2
       */

      /**
       * Constructs a new ENeq.
       * @exports ENeq
       * @classdesc Represents a ENeq.
       * @implements IENeq
       * @constructor
       * @param {IENeq=} [properties] Properties to set
       */
      function ENeq(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ENeq p1.
       * @member {IPar|null|undefined} p1
       * @memberof ENeq
       * @instance
       */
      ENeq.prototype.p1 = null;

      /**
       * ENeq p2.
       * @member {IPar|null|undefined} p2
       * @memberof ENeq
       * @instance
       */
      ENeq.prototype.p2 = null;

      /**
       * Creates a new ENeq instance using the specified properties.
       * @function create
       * @memberof ENeq
       * @static
       * @param {IENeq=} [properties] Properties to set
       * @returns {ENeq} ENeq instance
       */
      ENeq.create = function create(properties) {
          return new ENeq(properties);
      };

      /**
       * Encodes the specified ENeq message. Does not implicitly {@link ENeq.verify|verify} messages.
       * @function encode
       * @memberof ENeq
       * @static
       * @param {IENeq} message ENeq message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ENeq.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ENeq message, length delimited. Does not implicitly {@link ENeq.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ENeq
       * @static
       * @param {IENeq} message ENeq message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ENeq.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ENeq message from the specified reader or buffer.
       * @function decode
       * @memberof ENeq
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ENeq} ENeq
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ENeq.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ENeq();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ENeq message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ENeq
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ENeq} ENeq
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ENeq.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ENeq message.
       * @function verify
       * @memberof ENeq
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ENeq.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a ENeq message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ENeq
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ENeq} ENeq
       */
      ENeq.fromObject = function fromObject(object) {
          if (object instanceof $root.ENeq)
              return object;
          var message = new $root.ENeq();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".ENeq.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".ENeq.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a ENeq message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ENeq
       * @static
       * @param {ENeq} message ENeq
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ENeq.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this ENeq to JSON.
       * @function toJSON
       * @memberof ENeq
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ENeq.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ENeq;
  })();

  $root.EAnd = (function() {

      /**
       * Properties of a EAnd.
       * @exports IEAnd
       * @interface IEAnd
       * @property {IPar|null} [p1] EAnd p1
       * @property {IPar|null} [p2] EAnd p2
       */

      /**
       * Constructs a new EAnd.
       * @exports EAnd
       * @classdesc Represents a EAnd.
       * @implements IEAnd
       * @constructor
       * @param {IEAnd=} [properties] Properties to set
       */
      function EAnd(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EAnd p1.
       * @member {IPar|null|undefined} p1
       * @memberof EAnd
       * @instance
       */
      EAnd.prototype.p1 = null;

      /**
       * EAnd p2.
       * @member {IPar|null|undefined} p2
       * @memberof EAnd
       * @instance
       */
      EAnd.prototype.p2 = null;

      /**
       * Creates a new EAnd instance using the specified properties.
       * @function create
       * @memberof EAnd
       * @static
       * @param {IEAnd=} [properties] Properties to set
       * @returns {EAnd} EAnd instance
       */
      EAnd.create = function create(properties) {
          return new EAnd(properties);
      };

      /**
       * Encodes the specified EAnd message. Does not implicitly {@link EAnd.verify|verify} messages.
       * @function encode
       * @memberof EAnd
       * @static
       * @param {IEAnd} message EAnd message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EAnd.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EAnd message, length delimited. Does not implicitly {@link EAnd.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EAnd
       * @static
       * @param {IEAnd} message EAnd message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EAnd.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EAnd message from the specified reader or buffer.
       * @function decode
       * @memberof EAnd
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EAnd} EAnd
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EAnd.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EAnd();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EAnd message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EAnd
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EAnd} EAnd
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EAnd.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EAnd message.
       * @function verify
       * @memberof EAnd
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EAnd.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EAnd message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EAnd
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EAnd} EAnd
       */
      EAnd.fromObject = function fromObject(object) {
          if (object instanceof $root.EAnd)
              return object;
          var message = new $root.EAnd();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EAnd.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EAnd.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EAnd message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EAnd
       * @static
       * @param {EAnd} message EAnd
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EAnd.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EAnd to JSON.
       * @function toJSON
       * @memberof EAnd
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EAnd.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EAnd;
  })();

  $root.EOr = (function() {

      /**
       * Properties of a EOr.
       * @exports IEOr
       * @interface IEOr
       * @property {IPar|null} [p1] EOr p1
       * @property {IPar|null} [p2] EOr p2
       */

      /**
       * Constructs a new EOr.
       * @exports EOr
       * @classdesc Represents a EOr.
       * @implements IEOr
       * @constructor
       * @param {IEOr=} [properties] Properties to set
       */
      function EOr(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EOr p1.
       * @member {IPar|null|undefined} p1
       * @memberof EOr
       * @instance
       */
      EOr.prototype.p1 = null;

      /**
       * EOr p2.
       * @member {IPar|null|undefined} p2
       * @memberof EOr
       * @instance
       */
      EOr.prototype.p2 = null;

      /**
       * Creates a new EOr instance using the specified properties.
       * @function create
       * @memberof EOr
       * @static
       * @param {IEOr=} [properties] Properties to set
       * @returns {EOr} EOr instance
       */
      EOr.create = function create(properties) {
          return new EOr(properties);
      };

      /**
       * Encodes the specified EOr message. Does not implicitly {@link EOr.verify|verify} messages.
       * @function encode
       * @memberof EOr
       * @static
       * @param {IEOr} message EOr message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EOr.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EOr message, length delimited. Does not implicitly {@link EOr.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EOr
       * @static
       * @param {IEOr} message EOr message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EOr.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EOr message from the specified reader or buffer.
       * @function decode
       * @memberof EOr
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EOr} EOr
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EOr.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EOr();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EOr message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EOr
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EOr} EOr
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EOr.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EOr message.
       * @function verify
       * @memberof EOr
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EOr.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EOr message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EOr
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EOr} EOr
       */
      EOr.fromObject = function fromObject(object) {
          if (object instanceof $root.EOr)
              return object;
          var message = new $root.EOr();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EOr.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EOr.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EOr message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EOr
       * @static
       * @param {EOr} message EOr
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EOr.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EOr to JSON.
       * @function toJSON
       * @memberof EOr
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EOr.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EOr;
  })();

  $root.EMatches = (function() {

      /**
       * Properties of a EMatches.
       * @exports IEMatches
       * @interface IEMatches
       * @property {IPar|null} [target] EMatches target
       * @property {IPar|null} [pattern] EMatches pattern
       */

      /**
       * Constructs a new EMatches.
       * @exports EMatches
       * @classdesc Represents a EMatches.
       * @implements IEMatches
       * @constructor
       * @param {IEMatches=} [properties] Properties to set
       */
      function EMatches(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMatches target.
       * @member {IPar|null|undefined} target
       * @memberof EMatches
       * @instance
       */
      EMatches.prototype.target = null;

      /**
       * EMatches pattern.
       * @member {IPar|null|undefined} pattern
       * @memberof EMatches
       * @instance
       */
      EMatches.prototype.pattern = null;

      /**
       * Creates a new EMatches instance using the specified properties.
       * @function create
       * @memberof EMatches
       * @static
       * @param {IEMatches=} [properties] Properties to set
       * @returns {EMatches} EMatches instance
       */
      EMatches.create = function create(properties) {
          return new EMatches(properties);
      };

      /**
       * Encodes the specified EMatches message. Does not implicitly {@link EMatches.verify|verify} messages.
       * @function encode
       * @memberof EMatches
       * @static
       * @param {IEMatches} message EMatches message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMatches.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.target != null && message.hasOwnProperty("target"))
              $root.Par.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.pattern != null && message.hasOwnProperty("pattern"))
              $root.Par.encode(message.pattern, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EMatches message, length delimited. Does not implicitly {@link EMatches.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMatches
       * @static
       * @param {IEMatches} message EMatches message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMatches.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMatches message from the specified reader or buffer.
       * @function decode
       * @memberof EMatches
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMatches} EMatches
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMatches.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMatches();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.target = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.pattern = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMatches message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMatches
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMatches} EMatches
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMatches.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMatches message.
       * @function verify
       * @memberof EMatches
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMatches.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.target != null && message.hasOwnProperty("target")) {
              var error = $root.Par.verify(message.target);
              if (error)
                  return "target." + error;
          }
          if (message.pattern != null && message.hasOwnProperty("pattern")) {
              var error = $root.Par.verify(message.pattern);
              if (error)
                  return "pattern." + error;
          }
          return null;
      };

      /**
       * Creates a EMatches message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMatches
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMatches} EMatches
       */
      EMatches.fromObject = function fromObject(object) {
          if (object instanceof $root.EMatches)
              return object;
          var message = new $root.EMatches();
          if (object.target != null) {
              if (typeof object.target !== "object")
                  throw TypeError(".EMatches.target: object expected");
              message.target = $root.Par.fromObject(object.target);
          }
          if (object.pattern != null) {
              if (typeof object.pattern !== "object")
                  throw TypeError(".EMatches.pattern: object expected");
              message.pattern = $root.Par.fromObject(object.pattern);
          }
          return message;
      };

      /**
       * Creates a plain object from a EMatches message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMatches
       * @static
       * @param {EMatches} message EMatches
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMatches.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.target = null;
              object.pattern = null;
          }
          if (message.target != null && message.hasOwnProperty("target"))
              object.target = $root.Par.toObject(message.target, options);
          if (message.pattern != null && message.hasOwnProperty("pattern"))
              object.pattern = $root.Par.toObject(message.pattern, options);
          return object;
      };

      /**
       * Converts this EMatches to JSON.
       * @function toJSON
       * @memberof EMatches
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMatches.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMatches;
  })();

  $root.EPercentPercent = (function() {

      /**
       * Properties of a EPercentPercent.
       * @exports IEPercentPercent
       * @interface IEPercentPercent
       * @property {IPar|null} [p1] EPercentPercent p1
       * @property {IPar|null} [p2] EPercentPercent p2
       */

      /**
       * Constructs a new EPercentPercent.
       * @exports EPercentPercent
       * @classdesc String interpolation
       * 
       * `"Hello, {name}" %% {"name": "Bob"}` denotes `"Hello, Bob"`
       * @implements IEPercentPercent
       * @constructor
       * @param {IEPercentPercent=} [properties] Properties to set
       */
      function EPercentPercent(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EPercentPercent p1.
       * @member {IPar|null|undefined} p1
       * @memberof EPercentPercent
       * @instance
       */
      EPercentPercent.prototype.p1 = null;

      /**
       * EPercentPercent p2.
       * @member {IPar|null|undefined} p2
       * @memberof EPercentPercent
       * @instance
       */
      EPercentPercent.prototype.p2 = null;

      /**
       * Creates a new EPercentPercent instance using the specified properties.
       * @function create
       * @memberof EPercentPercent
       * @static
       * @param {IEPercentPercent=} [properties] Properties to set
       * @returns {EPercentPercent} EPercentPercent instance
       */
      EPercentPercent.create = function create(properties) {
          return new EPercentPercent(properties);
      };

      /**
       * Encodes the specified EPercentPercent message. Does not implicitly {@link EPercentPercent.verify|verify} messages.
       * @function encode
       * @memberof EPercentPercent
       * @static
       * @param {IEPercentPercent} message EPercentPercent message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EPercentPercent.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EPercentPercent message, length delimited. Does not implicitly {@link EPercentPercent.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EPercentPercent
       * @static
       * @param {IEPercentPercent} message EPercentPercent message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EPercentPercent.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EPercentPercent message from the specified reader or buffer.
       * @function decode
       * @memberof EPercentPercent
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EPercentPercent} EPercentPercent
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EPercentPercent.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EPercentPercent();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EPercentPercent message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EPercentPercent
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EPercentPercent} EPercentPercent
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EPercentPercent.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EPercentPercent message.
       * @function verify
       * @memberof EPercentPercent
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EPercentPercent.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EPercentPercent message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EPercentPercent
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EPercentPercent} EPercentPercent
       */
      EPercentPercent.fromObject = function fromObject(object) {
          if (object instanceof $root.EPercentPercent)
              return object;
          var message = new $root.EPercentPercent();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EPercentPercent.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EPercentPercent.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EPercentPercent message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EPercentPercent
       * @static
       * @param {EPercentPercent} message EPercentPercent
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EPercentPercent.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EPercentPercent to JSON.
       * @function toJSON
       * @memberof EPercentPercent
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EPercentPercent.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EPercentPercent;
  })();

  $root.EPlusPlus = (function() {

      /**
       * Properties of a EPlusPlus.
       * @exports IEPlusPlus
       * @interface IEPlusPlus
       * @property {IPar|null} [p1] EPlusPlus p1
       * @property {IPar|null} [p2] EPlusPlus p2
       */

      /**
       * Constructs a new EPlusPlus.
       * @exports EPlusPlus
       * @classdesc Represents a EPlusPlus.
       * @implements IEPlusPlus
       * @constructor
       * @param {IEPlusPlus=} [properties] Properties to set
       */
      function EPlusPlus(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EPlusPlus p1.
       * @member {IPar|null|undefined} p1
       * @memberof EPlusPlus
       * @instance
       */
      EPlusPlus.prototype.p1 = null;

      /**
       * EPlusPlus p2.
       * @member {IPar|null|undefined} p2
       * @memberof EPlusPlus
       * @instance
       */
      EPlusPlus.prototype.p2 = null;

      /**
       * Creates a new EPlusPlus instance using the specified properties.
       * @function create
       * @memberof EPlusPlus
       * @static
       * @param {IEPlusPlus=} [properties] Properties to set
       * @returns {EPlusPlus} EPlusPlus instance
       */
      EPlusPlus.create = function create(properties) {
          return new EPlusPlus(properties);
      };

      /**
       * Encodes the specified EPlusPlus message. Does not implicitly {@link EPlusPlus.verify|verify} messages.
       * @function encode
       * @memberof EPlusPlus
       * @static
       * @param {IEPlusPlus} message EPlusPlus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EPlusPlus.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EPlusPlus message, length delimited. Does not implicitly {@link EPlusPlus.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EPlusPlus
       * @static
       * @param {IEPlusPlus} message EPlusPlus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EPlusPlus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EPlusPlus message from the specified reader or buffer.
       * @function decode
       * @memberof EPlusPlus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EPlusPlus} EPlusPlus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EPlusPlus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EPlusPlus();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EPlusPlus message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EPlusPlus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EPlusPlus} EPlusPlus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EPlusPlus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EPlusPlus message.
       * @function verify
       * @memberof EPlusPlus
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EPlusPlus.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EPlusPlus message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EPlusPlus
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EPlusPlus} EPlusPlus
       */
      EPlusPlus.fromObject = function fromObject(object) {
          if (object instanceof $root.EPlusPlus)
              return object;
          var message = new $root.EPlusPlus();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EPlusPlus.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EPlusPlus.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EPlusPlus message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EPlusPlus
       * @static
       * @param {EPlusPlus} message EPlusPlus
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EPlusPlus.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EPlusPlus to JSON.
       * @function toJSON
       * @memberof EPlusPlus
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EPlusPlus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EPlusPlus;
  })();

  $root.EMinusMinus = (function() {

      /**
       * Properties of a EMinusMinus.
       * @exports IEMinusMinus
       * @interface IEMinusMinus
       * @property {IPar|null} [p1] EMinusMinus p1
       * @property {IPar|null} [p2] EMinusMinus p2
       */

      /**
       * Constructs a new EMinusMinus.
       * @exports EMinusMinus
       * @classdesc Represents a EMinusMinus.
       * @implements IEMinusMinus
       * @constructor
       * @param {IEMinusMinus=} [properties] Properties to set
       */
      function EMinusMinus(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * EMinusMinus p1.
       * @member {IPar|null|undefined} p1
       * @memberof EMinusMinus
       * @instance
       */
      EMinusMinus.prototype.p1 = null;

      /**
       * EMinusMinus p2.
       * @member {IPar|null|undefined} p2
       * @memberof EMinusMinus
       * @instance
       */
      EMinusMinus.prototype.p2 = null;

      /**
       * Creates a new EMinusMinus instance using the specified properties.
       * @function create
       * @memberof EMinusMinus
       * @static
       * @param {IEMinusMinus=} [properties] Properties to set
       * @returns {EMinusMinus} EMinusMinus instance
       */
      EMinusMinus.create = function create(properties) {
          return new EMinusMinus(properties);
      };

      /**
       * Encodes the specified EMinusMinus message. Does not implicitly {@link EMinusMinus.verify|verify} messages.
       * @function encode
       * @memberof EMinusMinus
       * @static
       * @param {IEMinusMinus} message EMinusMinus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMinusMinus.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.p1 != null && message.hasOwnProperty("p1"))
              $root.Par.encode(message.p1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.p2 != null && message.hasOwnProperty("p2"))
              $root.Par.encode(message.p2, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified EMinusMinus message, length delimited. Does not implicitly {@link EMinusMinus.verify|verify} messages.
       * @function encodeDelimited
       * @memberof EMinusMinus
       * @static
       * @param {IEMinusMinus} message EMinusMinus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EMinusMinus.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a EMinusMinus message from the specified reader or buffer.
       * @function decode
       * @memberof EMinusMinus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {EMinusMinus} EMinusMinus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMinusMinus.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EMinusMinus();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.p1 = $root.Par.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.p2 = $root.Par.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a EMinusMinus message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof EMinusMinus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {EMinusMinus} EMinusMinus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EMinusMinus.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a EMinusMinus message.
       * @function verify
       * @memberof EMinusMinus
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EMinusMinus.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.p1 != null && message.hasOwnProperty("p1")) {
              var error = $root.Par.verify(message.p1);
              if (error)
                  return "p1." + error;
          }
          if (message.p2 != null && message.hasOwnProperty("p2")) {
              var error = $root.Par.verify(message.p2);
              if (error)
                  return "p2." + error;
          }
          return null;
      };

      /**
       * Creates a EMinusMinus message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof EMinusMinus
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {EMinusMinus} EMinusMinus
       */
      EMinusMinus.fromObject = function fromObject(object) {
          if (object instanceof $root.EMinusMinus)
              return object;
          var message = new $root.EMinusMinus();
          if (object.p1 != null) {
              if (typeof object.p1 !== "object")
                  throw TypeError(".EMinusMinus.p1: object expected");
              message.p1 = $root.Par.fromObject(object.p1);
          }
          if (object.p2 != null) {
              if (typeof object.p2 !== "object")
                  throw TypeError(".EMinusMinus.p2: object expected");
              message.p2 = $root.Par.fromObject(object.p2);
          }
          return message;
      };

      /**
       * Creates a plain object from a EMinusMinus message. Also converts values to other types if specified.
       * @function toObject
       * @memberof EMinusMinus
       * @static
       * @param {EMinusMinus} message EMinusMinus
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EMinusMinus.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.p1 = null;
              object.p2 = null;
          }
          if (message.p1 != null && message.hasOwnProperty("p1"))
              object.p1 = $root.Par.toObject(message.p1, options);
          if (message.p2 != null && message.hasOwnProperty("p2"))
              object.p2 = $root.Par.toObject(message.p2, options);
          return object;
      };

      /**
       * Converts this EMinusMinus to JSON.
       * @function toJSON
       * @memberof EMinusMinus
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EMinusMinus.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return EMinusMinus;
  })();

  $root.Connective = (function() {

      /**
       * Properties of a Connective.
       * @exports IConnective
       * @interface IConnective
       * @property {IConnectiveBody|null} [conn_and_body] Connective conn_and_body
       * @property {IConnectiveBody|null} [conn_or_body] Connective conn_or_body
       * @property {IPar|null} [conn_not_body] Connective conn_not_body
       * @property {IVarRef|null} [var_ref_body] Connective var_ref_body
       * @property {boolean|null} [conn_bool] Connective conn_bool
       * @property {boolean|null} [conn_int] Connective conn_int
       * @property {boolean|null} [conn_string] Connective conn_string
       * @property {boolean|null} [conn_uri] Connective conn_uri
       * @property {boolean|null} [conn_byte_array] Connective conn_byte_array
       */

      /**
       * Constructs a new Connective.
       * @exports Connective
       * @classdesc Represents a Connective.
       * @implements IConnective
       * @constructor
       * @param {IConnective=} [properties] Properties to set
       */
      function Connective(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Connective conn_and_body.
       * @member {IConnectiveBody|null|undefined} conn_and_body
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_and_body = null;

      /**
       * Connective conn_or_body.
       * @member {IConnectiveBody|null|undefined} conn_or_body
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_or_body = null;

      /**
       * Connective conn_not_body.
       * @member {IPar|null|undefined} conn_not_body
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_not_body = null;

      /**
       * Connective var_ref_body.
       * @member {IVarRef|null|undefined} var_ref_body
       * @memberof Connective
       * @instance
       */
      Connective.prototype.var_ref_body = null;

      /**
       * Connective conn_bool.
       * @member {boolean} conn_bool
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_bool = false;

      /**
       * Connective conn_int.
       * @member {boolean} conn_int
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_int = false;

      /**
       * Connective conn_string.
       * @member {boolean} conn_string
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_string = false;

      /**
       * Connective conn_uri.
       * @member {boolean} conn_uri
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_uri = false;

      /**
       * Connective conn_byte_array.
       * @member {boolean} conn_byte_array
       * @memberof Connective
       * @instance
       */
      Connective.prototype.conn_byte_array = false;

      // OneOf field names bound to virtual getters and setters
      var $oneOfFields;

      /**
       * Connective connective_instance.
       * @member {"conn_and_body"|"conn_or_body"|"conn_not_body"|"var_ref_body"|"conn_bool"|"conn_int"|"conn_string"|"conn_uri"|"conn_byte_array"|undefined} connective_instance
       * @memberof Connective
       * @instance
       */
      Object.defineProperty(Connective.prototype, "connective_instance", {
          get: $util.oneOfGetter($oneOfFields = ["conn_and_body", "conn_or_body", "conn_not_body", "var_ref_body", "conn_bool", "conn_int", "conn_string", "conn_uri", "conn_byte_array"]),
          set: $util.oneOfSetter($oneOfFields)
      });

      /**
       * Creates a new Connective instance using the specified properties.
       * @function create
       * @memberof Connective
       * @static
       * @param {IConnective=} [properties] Properties to set
       * @returns {Connective} Connective instance
       */
      Connective.create = function create(properties) {
          return new Connective(properties);
      };

      /**
       * Encodes the specified Connective message. Does not implicitly {@link Connective.verify|verify} messages.
       * @function encode
       * @memberof Connective
       * @static
       * @param {IConnective} message Connective message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Connective.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.conn_and_body != null && message.hasOwnProperty("conn_and_body"))
              $root.ConnectiveBody.encode(message.conn_and_body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.conn_or_body != null && message.hasOwnProperty("conn_or_body"))
              $root.ConnectiveBody.encode(message.conn_or_body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.conn_not_body != null && message.hasOwnProperty("conn_not_body"))
              $root.Par.encode(message.conn_not_body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
          if (message.var_ref_body != null && message.hasOwnProperty("var_ref_body"))
              $root.VarRef.encode(message.var_ref_body, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
          if (message.conn_bool != null && message.hasOwnProperty("conn_bool"))
              writer.uint32(/* id 5, wireType 0 =*/40).bool(message.conn_bool);
          if (message.conn_int != null && message.hasOwnProperty("conn_int"))
              writer.uint32(/* id 6, wireType 0 =*/48).bool(message.conn_int);
          if (message.conn_string != null && message.hasOwnProperty("conn_string"))
              writer.uint32(/* id 7, wireType 0 =*/56).bool(message.conn_string);
          if (message.conn_uri != null && message.hasOwnProperty("conn_uri"))
              writer.uint32(/* id 8, wireType 0 =*/64).bool(message.conn_uri);
          if (message.conn_byte_array != null && message.hasOwnProperty("conn_byte_array"))
              writer.uint32(/* id 9, wireType 0 =*/72).bool(message.conn_byte_array);
          return writer;
      };

      /**
       * Encodes the specified Connective message, length delimited. Does not implicitly {@link Connective.verify|verify} messages.
       * @function encodeDelimited
       * @memberof Connective
       * @static
       * @param {IConnective} message Connective message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Connective.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Connective message from the specified reader or buffer.
       * @function decode
       * @memberof Connective
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {Connective} Connective
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Connective.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Connective();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.conn_and_body = $root.ConnectiveBody.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.conn_or_body = $root.ConnectiveBody.decode(reader, reader.uint32());
                  break;
              case 3:
                  message.conn_not_body = $root.Par.decode(reader, reader.uint32());
                  break;
              case 4:
                  message.var_ref_body = $root.VarRef.decode(reader, reader.uint32());
                  break;
              case 5:
                  message.conn_bool = reader.bool();
                  break;
              case 6:
                  message.conn_int = reader.bool();
                  break;
              case 7:
                  message.conn_string = reader.bool();
                  break;
              case 8:
                  message.conn_uri = reader.bool();
                  break;
              case 9:
                  message.conn_byte_array = reader.bool();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a Connective message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof Connective
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {Connective} Connective
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Connective.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Connective message.
       * @function verify
       * @memberof Connective
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Connective.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          var properties = {};
          if (message.conn_and_body != null && message.hasOwnProperty("conn_and_body")) {
              properties.connective_instance = 1;
              {
                  var error = $root.ConnectiveBody.verify(message.conn_and_body);
                  if (error)
                      return "conn_and_body." + error;
              }
          }
          if (message.conn_or_body != null && message.hasOwnProperty("conn_or_body")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              {
                  var error = $root.ConnectiveBody.verify(message.conn_or_body);
                  if (error)
                      return "conn_or_body." + error;
              }
          }
          if (message.conn_not_body != null && message.hasOwnProperty("conn_not_body")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              {
                  var error = $root.Par.verify(message.conn_not_body);
                  if (error)
                      return "conn_not_body." + error;
              }
          }
          if (message.var_ref_body != null && message.hasOwnProperty("var_ref_body")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              {
                  var error = $root.VarRef.verify(message.var_ref_body);
                  if (error)
                      return "var_ref_body." + error;
              }
          }
          if (message.conn_bool != null && message.hasOwnProperty("conn_bool")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              if (typeof message.conn_bool !== "boolean")
                  return "conn_bool: boolean expected";
          }
          if (message.conn_int != null && message.hasOwnProperty("conn_int")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              if (typeof message.conn_int !== "boolean")
                  return "conn_int: boolean expected";
          }
          if (message.conn_string != null && message.hasOwnProperty("conn_string")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              if (typeof message.conn_string !== "boolean")
                  return "conn_string: boolean expected";
          }
          if (message.conn_uri != null && message.hasOwnProperty("conn_uri")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              if (typeof message.conn_uri !== "boolean")
                  return "conn_uri: boolean expected";
          }
          if (message.conn_byte_array != null && message.hasOwnProperty("conn_byte_array")) {
              if (properties.connective_instance === 1)
                  return "connective_instance: multiple values";
              properties.connective_instance = 1;
              if (typeof message.conn_byte_array !== "boolean")
                  return "conn_byte_array: boolean expected";
          }
          return null;
      };

      /**
       * Creates a Connective message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof Connective
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {Connective} Connective
       */
      Connective.fromObject = function fromObject(object) {
          if (object instanceof $root.Connective)
              return object;
          var message = new $root.Connective();
          if (object.conn_and_body != null) {
              if (typeof object.conn_and_body !== "object")
                  throw TypeError(".Connective.conn_and_body: object expected");
              message.conn_and_body = $root.ConnectiveBody.fromObject(object.conn_and_body);
          }
          if (object.conn_or_body != null) {
              if (typeof object.conn_or_body !== "object")
                  throw TypeError(".Connective.conn_or_body: object expected");
              message.conn_or_body = $root.ConnectiveBody.fromObject(object.conn_or_body);
          }
          if (object.conn_not_body != null) {
              if (typeof object.conn_not_body !== "object")
                  throw TypeError(".Connective.conn_not_body: object expected");
              message.conn_not_body = $root.Par.fromObject(object.conn_not_body);
          }
          if (object.var_ref_body != null) {
              if (typeof object.var_ref_body !== "object")
                  throw TypeError(".Connective.var_ref_body: object expected");
              message.var_ref_body = $root.VarRef.fromObject(object.var_ref_body);
          }
          if (object.conn_bool != null)
              message.conn_bool = Boolean(object.conn_bool);
          if (object.conn_int != null)
              message.conn_int = Boolean(object.conn_int);
          if (object.conn_string != null)
              message.conn_string = Boolean(object.conn_string);
          if (object.conn_uri != null)
              message.conn_uri = Boolean(object.conn_uri);
          if (object.conn_byte_array != null)
              message.conn_byte_array = Boolean(object.conn_byte_array);
          return message;
      };

      /**
       * Creates a plain object from a Connective message. Also converts values to other types if specified.
       * @function toObject
       * @memberof Connective
       * @static
       * @param {Connective} message Connective
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Connective.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (message.conn_and_body != null && message.hasOwnProperty("conn_and_body")) {
              object.conn_and_body = $root.ConnectiveBody.toObject(message.conn_and_body, options);
              if (options.oneofs)
                  object.connective_instance = "conn_and_body";
          }
          if (message.conn_or_body != null && message.hasOwnProperty("conn_or_body")) {
              object.conn_or_body = $root.ConnectiveBody.toObject(message.conn_or_body, options);
              if (options.oneofs)
                  object.connective_instance = "conn_or_body";
          }
          if (message.conn_not_body != null && message.hasOwnProperty("conn_not_body")) {
              object.conn_not_body = $root.Par.toObject(message.conn_not_body, options);
              if (options.oneofs)
                  object.connective_instance = "conn_not_body";
          }
          if (message.var_ref_body != null && message.hasOwnProperty("var_ref_body")) {
              object.var_ref_body = $root.VarRef.toObject(message.var_ref_body, options);
              if (options.oneofs)
                  object.connective_instance = "var_ref_body";
          }
          if (message.conn_bool != null && message.hasOwnProperty("conn_bool")) {
              object.conn_bool = message.conn_bool;
              if (options.oneofs)
                  object.connective_instance = "conn_bool";
          }
          if (message.conn_int != null && message.hasOwnProperty("conn_int")) {
              object.conn_int = message.conn_int;
              if (options.oneofs)
                  object.connective_instance = "conn_int";
          }
          if (message.conn_string != null && message.hasOwnProperty("conn_string")) {
              object.conn_string = message.conn_string;
              if (options.oneofs)
                  object.connective_instance = "conn_string";
          }
          if (message.conn_uri != null && message.hasOwnProperty("conn_uri")) {
              object.conn_uri = message.conn_uri;
              if (options.oneofs)
                  object.connective_instance = "conn_uri";
          }
          if (message.conn_byte_array != null && message.hasOwnProperty("conn_byte_array")) {
              object.conn_byte_array = message.conn_byte_array;
              if (options.oneofs)
                  object.connective_instance = "conn_byte_array";
          }
          return object;
      };

      /**
       * Converts this Connective to JSON.
       * @function toJSON
       * @memberof Connective
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Connective.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return Connective;
  })();

  $root.VarRef = (function() {

      /**
       * Properties of a VarRef.
       * @exports IVarRef
       * @interface IVarRef
       * @property {number|null} [index] VarRef index
       * @property {number|null} [depth] VarRef depth
       */

      /**
       * Constructs a new VarRef.
       * @exports VarRef
       * @classdesc Represents a VarRef.
       * @implements IVarRef
       * @constructor
       * @param {IVarRef=} [properties] Properties to set
       */
      function VarRef(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * VarRef index.
       * @member {number} index
       * @memberof VarRef
       * @instance
       */
      VarRef.prototype.index = 0;

      /**
       * VarRef depth.
       * @member {number} depth
       * @memberof VarRef
       * @instance
       */
      VarRef.prototype.depth = 0;

      /**
       * Creates a new VarRef instance using the specified properties.
       * @function create
       * @memberof VarRef
       * @static
       * @param {IVarRef=} [properties] Properties to set
       * @returns {VarRef} VarRef instance
       */
      VarRef.create = function create(properties) {
          return new VarRef(properties);
      };

      /**
       * Encodes the specified VarRef message. Does not implicitly {@link VarRef.verify|verify} messages.
       * @function encode
       * @memberof VarRef
       * @static
       * @param {IVarRef} message VarRef message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      VarRef.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.index != null && message.hasOwnProperty("index"))
              writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.index);
          if (message.depth != null && message.hasOwnProperty("depth"))
              writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.depth);
          return writer;
      };

      /**
       * Encodes the specified VarRef message, length delimited. Does not implicitly {@link VarRef.verify|verify} messages.
       * @function encodeDelimited
       * @memberof VarRef
       * @static
       * @param {IVarRef} message VarRef message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      VarRef.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a VarRef message from the specified reader or buffer.
       * @function decode
       * @memberof VarRef
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {VarRef} VarRef
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      VarRef.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VarRef();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.index = reader.sint32();
                  break;
              case 2:
                  message.depth = reader.sint32();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a VarRef message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof VarRef
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {VarRef} VarRef
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      VarRef.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a VarRef message.
       * @function verify
       * @memberof VarRef
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      VarRef.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.index != null && message.hasOwnProperty("index"))
              if (!$util.isInteger(message.index))
                  return "index: integer expected";
          if (message.depth != null && message.hasOwnProperty("depth"))
              if (!$util.isInteger(message.depth))
                  return "depth: integer expected";
          return null;
      };

      /**
       * Creates a VarRef message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof VarRef
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {VarRef} VarRef
       */
      VarRef.fromObject = function fromObject(object) {
          if (object instanceof $root.VarRef)
              return object;
          var message = new $root.VarRef();
          if (object.index != null)
              message.index = object.index | 0;
          if (object.depth != null)
              message.depth = object.depth | 0;
          return message;
      };

      /**
       * Creates a plain object from a VarRef message. Also converts values to other types if specified.
       * @function toObject
       * @memberof VarRef
       * @static
       * @param {VarRef} message VarRef
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      VarRef.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults) {
              object.index = 0;
              object.depth = 0;
          }
          if (message.index != null && message.hasOwnProperty("index"))
              object.index = message.index;
          if (message.depth != null && message.hasOwnProperty("depth"))
              object.depth = message.depth;
          return object;
      };

      /**
       * Converts this VarRef to JSON.
       * @function toJSON
       * @memberof VarRef
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      VarRef.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return VarRef;
  })();

  $root.ConnectiveBody = (function() {

      /**
       * Properties of a ConnectiveBody.
       * @exports IConnectiveBody
       * @interface IConnectiveBody
       * @property {Array.<IPar>|null} [ps] ConnectiveBody ps
       */

      /**
       * Constructs a new ConnectiveBody.
       * @exports ConnectiveBody
       * @classdesc Represents a ConnectiveBody.
       * @implements IConnectiveBody
       * @constructor
       * @param {IConnectiveBody=} [properties] Properties to set
       */
      function ConnectiveBody(properties) {
          this.ps = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ConnectiveBody ps.
       * @member {Array.<IPar>} ps
       * @memberof ConnectiveBody
       * @instance
       */
      ConnectiveBody.prototype.ps = $util.emptyArray;

      /**
       * Creates a new ConnectiveBody instance using the specified properties.
       * @function create
       * @memberof ConnectiveBody
       * @static
       * @param {IConnectiveBody=} [properties] Properties to set
       * @returns {ConnectiveBody} ConnectiveBody instance
       */
      ConnectiveBody.create = function create(properties) {
          return new ConnectiveBody(properties);
      };

      /**
       * Encodes the specified ConnectiveBody message. Does not implicitly {@link ConnectiveBody.verify|verify} messages.
       * @function encode
       * @memberof ConnectiveBody
       * @static
       * @param {IConnectiveBody} message ConnectiveBody message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ConnectiveBody.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.ps != null && message.ps.length)
              for (var i = 0; i < message.ps.length; ++i)
                  $root.Par.encode(message.ps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified ConnectiveBody message, length delimited. Does not implicitly {@link ConnectiveBody.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ConnectiveBody
       * @static
       * @param {IConnectiveBody} message ConnectiveBody message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ConnectiveBody.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ConnectiveBody message from the specified reader or buffer.
       * @function decode
       * @memberof ConnectiveBody
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ConnectiveBody} ConnectiveBody
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ConnectiveBody.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectiveBody();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.ps && message.ps.length))
                      message.ps = [];
                  message.ps.push($root.Par.decode(reader, reader.uint32()));
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ConnectiveBody message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ConnectiveBody
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ConnectiveBody} ConnectiveBody
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ConnectiveBody.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ConnectiveBody message.
       * @function verify
       * @memberof ConnectiveBody
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ConnectiveBody.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.ps != null && message.hasOwnProperty("ps")) {
              if (!Array.isArray(message.ps))
                  return "ps: array expected";
              for (var i = 0; i < message.ps.length; ++i) {
                  var error = $root.Par.verify(message.ps[i]);
                  if (error)
                      return "ps." + error;
              }
          }
          return null;
      };

      /**
       * Creates a ConnectiveBody message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ConnectiveBody
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ConnectiveBody} ConnectiveBody
       */
      ConnectiveBody.fromObject = function fromObject(object) {
          if (object instanceof $root.ConnectiveBody)
              return object;
          var message = new $root.ConnectiveBody();
          if (object.ps) {
              if (!Array.isArray(object.ps))
                  throw TypeError(".ConnectiveBody.ps: array expected");
              message.ps = [];
              for (var i = 0; i < object.ps.length; ++i) {
                  if (typeof object.ps[i] !== "object")
                      throw TypeError(".ConnectiveBody.ps: object expected");
                  message.ps[i] = $root.Par.fromObject(object.ps[i]);
              }
          }
          return message;
      };

      /**
       * Creates a plain object from a ConnectiveBody message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ConnectiveBody
       * @static
       * @param {ConnectiveBody} message ConnectiveBody
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ConnectiveBody.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.ps = [];
          if (message.ps && message.ps.length) {
              object.ps = [];
              for (var j = 0; j < message.ps.length; ++j)
                  object.ps[j] = $root.Par.toObject(message.ps[j], options);
          }
          return object;
      };

      /**
       * Converts this ConnectiveBody to JSON.
       * @function toJSON
       * @memberof ConnectiveBody
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ConnectiveBody.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ConnectiveBody;
  })();

  $root.DeployId = (function() {

      /**
       * Properties of a DeployId.
       * @exports IDeployId
       * @interface IDeployId
       * @property {Uint8Array|null} [sig] DeployId sig
       */

      /**
       * Constructs a new DeployId.
       * @exports DeployId
       * @classdesc Represents a DeployId.
       * @implements IDeployId
       * @constructor
       * @param {IDeployId=} [properties] Properties to set
       */
      function DeployId(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * DeployId sig.
       * @member {Uint8Array} sig
       * @memberof DeployId
       * @instance
       */
      DeployId.prototype.sig = $util.newBuffer([]);

      /**
       * Creates a new DeployId instance using the specified properties.
       * @function create
       * @memberof DeployId
       * @static
       * @param {IDeployId=} [properties] Properties to set
       * @returns {DeployId} DeployId instance
       */
      DeployId.create = function create(properties) {
          return new DeployId(properties);
      };

      /**
       * Encodes the specified DeployId message. Does not implicitly {@link DeployId.verify|verify} messages.
       * @function encode
       * @memberof DeployId
       * @static
       * @param {IDeployId} message DeployId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DeployId.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.sig != null && message.hasOwnProperty("sig"))
              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sig);
          return writer;
      };

      /**
       * Encodes the specified DeployId message, length delimited. Does not implicitly {@link DeployId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof DeployId
       * @static
       * @param {IDeployId} message DeployId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DeployId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DeployId message from the specified reader or buffer.
       * @function decode
       * @memberof DeployId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {DeployId} DeployId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DeployId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeployId();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.sig = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a DeployId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof DeployId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {DeployId} DeployId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DeployId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DeployId message.
       * @function verify
       * @memberof DeployId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DeployId.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.sig != null && message.hasOwnProperty("sig"))
              if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                  return "sig: buffer expected";
          return null;
      };

      /**
       * Creates a DeployId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof DeployId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {DeployId} DeployId
       */
      DeployId.fromObject = function fromObject(object) {
          if (object instanceof $root.DeployId)
              return object;
          var message = new $root.DeployId();
          if (object.sig != null)
              if (typeof object.sig === "string")
                  $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
              else if (object.sig.length)
                  message.sig = object.sig;
          return message;
      };

      /**
       * Creates a plain object from a DeployId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof DeployId
       * @static
       * @param {DeployId} message DeployId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DeployId.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              if (options.bytes === String)
                  object.sig = "";
              else {
                  object.sig = [];
                  if (options.bytes !== Array)
                      object.sig = $util.newBuffer(object.sig);
              }
          if (message.sig != null && message.hasOwnProperty("sig"))
              object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
          return object;
      };

      /**
       * Converts this DeployId to JSON.
       * @function toJSON
       * @memberof DeployId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DeployId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return DeployId;
  })();

  $root.DeployerId = (function() {

      /**
       * Properties of a DeployerId.
       * @exports IDeployerId
       * @interface IDeployerId
       * @property {Uint8Array|null} [publicKey] DeployerId publicKey
       */

      /**
       * Constructs a new DeployerId.
       * @exports DeployerId
       * @classdesc Represents a DeployerId.
       * @implements IDeployerId
       * @constructor
       * @param {IDeployerId=} [properties] Properties to set
       */
      function DeployerId(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * DeployerId publicKey.
       * @member {Uint8Array} publicKey
       * @memberof DeployerId
       * @instance
       */
      DeployerId.prototype.publicKey = $util.newBuffer([]);

      /**
       * Creates a new DeployerId instance using the specified properties.
       * @function create
       * @memberof DeployerId
       * @static
       * @param {IDeployerId=} [properties] Properties to set
       * @returns {DeployerId} DeployerId instance
       */
      DeployerId.create = function create(properties) {
          return new DeployerId(properties);
      };

      /**
       * Encodes the specified DeployerId message. Does not implicitly {@link DeployerId.verify|verify} messages.
       * @function encode
       * @memberof DeployerId
       * @static
       * @param {IDeployerId} message DeployerId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DeployerId.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
          return writer;
      };

      /**
       * Encodes the specified DeployerId message, length delimited. Does not implicitly {@link DeployerId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof DeployerId
       * @static
       * @param {IDeployerId} message DeployerId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DeployerId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DeployerId message from the specified reader or buffer.
       * @function decode
       * @memberof DeployerId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {DeployerId} DeployerId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DeployerId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeployerId();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.publicKey = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a DeployerId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof DeployerId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {DeployerId} DeployerId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DeployerId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DeployerId message.
       * @function verify
       * @memberof DeployerId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DeployerId.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
              if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                  return "publicKey: buffer expected";
          return null;
      };

      /**
       * Creates a DeployerId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof DeployerId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {DeployerId} DeployerId
       */
      DeployerId.fromObject = function fromObject(object) {
          if (object instanceof $root.DeployerId)
              return object;
          var message = new $root.DeployerId();
          if (object.publicKey != null)
              if (typeof object.publicKey === "string")
                  $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
              else if (object.publicKey.length)
                  message.publicKey = object.publicKey;
          return message;
      };

      /**
       * Creates a plain object from a DeployerId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof DeployerId
       * @static
       * @param {DeployerId} message DeployerId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DeployerId.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              if (options.bytes === String)
                  object.publicKey = "";
              else {
                  object.publicKey = [];
                  if (options.bytes !== Array)
                      object.publicKey = $util.newBuffer(object.publicKey);
              }
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
              object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
          return object;
      };

      /**
       * Converts this DeployerId to JSON.
       * @function toJSON
       * @memberof DeployerId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DeployerId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return DeployerId;
  })();

  $root.GUnforgeable = (function() {

      /**
       * Properties of a GUnforgeable.
       * @exports IGUnforgeable
       * @interface IGUnforgeable
       * @property {IGPrivate|null} [g_private_body] GUnforgeable g_private_body
       * @property {IGDeployId|null} [g_deploy_id_body] GUnforgeable g_deploy_id_body
       * @property {IGDeployerId|null} [g_deployer_id_body] GUnforgeable g_deployer_id_body
       * @property {IGSysAuthToken|null} [g_sys_auth_token_body] GUnforgeable g_sys_auth_token_body
       */

      /**
       * Constructs a new GUnforgeable.
       * @exports GUnforgeable
       * @classdesc Represents a GUnforgeable.
       * @implements IGUnforgeable
       * @constructor
       * @param {IGUnforgeable=} [properties] Properties to set
       */
      function GUnforgeable(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * GUnforgeable g_private_body.
       * @member {IGPrivate|null|undefined} g_private_body
       * @memberof GUnforgeable
       * @instance
       */
      GUnforgeable.prototype.g_private_body = null;

      /**
       * GUnforgeable g_deploy_id_body.
       * @member {IGDeployId|null|undefined} g_deploy_id_body
       * @memberof GUnforgeable
       * @instance
       */
      GUnforgeable.prototype.g_deploy_id_body = null;

      /**
       * GUnforgeable g_deployer_id_body.
       * @member {IGDeployerId|null|undefined} g_deployer_id_body
       * @memberof GUnforgeable
       * @instance
       */
      GUnforgeable.prototype.g_deployer_id_body = null;

      /**
       * GUnforgeable g_sys_auth_token_body.
       * @member {IGSysAuthToken|null|undefined} g_sys_auth_token_body
       * @memberof GUnforgeable
       * @instance
       */
      GUnforgeable.prototype.g_sys_auth_token_body = null;

      // OneOf field names bound to virtual getters and setters
      var $oneOfFields;

      /**
       * GUnforgeable unf_instance.
       * @member {"g_private_body"|"g_deploy_id_body"|"g_deployer_id_body"|"g_sys_auth_token_body"|undefined} unf_instance
       * @memberof GUnforgeable
       * @instance
       */
      Object.defineProperty(GUnforgeable.prototype, "unf_instance", {
          get: $util.oneOfGetter($oneOfFields = ["g_private_body", "g_deploy_id_body", "g_deployer_id_body", "g_sys_auth_token_body"]),
          set: $util.oneOfSetter($oneOfFields)
      });

      /**
       * Creates a new GUnforgeable instance using the specified properties.
       * @function create
       * @memberof GUnforgeable
       * @static
       * @param {IGUnforgeable=} [properties] Properties to set
       * @returns {GUnforgeable} GUnforgeable instance
       */
      GUnforgeable.create = function create(properties) {
          return new GUnforgeable(properties);
      };

      /**
       * Encodes the specified GUnforgeable message. Does not implicitly {@link GUnforgeable.verify|verify} messages.
       * @function encode
       * @memberof GUnforgeable
       * @static
       * @param {IGUnforgeable} message GUnforgeable message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GUnforgeable.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.g_private_body != null && message.hasOwnProperty("g_private_body"))
              $root.GPrivate.encode(message.g_private_body, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
          if (message.g_deploy_id_body != null && message.hasOwnProperty("g_deploy_id_body"))
              $root.GDeployId.encode(message.g_deploy_id_body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
          if (message.g_deployer_id_body != null && message.hasOwnProperty("g_deployer_id_body"))
              $root.GDeployerId.encode(message.g_deployer_id_body, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
          if (message.g_sys_auth_token_body != null && message.hasOwnProperty("g_sys_auth_token_body"))
              $root.GSysAuthToken.encode(message.g_sys_auth_token_body, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
          return writer;
      };

      /**
       * Encodes the specified GUnforgeable message, length delimited. Does not implicitly {@link GUnforgeable.verify|verify} messages.
       * @function encodeDelimited
       * @memberof GUnforgeable
       * @static
       * @param {IGUnforgeable} message GUnforgeable message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GUnforgeable.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GUnforgeable message from the specified reader or buffer.
       * @function decode
       * @memberof GUnforgeable
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {GUnforgeable} GUnforgeable
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GUnforgeable.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GUnforgeable();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.g_private_body = $root.GPrivate.decode(reader, reader.uint32());
                  break;
              case 2:
                  message.g_deploy_id_body = $root.GDeployId.decode(reader, reader.uint32());
                  break;
              case 3:
                  message.g_deployer_id_body = $root.GDeployerId.decode(reader, reader.uint32());
                  break;
              case 4:
                  message.g_sys_auth_token_body = $root.GSysAuthToken.decode(reader, reader.uint32());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a GUnforgeable message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof GUnforgeable
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {GUnforgeable} GUnforgeable
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GUnforgeable.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GUnforgeable message.
       * @function verify
       * @memberof GUnforgeable
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GUnforgeable.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          var properties = {};
          if (message.g_private_body != null && message.hasOwnProperty("g_private_body")) {
              properties.unf_instance = 1;
              {
                  var error = $root.GPrivate.verify(message.g_private_body);
                  if (error)
                      return "g_private_body." + error;
              }
          }
          if (message.g_deploy_id_body != null && message.hasOwnProperty("g_deploy_id_body")) {
              if (properties.unf_instance === 1)
                  return "unf_instance: multiple values";
              properties.unf_instance = 1;
              {
                  var error = $root.GDeployId.verify(message.g_deploy_id_body);
                  if (error)
                      return "g_deploy_id_body." + error;
              }
          }
          if (message.g_deployer_id_body != null && message.hasOwnProperty("g_deployer_id_body")) {
              if (properties.unf_instance === 1)
                  return "unf_instance: multiple values";
              properties.unf_instance = 1;
              {
                  var error = $root.GDeployerId.verify(message.g_deployer_id_body);
                  if (error)
                      return "g_deployer_id_body." + error;
              }
          }
          if (message.g_sys_auth_token_body != null && message.hasOwnProperty("g_sys_auth_token_body")) {
              if (properties.unf_instance === 1)
                  return "unf_instance: multiple values";
              properties.unf_instance = 1;
              {
                  var error = $root.GSysAuthToken.verify(message.g_sys_auth_token_body);
                  if (error)
                      return "g_sys_auth_token_body." + error;
              }
          }
          return null;
      };

      /**
       * Creates a GUnforgeable message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof GUnforgeable
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {GUnforgeable} GUnforgeable
       */
      GUnforgeable.fromObject = function fromObject(object) {
          if (object instanceof $root.GUnforgeable)
              return object;
          var message = new $root.GUnforgeable();
          if (object.g_private_body != null) {
              if (typeof object.g_private_body !== "object")
                  throw TypeError(".GUnforgeable.g_private_body: object expected");
              message.g_private_body = $root.GPrivate.fromObject(object.g_private_body);
          }
          if (object.g_deploy_id_body != null) {
              if (typeof object.g_deploy_id_body !== "object")
                  throw TypeError(".GUnforgeable.g_deploy_id_body: object expected");
              message.g_deploy_id_body = $root.GDeployId.fromObject(object.g_deploy_id_body);
          }
          if (object.g_deployer_id_body != null) {
              if (typeof object.g_deployer_id_body !== "object")
                  throw TypeError(".GUnforgeable.g_deployer_id_body: object expected");
              message.g_deployer_id_body = $root.GDeployerId.fromObject(object.g_deployer_id_body);
          }
          if (object.g_sys_auth_token_body != null) {
              if (typeof object.g_sys_auth_token_body !== "object")
                  throw TypeError(".GUnforgeable.g_sys_auth_token_body: object expected");
              message.g_sys_auth_token_body = $root.GSysAuthToken.fromObject(object.g_sys_auth_token_body);
          }
          return message;
      };

      /**
       * Creates a plain object from a GUnforgeable message. Also converts values to other types if specified.
       * @function toObject
       * @memberof GUnforgeable
       * @static
       * @param {GUnforgeable} message GUnforgeable
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GUnforgeable.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (message.g_private_body != null && message.hasOwnProperty("g_private_body")) {
              object.g_private_body = $root.GPrivate.toObject(message.g_private_body, options);
              if (options.oneofs)
                  object.unf_instance = "g_private_body";
          }
          if (message.g_deploy_id_body != null && message.hasOwnProperty("g_deploy_id_body")) {
              object.g_deploy_id_body = $root.GDeployId.toObject(message.g_deploy_id_body, options);
              if (options.oneofs)
                  object.unf_instance = "g_deploy_id_body";
          }
          if (message.g_deployer_id_body != null && message.hasOwnProperty("g_deployer_id_body")) {
              object.g_deployer_id_body = $root.GDeployerId.toObject(message.g_deployer_id_body, options);
              if (options.oneofs)
                  object.unf_instance = "g_deployer_id_body";
          }
          if (message.g_sys_auth_token_body != null && message.hasOwnProperty("g_sys_auth_token_body")) {
              object.g_sys_auth_token_body = $root.GSysAuthToken.toObject(message.g_sys_auth_token_body, options);
              if (options.oneofs)
                  object.unf_instance = "g_sys_auth_token_body";
          }
          return object;
      };

      /**
       * Converts this GUnforgeable to JSON.
       * @function toJSON
       * @memberof GUnforgeable
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GUnforgeable.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return GUnforgeable;
  })();

  $root.GPrivate = (function() {

      /**
       * Properties of a GPrivate.
       * @exports IGPrivate
       * @interface IGPrivate
       * @property {Uint8Array|null} [id] GPrivate id
       */

      /**
       * Constructs a new GPrivate.
       * @exports GPrivate
       * @classdesc Represents a GPrivate.
       * @implements IGPrivate
       * @constructor
       * @param {IGPrivate=} [properties] Properties to set
       */
      function GPrivate(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * GPrivate id.
       * @member {Uint8Array} id
       * @memberof GPrivate
       * @instance
       */
      GPrivate.prototype.id = $util.newBuffer([]);

      /**
       * Creates a new GPrivate instance using the specified properties.
       * @function create
       * @memberof GPrivate
       * @static
       * @param {IGPrivate=} [properties] Properties to set
       * @returns {GPrivate} GPrivate instance
       */
      GPrivate.create = function create(properties) {
          return new GPrivate(properties);
      };

      /**
       * Encodes the specified GPrivate message. Does not implicitly {@link GPrivate.verify|verify} messages.
       * @function encode
       * @memberof GPrivate
       * @static
       * @param {IGPrivate} message GPrivate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GPrivate.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.id != null && message.hasOwnProperty("id"))
              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
          return writer;
      };

      /**
       * Encodes the specified GPrivate message, length delimited. Does not implicitly {@link GPrivate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof GPrivate
       * @static
       * @param {IGPrivate} message GPrivate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GPrivate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GPrivate message from the specified reader or buffer.
       * @function decode
       * @memberof GPrivate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {GPrivate} GPrivate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GPrivate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GPrivate();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.id = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a GPrivate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof GPrivate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {GPrivate} GPrivate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GPrivate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GPrivate message.
       * @function verify
       * @memberof GPrivate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GPrivate.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.id != null && message.hasOwnProperty("id"))
              if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                  return "id: buffer expected";
          return null;
      };

      /**
       * Creates a GPrivate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof GPrivate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {GPrivate} GPrivate
       */
      GPrivate.fromObject = function fromObject(object) {
          if (object instanceof $root.GPrivate)
              return object;
          var message = new $root.GPrivate();
          if (object.id != null)
              if (typeof object.id === "string")
                  $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
              else if (object.id.length)
                  message.id = object.id;
          return message;
      };

      /**
       * Creates a plain object from a GPrivate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof GPrivate
       * @static
       * @param {GPrivate} message GPrivate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GPrivate.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              if (options.bytes === String)
                  object.id = "";
              else {
                  object.id = [];
                  if (options.bytes !== Array)
                      object.id = $util.newBuffer(object.id);
              }
          if (message.id != null && message.hasOwnProperty("id"))
              object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
          return object;
      };

      /**
       * Converts this GPrivate to JSON.
       * @function toJSON
       * @memberof GPrivate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GPrivate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return GPrivate;
  })();

  $root.GDeployId = (function() {

      /**
       * Properties of a GDeployId.
       * @exports IGDeployId
       * @interface IGDeployId
       * @property {Uint8Array|null} [sig] GDeployId sig
       */

      /**
       * Constructs a new GDeployId.
       * @exports GDeployId
       * @classdesc Represents a GDeployId.
       * @implements IGDeployId
       * @constructor
       * @param {IGDeployId=} [properties] Properties to set
       */
      function GDeployId(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * GDeployId sig.
       * @member {Uint8Array} sig
       * @memberof GDeployId
       * @instance
       */
      GDeployId.prototype.sig = $util.newBuffer([]);

      /**
       * Creates a new GDeployId instance using the specified properties.
       * @function create
       * @memberof GDeployId
       * @static
       * @param {IGDeployId=} [properties] Properties to set
       * @returns {GDeployId} GDeployId instance
       */
      GDeployId.create = function create(properties) {
          return new GDeployId(properties);
      };

      /**
       * Encodes the specified GDeployId message. Does not implicitly {@link GDeployId.verify|verify} messages.
       * @function encode
       * @memberof GDeployId
       * @static
       * @param {IGDeployId} message GDeployId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GDeployId.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.sig != null && message.hasOwnProperty("sig"))
              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sig);
          return writer;
      };

      /**
       * Encodes the specified GDeployId message, length delimited. Does not implicitly {@link GDeployId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof GDeployId
       * @static
       * @param {IGDeployId} message GDeployId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GDeployId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GDeployId message from the specified reader or buffer.
       * @function decode
       * @memberof GDeployId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {GDeployId} GDeployId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GDeployId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GDeployId();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.sig = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a GDeployId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof GDeployId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {GDeployId} GDeployId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GDeployId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GDeployId message.
       * @function verify
       * @memberof GDeployId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GDeployId.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.sig != null && message.hasOwnProperty("sig"))
              if (!(message.sig && typeof message.sig.length === "number" || $util.isString(message.sig)))
                  return "sig: buffer expected";
          return null;
      };

      /**
       * Creates a GDeployId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof GDeployId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {GDeployId} GDeployId
       */
      GDeployId.fromObject = function fromObject(object) {
          if (object instanceof $root.GDeployId)
              return object;
          var message = new $root.GDeployId();
          if (object.sig != null)
              if (typeof object.sig === "string")
                  $util.base64.decode(object.sig, message.sig = $util.newBuffer($util.base64.length(object.sig)), 0);
              else if (object.sig.length)
                  message.sig = object.sig;
          return message;
      };

      /**
       * Creates a plain object from a GDeployId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof GDeployId
       * @static
       * @param {GDeployId} message GDeployId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GDeployId.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              if (options.bytes === String)
                  object.sig = "";
              else {
                  object.sig = [];
                  if (options.bytes !== Array)
                      object.sig = $util.newBuffer(object.sig);
              }
          if (message.sig != null && message.hasOwnProperty("sig"))
              object.sig = options.bytes === String ? $util.base64.encode(message.sig, 0, message.sig.length) : options.bytes === Array ? Array.prototype.slice.call(message.sig) : message.sig;
          return object;
      };

      /**
       * Converts this GDeployId to JSON.
       * @function toJSON
       * @memberof GDeployId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GDeployId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return GDeployId;
  })();

  $root.GDeployerId = (function() {

      /**
       * Properties of a GDeployerId.
       * @exports IGDeployerId
       * @interface IGDeployerId
       * @property {Uint8Array|null} [publicKey] GDeployerId publicKey
       */

      /**
       * Constructs a new GDeployerId.
       * @exports GDeployerId
       * @classdesc Represents a GDeployerId.
       * @implements IGDeployerId
       * @constructor
       * @param {IGDeployerId=} [properties] Properties to set
       */
      function GDeployerId(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * GDeployerId publicKey.
       * @member {Uint8Array} publicKey
       * @memberof GDeployerId
       * @instance
       */
      GDeployerId.prototype.publicKey = $util.newBuffer([]);

      /**
       * Creates a new GDeployerId instance using the specified properties.
       * @function create
       * @memberof GDeployerId
       * @static
       * @param {IGDeployerId=} [properties] Properties to set
       * @returns {GDeployerId} GDeployerId instance
       */
      GDeployerId.create = function create(properties) {
          return new GDeployerId(properties);
      };

      /**
       * Encodes the specified GDeployerId message. Does not implicitly {@link GDeployerId.verify|verify} messages.
       * @function encode
       * @memberof GDeployerId
       * @static
       * @param {IGDeployerId} message GDeployerId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GDeployerId.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
              writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
          return writer;
      };

      /**
       * Encodes the specified GDeployerId message, length delimited. Does not implicitly {@link GDeployerId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof GDeployerId
       * @static
       * @param {IGDeployerId} message GDeployerId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GDeployerId.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GDeployerId message from the specified reader or buffer.
       * @function decode
       * @memberof GDeployerId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {GDeployerId} GDeployerId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GDeployerId.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GDeployerId();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  message.publicKey = reader.bytes();
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a GDeployerId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof GDeployerId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {GDeployerId} GDeployerId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GDeployerId.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GDeployerId message.
       * @function verify
       * @memberof GDeployerId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GDeployerId.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
              if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                  return "publicKey: buffer expected";
          return null;
      };

      /**
       * Creates a GDeployerId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof GDeployerId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {GDeployerId} GDeployerId
       */
      GDeployerId.fromObject = function fromObject(object) {
          if (object instanceof $root.GDeployerId)
              return object;
          var message = new $root.GDeployerId();
          if (object.publicKey != null)
              if (typeof object.publicKey === "string")
                  $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
              else if (object.publicKey.length)
                  message.publicKey = object.publicKey;
          return message;
      };

      /**
       * Creates a plain object from a GDeployerId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof GDeployerId
       * @static
       * @param {GDeployerId} message GDeployerId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GDeployerId.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.defaults)
              if (options.bytes === String)
                  object.publicKey = "";
              else {
                  object.publicKey = [];
                  if (options.bytes !== Array)
                      object.publicKey = $util.newBuffer(object.publicKey);
              }
          if (message.publicKey != null && message.hasOwnProperty("publicKey"))
              object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
          return object;
      };

      /**
       * Converts this GDeployerId to JSON.
       * @function toJSON
       * @memberof GDeployerId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GDeployerId.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return GDeployerId;
  })();

  $root.GSysAuthToken = (function() {

      /**
       * Properties of a GSysAuthToken.
       * @exports IGSysAuthToken
       * @interface IGSysAuthToken
       */

      /**
       * Constructs a new GSysAuthToken.
       * @exports GSysAuthToken
       * @classdesc Represents a GSysAuthToken.
       * @implements IGSysAuthToken
       * @constructor
       * @param {IGSysAuthToken=} [properties] Properties to set
       */
      function GSysAuthToken(properties) {
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * Creates a new GSysAuthToken instance using the specified properties.
       * @function create
       * @memberof GSysAuthToken
       * @static
       * @param {IGSysAuthToken=} [properties] Properties to set
       * @returns {GSysAuthToken} GSysAuthToken instance
       */
      GSysAuthToken.create = function create(properties) {
          return new GSysAuthToken(properties);
      };

      /**
       * Encodes the specified GSysAuthToken message. Does not implicitly {@link GSysAuthToken.verify|verify} messages.
       * @function encode
       * @memberof GSysAuthToken
       * @static
       * @param {IGSysAuthToken} message GSysAuthToken message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GSysAuthToken.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          return writer;
      };

      /**
       * Encodes the specified GSysAuthToken message, length delimited. Does not implicitly {@link GSysAuthToken.verify|verify} messages.
       * @function encodeDelimited
       * @memberof GSysAuthToken
       * @static
       * @param {IGSysAuthToken} message GSysAuthToken message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GSysAuthToken.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GSysAuthToken message from the specified reader or buffer.
       * @function decode
       * @memberof GSysAuthToken
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {GSysAuthToken} GSysAuthToken
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GSysAuthToken.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GSysAuthToken();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a GSysAuthToken message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof GSysAuthToken
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {GSysAuthToken} GSysAuthToken
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GSysAuthToken.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GSysAuthToken message.
       * @function verify
       * @memberof GSysAuthToken
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GSysAuthToken.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          return null;
      };

      /**
       * Creates a GSysAuthToken message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof GSysAuthToken
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {GSysAuthToken} GSysAuthToken
       */
      GSysAuthToken.fromObject = function fromObject(object) {
          if (object instanceof $root.GSysAuthToken)
              return object;
          return new $root.GSysAuthToken();
      };

      /**
       * Creates a plain object from a GSysAuthToken message. Also converts values to other types if specified.
       * @function toObject
       * @memberof GSysAuthToken
       * @static
       * @param {GSysAuthToken} message GSysAuthToken
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GSysAuthToken.toObject = function toObject() {
          return {};
      };

      /**
       * Converts this GSysAuthToken to JSON.
       * @function toJSON
       * @memberof GSysAuthToken
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GSysAuthToken.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return GSysAuthToken;
  })();

  $root.ServiceError = (function() {

      /**
       * Properties of a ServiceError.
       * @exports IServiceError
       * @interface IServiceError
       * @property {Array.<string>|null} [messages] ServiceError messages
       */

      /**
       * Constructs a new ServiceError.
       * @exports ServiceError
       * @classdesc Represents a ServiceError.
       * @implements IServiceError
       * @constructor
       * @param {IServiceError=} [properties] Properties to set
       */
      function ServiceError(properties) {
          this.messages = [];
          if (properties)
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceError messages.
       * @member {Array.<string>} messages
       * @memberof ServiceError
       * @instance
       */
      ServiceError.prototype.messages = $util.emptyArray;

      /**
       * Creates a new ServiceError instance using the specified properties.
       * @function create
       * @memberof ServiceError
       * @static
       * @param {IServiceError=} [properties] Properties to set
       * @returns {ServiceError} ServiceError instance
       */
      ServiceError.create = function create(properties) {
          return new ServiceError(properties);
      };

      /**
       * Encodes the specified ServiceError message. Does not implicitly {@link ServiceError.verify|verify} messages.
       * @function encode
       * @memberof ServiceError
       * @static
       * @param {IServiceError} message ServiceError message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceError.encode = function encode(message, writer) {
          if (!writer)
              writer = $Writer.create();
          if (message.messages != null && message.messages.length)
              for (var i = 0; i < message.messages.length; ++i)
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.messages[i]);
          return writer;
      };

      /**
       * Encodes the specified ServiceError message, length delimited. Does not implicitly {@link ServiceError.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ServiceError
       * @static
       * @param {IServiceError} message ServiceError message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceError.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceError message from the specified reader or buffer.
       * @function decode
       * @memberof ServiceError
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ServiceError} ServiceError
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceError.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
          var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceError();
          while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
              case 1:
                  if (!(message.messages && message.messages.length))
                      message.messages = [];
                  message.messages.push(reader.string());
                  break;
              default:
                  reader.skipType(tag & 7);
                  break;
              }
          }
          return message;
      };

      /**
       * Decodes a ServiceError message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ServiceError
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ServiceError} ServiceError
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceError.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceError message.
       * @function verify
       * @memberof ServiceError
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceError.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
              return "object expected";
          if (message.messages != null && message.hasOwnProperty("messages")) {
              if (!Array.isArray(message.messages))
                  return "messages: array expected";
              for (var i = 0; i < message.messages.length; ++i)
                  if (!$util.isString(message.messages[i]))
                      return "messages: string[] expected";
          }
          return null;
      };

      /**
       * Creates a ServiceError message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ServiceError
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ServiceError} ServiceError
       */
      ServiceError.fromObject = function fromObject(object) {
          if (object instanceof $root.ServiceError)
              return object;
          var message = new $root.ServiceError();
          if (object.messages) {
              if (!Array.isArray(object.messages))
                  throw TypeError(".ServiceError.messages: array expected");
              message.messages = [];
              for (var i = 0; i < object.messages.length; ++i)
                  message.messages[i] = String(object.messages[i]);
          }
          return message;
      };

      /**
       * Creates a plain object from a ServiceError message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ServiceError
       * @static
       * @param {ServiceError} message ServiceError
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceError.toObject = function toObject(message, options) {
          if (!options)
              options = {};
          var object = {};
          if (options.arrays || options.defaults)
              object.messages = [];
          if (message.messages && message.messages.length) {
              object.messages = [];
              for (var j = 0; j < message.messages.length; ++j)
                  object.messages[j] = message.messages[j];
          }
          return object;
      };

      /**
       * Converts this ServiceError to JSON.
       * @function toJSON
       * @memberof ServiceError
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceError.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
      };

      return ServiceError;
  })();

  $root.routing = (function() {

      /**
       * Namespace routing.
       * @exports routing
       * @namespace
       */
      var routing = {};

      routing.Node = (function() {

          /**
           * Properties of a Node.
           * @memberof routing
           * @interface INode
           * @property {Uint8Array|null} [id] Node id
           * @property {Uint8Array|null} [host] Node host
           * @property {number|null} [tcp_port] Node tcp_port
           * @property {number|null} [udp_port] Node udp_port
           */

          /**
           * Constructs a new Node.
           * @memberof routing
           * @classdesc Represents a Node.
           * @implements INode
           * @constructor
           * @param {routing.INode=} [properties] Properties to set
           */
          function Node(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Node id.
           * @member {Uint8Array} id
           * @memberof routing.Node
           * @instance
           */
          Node.prototype.id = $util.newBuffer([]);

          /**
           * Node host.
           * @member {Uint8Array} host
           * @memberof routing.Node
           * @instance
           */
          Node.prototype.host = $util.newBuffer([]);

          /**
           * Node tcp_port.
           * @member {number} tcp_port
           * @memberof routing.Node
           * @instance
           */
          Node.prototype.tcp_port = 0;

          /**
           * Node udp_port.
           * @member {number} udp_port
           * @memberof routing.Node
           * @instance
           */
          Node.prototype.udp_port = 0;

          /**
           * Creates a new Node instance using the specified properties.
           * @function create
           * @memberof routing.Node
           * @static
           * @param {routing.INode=} [properties] Properties to set
           * @returns {routing.Node} Node instance
           */
          Node.create = function create(properties) {
              return new Node(properties);
          };

          /**
           * Encodes the specified Node message. Does not implicitly {@link routing.Node.verify|verify} messages.
           * @function encode
           * @memberof routing.Node
           * @static
           * @param {routing.INode} message Node message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Node.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.id != null && message.hasOwnProperty("id"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
              if (message.host != null && message.hasOwnProperty("host"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.host);
              if (message.tcp_port != null && message.hasOwnProperty("tcp_port"))
                  writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tcp_port);
              if (message.udp_port != null && message.hasOwnProperty("udp_port"))
                  writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.udp_port);
              return writer;
          };

          /**
           * Encodes the specified Node message, length delimited. Does not implicitly {@link routing.Node.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Node
           * @static
           * @param {routing.INode} message Node message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Node.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Node message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Node
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Node} Node
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Node.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Node();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.id = reader.bytes();
                      break;
                  case 2:
                      message.host = reader.bytes();
                      break;
                  case 3:
                      message.tcp_port = reader.uint32();
                      break;
                  case 4:
                      message.udp_port = reader.uint32();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Node message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Node
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Node} Node
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Node.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Node message.
           * @function verify
           * @memberof routing.Node
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Node.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                  if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                      return "id: buffer expected";
              if (message.host != null && message.hasOwnProperty("host"))
                  if (!(message.host && typeof message.host.length === "number" || $util.isString(message.host)))
                      return "host: buffer expected";
              if (message.tcp_port != null && message.hasOwnProperty("tcp_port"))
                  if (!$util.isInteger(message.tcp_port))
                      return "tcp_port: integer expected";
              if (message.udp_port != null && message.hasOwnProperty("udp_port"))
                  if (!$util.isInteger(message.udp_port))
                      return "udp_port: integer expected";
              return null;
          };

          /**
           * Creates a Node message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Node
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Node} Node
           */
          Node.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Node)
                  return object;
              var message = new $root.routing.Node();
              if (object.id != null)
                  if (typeof object.id === "string")
                      $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                  else if (object.id.length)
                      message.id = object.id;
              if (object.host != null)
                  if (typeof object.host === "string")
                      $util.base64.decode(object.host, message.host = $util.newBuffer($util.base64.length(object.host)), 0);
                  else if (object.host.length)
                      message.host = object.host;
              if (object.tcp_port != null)
                  message.tcp_port = object.tcp_port >>> 0;
              if (object.udp_port != null)
                  message.udp_port = object.udp_port >>> 0;
              return message;
          };

          /**
           * Creates a plain object from a Node message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Node
           * @static
           * @param {routing.Node} message Node
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Node.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  if (options.bytes === String)
                      object.id = "";
                  else {
                      object.id = [];
                      if (options.bytes !== Array)
                          object.id = $util.newBuffer(object.id);
                  }
                  if (options.bytes === String)
                      object.host = "";
                  else {
                      object.host = [];
                      if (options.bytes !== Array)
                          object.host = $util.newBuffer(object.host);
                  }
                  object.tcp_port = 0;
                  object.udp_port = 0;
              }
              if (message.id != null && message.hasOwnProperty("id"))
                  object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
              if (message.host != null && message.hasOwnProperty("host"))
                  object.host = options.bytes === String ? $util.base64.encode(message.host, 0, message.host.length) : options.bytes === Array ? Array.prototype.slice.call(message.host) : message.host;
              if (message.tcp_port != null && message.hasOwnProperty("tcp_port"))
                  object.tcp_port = message.tcp_port;
              if (message.udp_port != null && message.hasOwnProperty("udp_port"))
                  object.udp_port = message.udp_port;
              return object;
          };

          /**
           * Converts this Node to JSON.
           * @function toJSON
           * @memberof routing.Node
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Node.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Node;
      })();

      routing.Header = (function() {

          /**
           * Properties of a Header.
           * @memberof routing
           * @interface IHeader
           * @property {routing.INode|null} [sender] Header sender
           * @property {string|null} [networkId] Header networkId
           */

          /**
           * Constructs a new Header.
           * @memberof routing
           * @classdesc Represents a Header.
           * @implements IHeader
           * @constructor
           * @param {routing.IHeader=} [properties] Properties to set
           */
          function Header(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Header sender.
           * @member {routing.INode|null|undefined} sender
           * @memberof routing.Header
           * @instance
           */
          Header.prototype.sender = null;

          /**
           * Header networkId.
           * @member {string} networkId
           * @memberof routing.Header
           * @instance
           */
          Header.prototype.networkId = "";

          /**
           * Creates a new Header instance using the specified properties.
           * @function create
           * @memberof routing.Header
           * @static
           * @param {routing.IHeader=} [properties] Properties to set
           * @returns {routing.Header} Header instance
           */
          Header.create = function create(properties) {
              return new Header(properties);
          };

          /**
           * Encodes the specified Header message. Does not implicitly {@link routing.Header.verify|verify} messages.
           * @function encode
           * @memberof routing.Header
           * @static
           * @param {routing.IHeader} message Header message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Header.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.sender != null && message.hasOwnProperty("sender"))
                  $root.routing.Node.encode(message.sender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.networkId != null && message.hasOwnProperty("networkId"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.networkId);
              return writer;
          };

          /**
           * Encodes the specified Header message, length delimited. Does not implicitly {@link routing.Header.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Header
           * @static
           * @param {routing.IHeader} message Header message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Header.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Header message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Header
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Header} Header
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Header.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Header();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.sender = $root.routing.Node.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.networkId = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Header message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Header
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Header} Header
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Header.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Header message.
           * @function verify
           * @memberof routing.Header
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Header.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.sender != null && message.hasOwnProperty("sender")) {
                  var error = $root.routing.Node.verify(message.sender);
                  if (error)
                      return "sender." + error;
              }
              if (message.networkId != null && message.hasOwnProperty("networkId"))
                  if (!$util.isString(message.networkId))
                      return "networkId: string expected";
              return null;
          };

          /**
           * Creates a Header message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Header
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Header} Header
           */
          Header.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Header)
                  return object;
              var message = new $root.routing.Header();
              if (object.sender != null) {
                  if (typeof object.sender !== "object")
                      throw TypeError(".routing.Header.sender: object expected");
                  message.sender = $root.routing.Node.fromObject(object.sender);
              }
              if (object.networkId != null)
                  message.networkId = String(object.networkId);
              return message;
          };

          /**
           * Creates a plain object from a Header message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Header
           * @static
           * @param {routing.Header} message Header
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Header.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.sender = null;
                  object.networkId = "";
              }
              if (message.sender != null && message.hasOwnProperty("sender"))
                  object.sender = $root.routing.Node.toObject(message.sender, options);
              if (message.networkId != null && message.hasOwnProperty("networkId"))
                  object.networkId = message.networkId;
              return object;
          };

          /**
           * Converts this Header to JSON.
           * @function toJSON
           * @memberof routing.Header
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Header.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Header;
      })();

      routing.Heartbeat = (function() {

          /**
           * Properties of a Heartbeat.
           * @memberof routing
           * @interface IHeartbeat
           */

          /**
           * Constructs a new Heartbeat.
           * @memberof routing
           * @classdesc Represents a Heartbeat.
           * @implements IHeartbeat
           * @constructor
           * @param {routing.IHeartbeat=} [properties] Properties to set
           */
          function Heartbeat(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new Heartbeat instance using the specified properties.
           * @function create
           * @memberof routing.Heartbeat
           * @static
           * @param {routing.IHeartbeat=} [properties] Properties to set
           * @returns {routing.Heartbeat} Heartbeat instance
           */
          Heartbeat.create = function create(properties) {
              return new Heartbeat(properties);
          };

          /**
           * Encodes the specified Heartbeat message. Does not implicitly {@link routing.Heartbeat.verify|verify} messages.
           * @function encode
           * @memberof routing.Heartbeat
           * @static
           * @param {routing.IHeartbeat} message Heartbeat message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Heartbeat.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified Heartbeat message, length delimited. Does not implicitly {@link routing.Heartbeat.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Heartbeat
           * @static
           * @param {routing.IHeartbeat} message Heartbeat message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Heartbeat.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Heartbeat message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Heartbeat
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Heartbeat} Heartbeat
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Heartbeat.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Heartbeat();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Heartbeat message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Heartbeat
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Heartbeat} Heartbeat
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Heartbeat.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Heartbeat message.
           * @function verify
           * @memberof routing.Heartbeat
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Heartbeat.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a Heartbeat message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Heartbeat
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Heartbeat} Heartbeat
           */
          Heartbeat.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Heartbeat)
                  return object;
              return new $root.routing.Heartbeat();
          };

          /**
           * Creates a plain object from a Heartbeat message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Heartbeat
           * @static
           * @param {routing.Heartbeat} message Heartbeat
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Heartbeat.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this Heartbeat to JSON.
           * @function toJSON
           * @memberof routing.Heartbeat
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Heartbeat.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Heartbeat;
      })();

      routing.HeartbeatResponse = (function() {

          /**
           * Properties of a HeartbeatResponse.
           * @memberof routing
           * @interface IHeartbeatResponse
           */

          /**
           * Constructs a new HeartbeatResponse.
           * @memberof routing
           * @classdesc Represents a HeartbeatResponse.
           * @implements IHeartbeatResponse
           * @constructor
           * @param {routing.IHeartbeatResponse=} [properties] Properties to set
           */
          function HeartbeatResponse(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new HeartbeatResponse instance using the specified properties.
           * @function create
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {routing.IHeartbeatResponse=} [properties] Properties to set
           * @returns {routing.HeartbeatResponse} HeartbeatResponse instance
           */
          HeartbeatResponse.create = function create(properties) {
              return new HeartbeatResponse(properties);
          };

          /**
           * Encodes the specified HeartbeatResponse message. Does not implicitly {@link routing.HeartbeatResponse.verify|verify} messages.
           * @function encode
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {routing.IHeartbeatResponse} message HeartbeatResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HeartbeatResponse.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified HeartbeatResponse message, length delimited. Does not implicitly {@link routing.HeartbeatResponse.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {routing.IHeartbeatResponse} message HeartbeatResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          HeartbeatResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a HeartbeatResponse message from the specified reader or buffer.
           * @function decode
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.HeartbeatResponse} HeartbeatResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HeartbeatResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.HeartbeatResponse();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a HeartbeatResponse message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.HeartbeatResponse} HeartbeatResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          HeartbeatResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a HeartbeatResponse message.
           * @function verify
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          HeartbeatResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a HeartbeatResponse message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.HeartbeatResponse} HeartbeatResponse
           */
          HeartbeatResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.HeartbeatResponse)
                  return object;
              return new $root.routing.HeartbeatResponse();
          };

          /**
           * Creates a plain object from a HeartbeatResponse message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.HeartbeatResponse
           * @static
           * @param {routing.HeartbeatResponse} message HeartbeatResponse
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          HeartbeatResponse.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this HeartbeatResponse to JSON.
           * @function toJSON
           * @memberof routing.HeartbeatResponse
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          HeartbeatResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return HeartbeatResponse;
      })();

      routing.ProtocolHandshake = (function() {

          /**
           * Properties of a ProtocolHandshake.
           * @memberof routing
           * @interface IProtocolHandshake
           * @property {Uint8Array|null} [nonce] ProtocolHandshake nonce
           */

          /**
           * Constructs a new ProtocolHandshake.
           * @memberof routing
           * @classdesc Represents a ProtocolHandshake.
           * @implements IProtocolHandshake
           * @constructor
           * @param {routing.IProtocolHandshake=} [properties] Properties to set
           */
          function ProtocolHandshake(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ProtocolHandshake nonce.
           * @member {Uint8Array} nonce
           * @memberof routing.ProtocolHandshake
           * @instance
           */
          ProtocolHandshake.prototype.nonce = $util.newBuffer([]);

          /**
           * Creates a new ProtocolHandshake instance using the specified properties.
           * @function create
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {routing.IProtocolHandshake=} [properties] Properties to set
           * @returns {routing.ProtocolHandshake} ProtocolHandshake instance
           */
          ProtocolHandshake.create = function create(properties) {
              return new ProtocolHandshake(properties);
          };

          /**
           * Encodes the specified ProtocolHandshake message. Does not implicitly {@link routing.ProtocolHandshake.verify|verify} messages.
           * @function encode
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {routing.IProtocolHandshake} message ProtocolHandshake message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProtocolHandshake.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.nonce != null && message.hasOwnProperty("nonce"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
              return writer;
          };

          /**
           * Encodes the specified ProtocolHandshake message, length delimited. Does not implicitly {@link routing.ProtocolHandshake.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {routing.IProtocolHandshake} message ProtocolHandshake message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProtocolHandshake.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ProtocolHandshake message from the specified reader or buffer.
           * @function decode
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.ProtocolHandshake} ProtocolHandshake
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProtocolHandshake.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ProtocolHandshake();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.nonce = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ProtocolHandshake message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.ProtocolHandshake} ProtocolHandshake
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProtocolHandshake.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ProtocolHandshake message.
           * @function verify
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ProtocolHandshake.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.nonce != null && message.hasOwnProperty("nonce"))
                  if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                      return "nonce: buffer expected";
              return null;
          };

          /**
           * Creates a ProtocolHandshake message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.ProtocolHandshake} ProtocolHandshake
           */
          ProtocolHandshake.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.ProtocolHandshake)
                  return object;
              var message = new $root.routing.ProtocolHandshake();
              if (object.nonce != null)
                  if (typeof object.nonce === "string")
                      $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                  else if (object.nonce.length)
                      message.nonce = object.nonce;
              return message;
          };

          /**
           * Creates a plain object from a ProtocolHandshake message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.ProtocolHandshake
           * @static
           * @param {routing.ProtocolHandshake} message ProtocolHandshake
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ProtocolHandshake.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.nonce = "";
                  else {
                      object.nonce = [];
                      if (options.bytes !== Array)
                          object.nonce = $util.newBuffer(object.nonce);
                  }
              if (message.nonce != null && message.hasOwnProperty("nonce"))
                  object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
              return object;
          };

          /**
           * Converts this ProtocolHandshake to JSON.
           * @function toJSON
           * @memberof routing.ProtocolHandshake
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ProtocolHandshake.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ProtocolHandshake;
      })();

      routing.ProtocolHandshakeResponse = (function() {

          /**
           * Properties of a ProtocolHandshakeResponse.
           * @memberof routing
           * @interface IProtocolHandshakeResponse
           * @property {Uint8Array|null} [nonce] ProtocolHandshakeResponse nonce
           */

          /**
           * Constructs a new ProtocolHandshakeResponse.
           * @memberof routing
           * @classdesc Represents a ProtocolHandshakeResponse.
           * @implements IProtocolHandshakeResponse
           * @constructor
           * @param {routing.IProtocolHandshakeResponse=} [properties] Properties to set
           */
          function ProtocolHandshakeResponse(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ProtocolHandshakeResponse nonce.
           * @member {Uint8Array} nonce
           * @memberof routing.ProtocolHandshakeResponse
           * @instance
           */
          ProtocolHandshakeResponse.prototype.nonce = $util.newBuffer([]);

          /**
           * Creates a new ProtocolHandshakeResponse instance using the specified properties.
           * @function create
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {routing.IProtocolHandshakeResponse=} [properties] Properties to set
           * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse instance
           */
          ProtocolHandshakeResponse.create = function create(properties) {
              return new ProtocolHandshakeResponse(properties);
          };

          /**
           * Encodes the specified ProtocolHandshakeResponse message. Does not implicitly {@link routing.ProtocolHandshakeResponse.verify|verify} messages.
           * @function encode
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {routing.IProtocolHandshakeResponse} message ProtocolHandshakeResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProtocolHandshakeResponse.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.nonce != null && message.hasOwnProperty("nonce"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
              return writer;
          };

          /**
           * Encodes the specified ProtocolHandshakeResponse message, length delimited. Does not implicitly {@link routing.ProtocolHandshakeResponse.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {routing.IProtocolHandshakeResponse} message ProtocolHandshakeResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ProtocolHandshakeResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ProtocolHandshakeResponse message from the specified reader or buffer.
           * @function decode
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProtocolHandshakeResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ProtocolHandshakeResponse();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.nonce = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ProtocolHandshakeResponse message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ProtocolHandshakeResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ProtocolHandshakeResponse message.
           * @function verify
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ProtocolHandshakeResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.nonce != null && message.hasOwnProperty("nonce"))
                  if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                      return "nonce: buffer expected";
              return null;
          };

          /**
           * Creates a ProtocolHandshakeResponse message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.ProtocolHandshakeResponse} ProtocolHandshakeResponse
           */
          ProtocolHandshakeResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.ProtocolHandshakeResponse)
                  return object;
              var message = new $root.routing.ProtocolHandshakeResponse();
              if (object.nonce != null)
                  if (typeof object.nonce === "string")
                      $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                  else if (object.nonce.length)
                      message.nonce = object.nonce;
              return message;
          };

          /**
           * Creates a plain object from a ProtocolHandshakeResponse message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.ProtocolHandshakeResponse
           * @static
           * @param {routing.ProtocolHandshakeResponse} message ProtocolHandshakeResponse
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ProtocolHandshakeResponse.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.nonce = "";
                  else {
                      object.nonce = [];
                      if (options.bytes !== Array)
                          object.nonce = $util.newBuffer(object.nonce);
                  }
              if (message.nonce != null && message.hasOwnProperty("nonce"))
                  object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
              return object;
          };

          /**
           * Converts this ProtocolHandshakeResponse to JSON.
           * @function toJSON
           * @memberof routing.ProtocolHandshakeResponse
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ProtocolHandshakeResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ProtocolHandshakeResponse;
      })();

      routing.Packet = (function() {

          /**
           * Properties of a Packet.
           * @memberof routing
           * @interface IPacket
           * @property {string|null} [typeId] Packet typeId
           * @property {Uint8Array|null} [content] Packet content
           */

          /**
           * Constructs a new Packet.
           * @memberof routing
           * @classdesc Represents a Packet.
           * @implements IPacket
           * @constructor
           * @param {routing.IPacket=} [properties] Properties to set
           */
          function Packet(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Packet typeId.
           * @member {string} typeId
           * @memberof routing.Packet
           * @instance
           */
          Packet.prototype.typeId = "";

          /**
           * Packet content.
           * @member {Uint8Array} content
           * @memberof routing.Packet
           * @instance
           */
          Packet.prototype.content = $util.newBuffer([]);

          /**
           * Creates a new Packet instance using the specified properties.
           * @function create
           * @memberof routing.Packet
           * @static
           * @param {routing.IPacket=} [properties] Properties to set
           * @returns {routing.Packet} Packet instance
           */
          Packet.create = function create(properties) {
              return new Packet(properties);
          };

          /**
           * Encodes the specified Packet message. Does not implicitly {@link routing.Packet.verify|verify} messages.
           * @function encode
           * @memberof routing.Packet
           * @static
           * @param {routing.IPacket} message Packet message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Packet.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.typeId != null && message.hasOwnProperty("typeId"))
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.typeId);
              if (message.content != null && message.hasOwnProperty("content"))
                  writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
              return writer;
          };

          /**
           * Encodes the specified Packet message, length delimited. Does not implicitly {@link routing.Packet.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Packet
           * @static
           * @param {routing.IPacket} message Packet message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Packet.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Packet message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Packet
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Packet} Packet
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Packet.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Packet();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.typeId = reader.string();
                      break;
                  case 2:
                      message.content = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Packet message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Packet
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Packet} Packet
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Packet.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Packet message.
           * @function verify
           * @memberof routing.Packet
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Packet.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.typeId != null && message.hasOwnProperty("typeId"))
                  if (!$util.isString(message.typeId))
                      return "typeId: string expected";
              if (message.content != null && message.hasOwnProperty("content"))
                  if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                      return "content: buffer expected";
              return null;
          };

          /**
           * Creates a Packet message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Packet
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Packet} Packet
           */
          Packet.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Packet)
                  return object;
              var message = new $root.routing.Packet();
              if (object.typeId != null)
                  message.typeId = String(object.typeId);
              if (object.content != null)
                  if (typeof object.content === "string")
                      $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                  else if (object.content.length)
                      message.content = object.content;
              return message;
          };

          /**
           * Creates a plain object from a Packet message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Packet
           * @static
           * @param {routing.Packet} message Packet
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Packet.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.typeId = "";
                  if (options.bytes === String)
                      object.content = "";
                  else {
                      object.content = [];
                      if (options.bytes !== Array)
                          object.content = $util.newBuffer(object.content);
                  }
              }
              if (message.typeId != null && message.hasOwnProperty("typeId"))
                  object.typeId = message.typeId;
              if (message.content != null && message.hasOwnProperty("content"))
                  object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
              return object;
          };

          /**
           * Converts this Packet to JSON.
           * @function toJSON
           * @memberof routing.Packet
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Packet.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Packet;
      })();

      routing.Disconnect = (function() {

          /**
           * Properties of a Disconnect.
           * @memberof routing
           * @interface IDisconnect
           */

          /**
           * Constructs a new Disconnect.
           * @memberof routing
           * @classdesc Represents a Disconnect.
           * @implements IDisconnect
           * @constructor
           * @param {routing.IDisconnect=} [properties] Properties to set
           */
          function Disconnect(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Creates a new Disconnect instance using the specified properties.
           * @function create
           * @memberof routing.Disconnect
           * @static
           * @param {routing.IDisconnect=} [properties] Properties to set
           * @returns {routing.Disconnect} Disconnect instance
           */
          Disconnect.create = function create(properties) {
              return new Disconnect(properties);
          };

          /**
           * Encodes the specified Disconnect message. Does not implicitly {@link routing.Disconnect.verify|verify} messages.
           * @function encode
           * @memberof routing.Disconnect
           * @static
           * @param {routing.IDisconnect} message Disconnect message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Disconnect.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              return writer;
          };

          /**
           * Encodes the specified Disconnect message, length delimited. Does not implicitly {@link routing.Disconnect.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Disconnect
           * @static
           * @param {routing.IDisconnect} message Disconnect message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Disconnect message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Disconnect
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Disconnect} Disconnect
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Disconnect.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Disconnect();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Disconnect message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Disconnect
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Disconnect} Disconnect
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Disconnect.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Disconnect message.
           * @function verify
           * @memberof routing.Disconnect
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Disconnect.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              return null;
          };

          /**
           * Creates a Disconnect message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Disconnect
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Disconnect} Disconnect
           */
          Disconnect.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Disconnect)
                  return object;
              return new $root.routing.Disconnect();
          };

          /**
           * Creates a plain object from a Disconnect message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Disconnect
           * @static
           * @param {routing.Disconnect} message Disconnect
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Disconnect.toObject = function toObject() {
              return {};
          };

          /**
           * Converts this Disconnect to JSON.
           * @function toJSON
           * @memberof routing.Disconnect
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Disconnect.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Disconnect;
      })();

      routing.Protocol = (function() {

          /**
           * Properties of a Protocol.
           * @memberof routing
           * @interface IProtocol
           * @property {routing.IHeader|null} [header] Protocol header
           * @property {routing.IHeartbeat|null} [heartbeat] Protocol heartbeat
           * @property {routing.IProtocolHandshake|null} [protocol_handshake] Protocol protocol_handshake
           * @property {routing.IProtocolHandshakeResponse|null} [protocol_handshake_response] Protocol protocol_handshake_response
           * @property {routing.IPacket|null} [packet] Protocol packet
           * @property {routing.IDisconnect|null} [disconnect] Protocol disconnect
           */

          /**
           * Constructs a new Protocol.
           * @memberof routing
           * @classdesc Represents a Protocol.
           * @implements IProtocol
           * @constructor
           * @param {routing.IProtocol=} [properties] Properties to set
           */
          function Protocol(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Protocol header.
           * @member {routing.IHeader|null|undefined} header
           * @memberof routing.Protocol
           * @instance
           */
          Protocol.prototype.header = null;

          /**
           * Protocol heartbeat.
           * @member {routing.IHeartbeat|null|undefined} heartbeat
           * @memberof routing.Protocol
           * @instance
           */
          Protocol.prototype.heartbeat = null;

          /**
           * Protocol protocol_handshake.
           * @member {routing.IProtocolHandshake|null|undefined} protocol_handshake
           * @memberof routing.Protocol
           * @instance
           */
          Protocol.prototype.protocol_handshake = null;

          /**
           * Protocol protocol_handshake_response.
           * @member {routing.IProtocolHandshakeResponse|null|undefined} protocol_handshake_response
           * @memberof routing.Protocol
           * @instance
           */
          Protocol.prototype.protocol_handshake_response = null;

          /**
           * Protocol packet.
           * @member {routing.IPacket|null|undefined} packet
           * @memberof routing.Protocol
           * @instance
           */
          Protocol.prototype.packet = null;

          /**
           * Protocol disconnect.
           * @member {routing.IDisconnect|null|undefined} disconnect
           * @memberof routing.Protocol
           * @instance
           */
          Protocol.prototype.disconnect = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * Protocol message.
           * @member {"heartbeat"|"protocol_handshake"|"protocol_handshake_response"|"packet"|"disconnect"|undefined} message
           * @memberof routing.Protocol
           * @instance
           */
          Object.defineProperty(Protocol.prototype, "message", {
              get: $util.oneOfGetter($oneOfFields = ["heartbeat", "protocol_handshake", "protocol_handshake_response", "packet", "disconnect"]),
              set: $util.oneOfSetter($oneOfFields)
          });

          /**
           * Creates a new Protocol instance using the specified properties.
           * @function create
           * @memberof routing.Protocol
           * @static
           * @param {routing.IProtocol=} [properties] Properties to set
           * @returns {routing.Protocol} Protocol instance
           */
          Protocol.create = function create(properties) {
              return new Protocol(properties);
          };

          /**
           * Encodes the specified Protocol message. Does not implicitly {@link routing.Protocol.verify|verify} messages.
           * @function encode
           * @memberof routing.Protocol
           * @static
           * @param {routing.IProtocol} message Protocol message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Protocol.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.header != null && message.hasOwnProperty("header"))
                  $root.routing.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.heartbeat != null && message.hasOwnProperty("heartbeat"))
                  $root.routing.Heartbeat.encode(message.heartbeat, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              if (message.protocol_handshake != null && message.hasOwnProperty("protocol_handshake"))
                  $root.routing.ProtocolHandshake.encode(message.protocol_handshake, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
              if (message.protocol_handshake_response != null && message.hasOwnProperty("protocol_handshake_response"))
                  $root.routing.ProtocolHandshakeResponse.encode(message.protocol_handshake_response, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
              if (message.packet != null && message.hasOwnProperty("packet"))
                  $root.routing.Packet.encode(message.packet, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
              if (message.disconnect != null && message.hasOwnProperty("disconnect"))
                  $root.routing.Disconnect.encode(message.disconnect, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified Protocol message, length delimited. Does not implicitly {@link routing.Protocol.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Protocol
           * @static
           * @param {routing.IProtocol} message Protocol message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Protocol.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Protocol message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Protocol
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Protocol} Protocol
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Protocol.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Protocol();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.header = $root.routing.Header.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.heartbeat = $root.routing.Heartbeat.decode(reader, reader.uint32());
                      break;
                  case 3:
                      message.protocol_handshake = $root.routing.ProtocolHandshake.decode(reader, reader.uint32());
                      break;
                  case 4:
                      message.protocol_handshake_response = $root.routing.ProtocolHandshakeResponse.decode(reader, reader.uint32());
                      break;
                  case 5:
                      message.packet = $root.routing.Packet.decode(reader, reader.uint32());
                      break;
                  case 6:
                      message.disconnect = $root.routing.Disconnect.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Protocol message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Protocol
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Protocol} Protocol
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Protocol.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Protocol message.
           * @function verify
           * @memberof routing.Protocol
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Protocol.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              var properties = {};
              if (message.header != null && message.hasOwnProperty("header")) {
                  var error = $root.routing.Header.verify(message.header);
                  if (error)
                      return "header." + error;
              }
              if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                  properties.message = 1;
                  {
                      var error = $root.routing.Heartbeat.verify(message.heartbeat);
                      if (error)
                          return "heartbeat." + error;
                  }
              }
              if (message.protocol_handshake != null && message.hasOwnProperty("protocol_handshake")) {
                  if (properties.message === 1)
                      return "message: multiple values";
                  properties.message = 1;
                  {
                      var error = $root.routing.ProtocolHandshake.verify(message.protocol_handshake);
                      if (error)
                          return "protocol_handshake." + error;
                  }
              }
              if (message.protocol_handshake_response != null && message.hasOwnProperty("protocol_handshake_response")) {
                  if (properties.message === 1)
                      return "message: multiple values";
                  properties.message = 1;
                  {
                      var error = $root.routing.ProtocolHandshakeResponse.verify(message.protocol_handshake_response);
                      if (error)
                          return "protocol_handshake_response." + error;
                  }
              }
              if (message.packet != null && message.hasOwnProperty("packet")) {
                  if (properties.message === 1)
                      return "message: multiple values";
                  properties.message = 1;
                  {
                      var error = $root.routing.Packet.verify(message.packet);
                      if (error)
                          return "packet." + error;
                  }
              }
              if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                  if (properties.message === 1)
                      return "message: multiple values";
                  properties.message = 1;
                  {
                      var error = $root.routing.Disconnect.verify(message.disconnect);
                      if (error)
                          return "disconnect." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a Protocol message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Protocol
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Protocol} Protocol
           */
          Protocol.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Protocol)
                  return object;
              var message = new $root.routing.Protocol();
              if (object.header != null) {
                  if (typeof object.header !== "object")
                      throw TypeError(".routing.Protocol.header: object expected");
                  message.header = $root.routing.Header.fromObject(object.header);
              }
              if (object.heartbeat != null) {
                  if (typeof object.heartbeat !== "object")
                      throw TypeError(".routing.Protocol.heartbeat: object expected");
                  message.heartbeat = $root.routing.Heartbeat.fromObject(object.heartbeat);
              }
              if (object.protocol_handshake != null) {
                  if (typeof object.protocol_handshake !== "object")
                      throw TypeError(".routing.Protocol.protocol_handshake: object expected");
                  message.protocol_handshake = $root.routing.ProtocolHandshake.fromObject(object.protocol_handshake);
              }
              if (object.protocol_handshake_response != null) {
                  if (typeof object.protocol_handshake_response !== "object")
                      throw TypeError(".routing.Protocol.protocol_handshake_response: object expected");
                  message.protocol_handshake_response = $root.routing.ProtocolHandshakeResponse.fromObject(object.protocol_handshake_response);
              }
              if (object.packet != null) {
                  if (typeof object.packet !== "object")
                      throw TypeError(".routing.Protocol.packet: object expected");
                  message.packet = $root.routing.Packet.fromObject(object.packet);
              }
              if (object.disconnect != null) {
                  if (typeof object.disconnect !== "object")
                      throw TypeError(".routing.Protocol.disconnect: object expected");
                  message.disconnect = $root.routing.Disconnect.fromObject(object.disconnect);
              }
              return message;
          };

          /**
           * Creates a plain object from a Protocol message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Protocol
           * @static
           * @param {routing.Protocol} message Protocol
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Protocol.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.header = null;
              if (message.header != null && message.hasOwnProperty("header"))
                  object.header = $root.routing.Header.toObject(message.header, options);
              if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                  object.heartbeat = $root.routing.Heartbeat.toObject(message.heartbeat, options);
                  if (options.oneofs)
                      object.message = "heartbeat";
              }
              if (message.protocol_handshake != null && message.hasOwnProperty("protocol_handshake")) {
                  object.protocol_handshake = $root.routing.ProtocolHandshake.toObject(message.protocol_handshake, options);
                  if (options.oneofs)
                      object.message = "protocol_handshake";
              }
              if (message.protocol_handshake_response != null && message.hasOwnProperty("protocol_handshake_response")) {
                  object.protocol_handshake_response = $root.routing.ProtocolHandshakeResponse.toObject(message.protocol_handshake_response, options);
                  if (options.oneofs)
                      object.message = "protocol_handshake_response";
              }
              if (message.packet != null && message.hasOwnProperty("packet")) {
                  object.packet = $root.routing.Packet.toObject(message.packet, options);
                  if (options.oneofs)
                      object.message = "packet";
              }
              if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                  object.disconnect = $root.routing.Disconnect.toObject(message.disconnect, options);
                  if (options.oneofs)
                      object.message = "disconnect";
              }
              return object;
          };

          /**
           * Converts this Protocol to JSON.
           * @function toJSON
           * @memberof routing.Protocol
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Protocol.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Protocol;
      })();

      routing.TransportLayer = (function() {

          /**
           * Constructs a new TransportLayer service.
           * @memberof routing
           * @classdesc Represents a TransportLayer
           * @extends $protobuf.rpc.Service
           * @constructor
           * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
           * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
           * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
           */
          function TransportLayer(rpcImpl, requestDelimited, responseDelimited) {
              minimal$1.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
          }

          (TransportLayer.prototype = Object.create(minimal$1.rpc.Service.prototype)).constructor = TransportLayer;

          /**
           * Creates new TransportLayer service using the specified rpc implementation.
           * @function create
           * @memberof routing.TransportLayer
           * @static
           * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
           * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
           * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
           * @returns {TransportLayer} RPC service. Useful where requests and/or responses are streamed.
           */
          TransportLayer.create = function create(rpcImpl, requestDelimited, responseDelimited) {
              return new this(rpcImpl, requestDelimited, responseDelimited);
          };

          /**
           * Callback as used by {@link routing.TransportLayer#send}.
           * @memberof routing.TransportLayer
           * @typedef SendCallback
           * @type {function}
           * @param {Error|null} error Error, if any
           * @param {routing.TLResponse} [response] TLResponse
           */

          /**
           * Calls Send.
           * @function send
           * @memberof routing.TransportLayer
           * @instance
           * @param {routing.ITLRequest} request TLRequest message or plain object
           * @param {routing.TransportLayer.SendCallback} callback Node-style callback called with the error, if any, and TLResponse
           * @returns {undefined}
           * @variation 1
           */
          Object.defineProperty(TransportLayer.prototype.send = function send(request, callback) {
              return this.rpcCall(send, $root.routing.TLRequest, $root.routing.TLResponse, request, callback);
          }, "name", { value: "Send" });

          /**
           * Calls Send.
           * @function send
           * @memberof routing.TransportLayer
           * @instance
           * @param {routing.ITLRequest} request TLRequest message or plain object
           * @returns {Promise<routing.TLResponse>} Promise
           * @variation 2
           */

          /**
           * Callback as used by {@link routing.TransportLayer#stream}.
           * @memberof routing.TransportLayer
           * @typedef StreamCallback
           * @type {function}
           * @param {Error|null} error Error, if any
           * @param {routing.TLResponse} [response] TLResponse
           */

          /**
           * Calls Stream.
           * @function stream
           * @memberof routing.TransportLayer
           * @instance
           * @param {routing.IChunk} request Chunk message or plain object
           * @param {routing.TransportLayer.StreamCallback} callback Node-style callback called with the error, if any, and TLResponse
           * @returns {undefined}
           * @variation 1
           */
          Object.defineProperty(TransportLayer.prototype.stream = function stream(request, callback) {
              return this.rpcCall(stream, $root.routing.Chunk, $root.routing.TLResponse, request, callback);
          }, "name", { value: "Stream" });

          /**
           * Calls Stream.
           * @function stream
           * @memberof routing.TransportLayer
           * @instance
           * @param {routing.IChunk} request Chunk message or plain object
           * @returns {Promise<routing.TLResponse>} Promise
           * @variation 2
           */

          return TransportLayer;
      })();

      routing.TLRequest = (function() {

          /**
           * Properties of a TLRequest.
           * @memberof routing
           * @interface ITLRequest
           * @property {routing.IProtocol|null} [protocol] TLRequest protocol
           */

          /**
           * Constructs a new TLRequest.
           * @memberof routing
           * @classdesc Represents a TLRequest.
           * @implements ITLRequest
           * @constructor
           * @param {routing.ITLRequest=} [properties] Properties to set
           */
          function TLRequest(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * TLRequest protocol.
           * @member {routing.IProtocol|null|undefined} protocol
           * @memberof routing.TLRequest
           * @instance
           */
          TLRequest.prototype.protocol = null;

          /**
           * Creates a new TLRequest instance using the specified properties.
           * @function create
           * @memberof routing.TLRequest
           * @static
           * @param {routing.ITLRequest=} [properties] Properties to set
           * @returns {routing.TLRequest} TLRequest instance
           */
          TLRequest.create = function create(properties) {
              return new TLRequest(properties);
          };

          /**
           * Encodes the specified TLRequest message. Does not implicitly {@link routing.TLRequest.verify|verify} messages.
           * @function encode
           * @memberof routing.TLRequest
           * @static
           * @param {routing.ITLRequest} message TLRequest message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TLRequest.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.protocol != null && message.hasOwnProperty("protocol"))
                  $root.routing.Protocol.encode(message.protocol, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified TLRequest message, length delimited. Does not implicitly {@link routing.TLRequest.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.TLRequest
           * @static
           * @param {routing.ITLRequest} message TLRequest message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TLRequest.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a TLRequest message from the specified reader or buffer.
           * @function decode
           * @memberof routing.TLRequest
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.TLRequest} TLRequest
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TLRequest.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.TLRequest();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.protocol = $root.routing.Protocol.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a TLRequest message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.TLRequest
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.TLRequest} TLRequest
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TLRequest.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a TLRequest message.
           * @function verify
           * @memberof routing.TLRequest
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          TLRequest.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.protocol != null && message.hasOwnProperty("protocol")) {
                  var error = $root.routing.Protocol.verify(message.protocol);
                  if (error)
                      return "protocol." + error;
              }
              return null;
          };

          /**
           * Creates a TLRequest message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.TLRequest
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.TLRequest} TLRequest
           */
          TLRequest.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.TLRequest)
                  return object;
              var message = new $root.routing.TLRequest();
              if (object.protocol != null) {
                  if (typeof object.protocol !== "object")
                      throw TypeError(".routing.TLRequest.protocol: object expected");
                  message.protocol = $root.routing.Protocol.fromObject(object.protocol);
              }
              return message;
          };

          /**
           * Creates a plain object from a TLRequest message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.TLRequest
           * @static
           * @param {routing.TLRequest} message TLRequest
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          TLRequest.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.protocol = null;
              if (message.protocol != null && message.hasOwnProperty("protocol"))
                  object.protocol = $root.routing.Protocol.toObject(message.protocol, options);
              return object;
          };

          /**
           * Converts this TLRequest to JSON.
           * @function toJSON
           * @memberof routing.TLRequest
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          TLRequest.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return TLRequest;
      })();

      routing.InternalServerError = (function() {

          /**
           * Properties of an InternalServerError.
           * @memberof routing
           * @interface IInternalServerError
           * @property {Uint8Array|null} [error] InternalServerError error
           */

          /**
           * Constructs a new InternalServerError.
           * @memberof routing
           * @classdesc Represents an InternalServerError.
           * @implements IInternalServerError
           * @constructor
           * @param {routing.IInternalServerError=} [properties] Properties to set
           */
          function InternalServerError(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * InternalServerError error.
           * @member {Uint8Array} error
           * @memberof routing.InternalServerError
           * @instance
           */
          InternalServerError.prototype.error = $util.newBuffer([]);

          /**
           * Creates a new InternalServerError instance using the specified properties.
           * @function create
           * @memberof routing.InternalServerError
           * @static
           * @param {routing.IInternalServerError=} [properties] Properties to set
           * @returns {routing.InternalServerError} InternalServerError instance
           */
          InternalServerError.create = function create(properties) {
              return new InternalServerError(properties);
          };

          /**
           * Encodes the specified InternalServerError message. Does not implicitly {@link routing.InternalServerError.verify|verify} messages.
           * @function encode
           * @memberof routing.InternalServerError
           * @static
           * @param {routing.IInternalServerError} message InternalServerError message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          InternalServerError.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.error != null && message.hasOwnProperty("error"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.error);
              return writer;
          };

          /**
           * Encodes the specified InternalServerError message, length delimited. Does not implicitly {@link routing.InternalServerError.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.InternalServerError
           * @static
           * @param {routing.IInternalServerError} message InternalServerError message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          InternalServerError.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an InternalServerError message from the specified reader or buffer.
           * @function decode
           * @memberof routing.InternalServerError
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.InternalServerError} InternalServerError
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          InternalServerError.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.InternalServerError();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.error = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an InternalServerError message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.InternalServerError
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.InternalServerError} InternalServerError
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          InternalServerError.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an InternalServerError message.
           * @function verify
           * @memberof routing.InternalServerError
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          InternalServerError.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.error != null && message.hasOwnProperty("error"))
                  if (!(message.error && typeof message.error.length === "number" || $util.isString(message.error)))
                      return "error: buffer expected";
              return null;
          };

          /**
           * Creates an InternalServerError message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.InternalServerError
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.InternalServerError} InternalServerError
           */
          InternalServerError.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.InternalServerError)
                  return object;
              var message = new $root.routing.InternalServerError();
              if (object.error != null)
                  if (typeof object.error === "string")
                      $util.base64.decode(object.error, message.error = $util.newBuffer($util.base64.length(object.error)), 0);
                  else if (object.error.length)
                      message.error = object.error;
              return message;
          };

          /**
           * Creates a plain object from an InternalServerError message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.InternalServerError
           * @static
           * @param {routing.InternalServerError} message InternalServerError
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          InternalServerError.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.error = "";
                  else {
                      object.error = [];
                      if (options.bytes !== Array)
                          object.error = $util.newBuffer(object.error);
                  }
              if (message.error != null && message.hasOwnProperty("error"))
                  object.error = options.bytes === String ? $util.base64.encode(message.error, 0, message.error.length) : options.bytes === Array ? Array.prototype.slice.call(message.error) : message.error;
              return object;
          };

          /**
           * Converts this InternalServerError to JSON.
           * @function toJSON
           * @memberof routing.InternalServerError
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          InternalServerError.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return InternalServerError;
      })();

      routing.Ack = (function() {

          /**
           * Properties of an Ack.
           * @memberof routing
           * @interface IAck
           * @property {routing.IHeader|null} [header] Ack header
           */

          /**
           * Constructs a new Ack.
           * @memberof routing
           * @classdesc Represents an Ack.
           * @implements IAck
           * @constructor
           * @param {routing.IAck=} [properties] Properties to set
           */
          function Ack(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Ack header.
           * @member {routing.IHeader|null|undefined} header
           * @memberof routing.Ack
           * @instance
           */
          Ack.prototype.header = null;

          /**
           * Creates a new Ack instance using the specified properties.
           * @function create
           * @memberof routing.Ack
           * @static
           * @param {routing.IAck=} [properties] Properties to set
           * @returns {routing.Ack} Ack instance
           */
          Ack.create = function create(properties) {
              return new Ack(properties);
          };

          /**
           * Encodes the specified Ack message. Does not implicitly {@link routing.Ack.verify|verify} messages.
           * @function encode
           * @memberof routing.Ack
           * @static
           * @param {routing.IAck} message Ack message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Ack.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.header != null && message.hasOwnProperty("header"))
                  $root.routing.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified Ack message, length delimited. Does not implicitly {@link routing.Ack.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Ack
           * @static
           * @param {routing.IAck} message Ack message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Ack.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Ack message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Ack
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Ack} Ack
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Ack.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Ack();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.header = $root.routing.Header.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes an Ack message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Ack
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Ack} Ack
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Ack.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Ack message.
           * @function verify
           * @memberof routing.Ack
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Ack.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.header != null && message.hasOwnProperty("header")) {
                  var error = $root.routing.Header.verify(message.header);
                  if (error)
                      return "header." + error;
              }
              return null;
          };

          /**
           * Creates an Ack message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Ack
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Ack} Ack
           */
          Ack.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Ack)
                  return object;
              var message = new $root.routing.Ack();
              if (object.header != null) {
                  if (typeof object.header !== "object")
                      throw TypeError(".routing.Ack.header: object expected");
                  message.header = $root.routing.Header.fromObject(object.header);
              }
              return message;
          };

          /**
           * Creates a plain object from an Ack message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Ack
           * @static
           * @param {routing.Ack} message Ack
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Ack.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  object.header = null;
              if (message.header != null && message.hasOwnProperty("header"))
                  object.header = $root.routing.Header.toObject(message.header, options);
              return object;
          };

          /**
           * Converts this Ack to JSON.
           * @function toJSON
           * @memberof routing.Ack
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Ack.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Ack;
      })();

      routing.TLResponse = (function() {

          /**
           * Properties of a TLResponse.
           * @memberof routing
           * @interface ITLResponse
           * @property {routing.IAck|null} [ack] TLResponse ack
           * @property {routing.IInternalServerError|null} [internalServerError] TLResponse internalServerError
           */

          /**
           * Constructs a new TLResponse.
           * @memberof routing
           * @classdesc Represents a TLResponse.
           * @implements ITLResponse
           * @constructor
           * @param {routing.ITLResponse=} [properties] Properties to set
           */
          function TLResponse(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * TLResponse ack.
           * @member {routing.IAck|null|undefined} ack
           * @memberof routing.TLResponse
           * @instance
           */
          TLResponse.prototype.ack = null;

          /**
           * TLResponse internalServerError.
           * @member {routing.IInternalServerError|null|undefined} internalServerError
           * @memberof routing.TLResponse
           * @instance
           */
          TLResponse.prototype.internalServerError = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * TLResponse payload.
           * @member {"ack"|"internalServerError"|undefined} payload
           * @memberof routing.TLResponse
           * @instance
           */
          Object.defineProperty(TLResponse.prototype, "payload", {
              get: $util.oneOfGetter($oneOfFields = ["ack", "internalServerError"]),
              set: $util.oneOfSetter($oneOfFields)
          });

          /**
           * Creates a new TLResponse instance using the specified properties.
           * @function create
           * @memberof routing.TLResponse
           * @static
           * @param {routing.ITLResponse=} [properties] Properties to set
           * @returns {routing.TLResponse} TLResponse instance
           */
          TLResponse.create = function create(properties) {
              return new TLResponse(properties);
          };

          /**
           * Encodes the specified TLResponse message. Does not implicitly {@link routing.TLResponse.verify|verify} messages.
           * @function encode
           * @memberof routing.TLResponse
           * @static
           * @param {routing.ITLResponse} message TLResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TLResponse.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.ack != null && message.hasOwnProperty("ack"))
                  $root.routing.Ack.encode(message.ack, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.internalServerError != null && message.hasOwnProperty("internalServerError"))
                  $root.routing.InternalServerError.encode(message.internalServerError, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified TLResponse message, length delimited. Does not implicitly {@link routing.TLResponse.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.TLResponse
           * @static
           * @param {routing.ITLResponse} message TLResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          TLResponse.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a TLResponse message from the specified reader or buffer.
           * @function decode
           * @memberof routing.TLResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.TLResponse} TLResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TLResponse.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.TLResponse();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.ack = $root.routing.Ack.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.internalServerError = $root.routing.InternalServerError.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a TLResponse message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.TLResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.TLResponse} TLResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          TLResponse.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a TLResponse message.
           * @function verify
           * @memberof routing.TLResponse
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          TLResponse.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              var properties = {};
              if (message.ack != null && message.hasOwnProperty("ack")) {
                  properties.payload = 1;
                  {
                      var error = $root.routing.Ack.verify(message.ack);
                      if (error)
                          return "ack." + error;
                  }
              }
              if (message.internalServerError != null && message.hasOwnProperty("internalServerError")) {
                  if (properties.payload === 1)
                      return "payload: multiple values";
                  properties.payload = 1;
                  {
                      var error = $root.routing.InternalServerError.verify(message.internalServerError);
                      if (error)
                          return "internalServerError." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a TLResponse message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.TLResponse
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.TLResponse} TLResponse
           */
          TLResponse.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.TLResponse)
                  return object;
              var message = new $root.routing.TLResponse();
              if (object.ack != null) {
                  if (typeof object.ack !== "object")
                      throw TypeError(".routing.TLResponse.ack: object expected");
                  message.ack = $root.routing.Ack.fromObject(object.ack);
              }
              if (object.internalServerError != null) {
                  if (typeof object.internalServerError !== "object")
                      throw TypeError(".routing.TLResponse.internalServerError: object expected");
                  message.internalServerError = $root.routing.InternalServerError.fromObject(object.internalServerError);
              }
              return message;
          };

          /**
           * Creates a plain object from a TLResponse message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.TLResponse
           * @static
           * @param {routing.TLResponse} message TLResponse
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          TLResponse.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (message.ack != null && message.hasOwnProperty("ack")) {
                  object.ack = $root.routing.Ack.toObject(message.ack, options);
                  if (options.oneofs)
                      object.payload = "ack";
              }
              if (message.internalServerError != null && message.hasOwnProperty("internalServerError")) {
                  object.internalServerError = $root.routing.InternalServerError.toObject(message.internalServerError, options);
                  if (options.oneofs)
                      object.payload = "internalServerError";
              }
              return object;
          };

          /**
           * Converts this TLResponse to JSON.
           * @function toJSON
           * @memberof routing.TLResponse
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          TLResponse.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return TLResponse;
      })();

      routing.ChunkHeader = (function() {

          /**
           * Properties of a ChunkHeader.
           * @memberof routing
           * @interface IChunkHeader
           * @property {routing.INode|null} [sender] ChunkHeader sender
           * @property {string|null} [typeId] ChunkHeader typeId
           * @property {boolean|null} [compressed] ChunkHeader compressed
           * @property {number|null} [contentLength] ChunkHeader contentLength
           * @property {string|null} [networkId] ChunkHeader networkId
           */

          /**
           * Constructs a new ChunkHeader.
           * @memberof routing
           * @classdesc Represents a ChunkHeader.
           * @implements IChunkHeader
           * @constructor
           * @param {routing.IChunkHeader=} [properties] Properties to set
           */
          function ChunkHeader(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ChunkHeader sender.
           * @member {routing.INode|null|undefined} sender
           * @memberof routing.ChunkHeader
           * @instance
           */
          ChunkHeader.prototype.sender = null;

          /**
           * ChunkHeader typeId.
           * @member {string} typeId
           * @memberof routing.ChunkHeader
           * @instance
           */
          ChunkHeader.prototype.typeId = "";

          /**
           * ChunkHeader compressed.
           * @member {boolean} compressed
           * @memberof routing.ChunkHeader
           * @instance
           */
          ChunkHeader.prototype.compressed = false;

          /**
           * ChunkHeader contentLength.
           * @member {number} contentLength
           * @memberof routing.ChunkHeader
           * @instance
           */
          ChunkHeader.prototype.contentLength = 0;

          /**
           * ChunkHeader networkId.
           * @member {string} networkId
           * @memberof routing.ChunkHeader
           * @instance
           */
          ChunkHeader.prototype.networkId = "";

          /**
           * Creates a new ChunkHeader instance using the specified properties.
           * @function create
           * @memberof routing.ChunkHeader
           * @static
           * @param {routing.IChunkHeader=} [properties] Properties to set
           * @returns {routing.ChunkHeader} ChunkHeader instance
           */
          ChunkHeader.create = function create(properties) {
              return new ChunkHeader(properties);
          };

          /**
           * Encodes the specified ChunkHeader message. Does not implicitly {@link routing.ChunkHeader.verify|verify} messages.
           * @function encode
           * @memberof routing.ChunkHeader
           * @static
           * @param {routing.IChunkHeader} message ChunkHeader message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ChunkHeader.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.sender != null && message.hasOwnProperty("sender"))
                  $root.routing.Node.encode(message.sender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.typeId != null && message.hasOwnProperty("typeId"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeId);
              if (message.compressed != null && message.hasOwnProperty("compressed"))
                  writer.uint32(/* id 3, wireType 0 =*/24).bool(message.compressed);
              if (message.contentLength != null && message.hasOwnProperty("contentLength"))
                  writer.uint32(/* id 4, wireType 0 =*/32).int32(message.contentLength);
              if (message.networkId != null && message.hasOwnProperty("networkId"))
                  writer.uint32(/* id 5, wireType 2 =*/42).string(message.networkId);
              return writer;
          };

          /**
           * Encodes the specified ChunkHeader message, length delimited. Does not implicitly {@link routing.ChunkHeader.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.ChunkHeader
           * @static
           * @param {routing.IChunkHeader} message ChunkHeader message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ChunkHeader.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ChunkHeader message from the specified reader or buffer.
           * @function decode
           * @memberof routing.ChunkHeader
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.ChunkHeader} ChunkHeader
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ChunkHeader.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ChunkHeader();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.sender = $root.routing.Node.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.typeId = reader.string();
                      break;
                  case 3:
                      message.compressed = reader.bool();
                      break;
                  case 4:
                      message.contentLength = reader.int32();
                      break;
                  case 5:
                      message.networkId = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ChunkHeader message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.ChunkHeader
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.ChunkHeader} ChunkHeader
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ChunkHeader.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ChunkHeader message.
           * @function verify
           * @memberof routing.ChunkHeader
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ChunkHeader.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.sender != null && message.hasOwnProperty("sender")) {
                  var error = $root.routing.Node.verify(message.sender);
                  if (error)
                      return "sender." + error;
              }
              if (message.typeId != null && message.hasOwnProperty("typeId"))
                  if (!$util.isString(message.typeId))
                      return "typeId: string expected";
              if (message.compressed != null && message.hasOwnProperty("compressed"))
                  if (typeof message.compressed !== "boolean")
                      return "compressed: boolean expected";
              if (message.contentLength != null && message.hasOwnProperty("contentLength"))
                  if (!$util.isInteger(message.contentLength))
                      return "contentLength: integer expected";
              if (message.networkId != null && message.hasOwnProperty("networkId"))
                  if (!$util.isString(message.networkId))
                      return "networkId: string expected";
              return null;
          };

          /**
           * Creates a ChunkHeader message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.ChunkHeader
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.ChunkHeader} ChunkHeader
           */
          ChunkHeader.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.ChunkHeader)
                  return object;
              var message = new $root.routing.ChunkHeader();
              if (object.sender != null) {
                  if (typeof object.sender !== "object")
                      throw TypeError(".routing.ChunkHeader.sender: object expected");
                  message.sender = $root.routing.Node.fromObject(object.sender);
              }
              if (object.typeId != null)
                  message.typeId = String(object.typeId);
              if (object.compressed != null)
                  message.compressed = Boolean(object.compressed);
              if (object.contentLength != null)
                  message.contentLength = object.contentLength | 0;
              if (object.networkId != null)
                  message.networkId = String(object.networkId);
              return message;
          };

          /**
           * Creates a plain object from a ChunkHeader message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.ChunkHeader
           * @static
           * @param {routing.ChunkHeader} message ChunkHeader
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ChunkHeader.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.sender = null;
                  object.typeId = "";
                  object.compressed = false;
                  object.contentLength = 0;
                  object.networkId = "";
              }
              if (message.sender != null && message.hasOwnProperty("sender"))
                  object.sender = $root.routing.Node.toObject(message.sender, options);
              if (message.typeId != null && message.hasOwnProperty("typeId"))
                  object.typeId = message.typeId;
              if (message.compressed != null && message.hasOwnProperty("compressed"))
                  object.compressed = message.compressed;
              if (message.contentLength != null && message.hasOwnProperty("contentLength"))
                  object.contentLength = message.contentLength;
              if (message.networkId != null && message.hasOwnProperty("networkId"))
                  object.networkId = message.networkId;
              return object;
          };

          /**
           * Converts this ChunkHeader to JSON.
           * @function toJSON
           * @memberof routing.ChunkHeader
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ChunkHeader.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ChunkHeader;
      })();

      routing.ChunkData = (function() {

          /**
           * Properties of a ChunkData.
           * @memberof routing
           * @interface IChunkData
           * @property {Uint8Array|null} [contentData] ChunkData contentData
           */

          /**
           * Constructs a new ChunkData.
           * @memberof routing
           * @classdesc Represents a ChunkData.
           * @implements IChunkData
           * @constructor
           * @param {routing.IChunkData=} [properties] Properties to set
           */
          function ChunkData(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * ChunkData contentData.
           * @member {Uint8Array} contentData
           * @memberof routing.ChunkData
           * @instance
           */
          ChunkData.prototype.contentData = $util.newBuffer([]);

          /**
           * Creates a new ChunkData instance using the specified properties.
           * @function create
           * @memberof routing.ChunkData
           * @static
           * @param {routing.IChunkData=} [properties] Properties to set
           * @returns {routing.ChunkData} ChunkData instance
           */
          ChunkData.create = function create(properties) {
              return new ChunkData(properties);
          };

          /**
           * Encodes the specified ChunkData message. Does not implicitly {@link routing.ChunkData.verify|verify} messages.
           * @function encode
           * @memberof routing.ChunkData
           * @static
           * @param {routing.IChunkData} message ChunkData message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ChunkData.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.contentData != null && message.hasOwnProperty("contentData"))
                  writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contentData);
              return writer;
          };

          /**
           * Encodes the specified ChunkData message, length delimited. Does not implicitly {@link routing.ChunkData.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.ChunkData
           * @static
           * @param {routing.IChunkData} message ChunkData message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ChunkData.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ChunkData message from the specified reader or buffer.
           * @function decode
           * @memberof routing.ChunkData
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.ChunkData} ChunkData
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ChunkData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.ChunkData();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.contentData = reader.bytes();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a ChunkData message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.ChunkData
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.ChunkData} ChunkData
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ChunkData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ChunkData message.
           * @function verify
           * @memberof routing.ChunkData
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ChunkData.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.contentData != null && message.hasOwnProperty("contentData"))
                  if (!(message.contentData && typeof message.contentData.length === "number" || $util.isString(message.contentData)))
                      return "contentData: buffer expected";
              return null;
          };

          /**
           * Creates a ChunkData message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.ChunkData
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.ChunkData} ChunkData
           */
          ChunkData.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.ChunkData)
                  return object;
              var message = new $root.routing.ChunkData();
              if (object.contentData != null)
                  if (typeof object.contentData === "string")
                      $util.base64.decode(object.contentData, message.contentData = $util.newBuffer($util.base64.length(object.contentData)), 0);
                  else if (object.contentData.length)
                      message.contentData = object.contentData;
              return message;
          };

          /**
           * Creates a plain object from a ChunkData message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.ChunkData
           * @static
           * @param {routing.ChunkData} message ChunkData
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ChunkData.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults)
                  if (options.bytes === String)
                      object.contentData = "";
                  else {
                      object.contentData = [];
                      if (options.bytes !== Array)
                          object.contentData = $util.newBuffer(object.contentData);
                  }
              if (message.contentData != null && message.hasOwnProperty("contentData"))
                  object.contentData = options.bytes === String ? $util.base64.encode(message.contentData, 0, message.contentData.length) : options.bytes === Array ? Array.prototype.slice.call(message.contentData) : message.contentData;
              return object;
          };

          /**
           * Converts this ChunkData to JSON.
           * @function toJSON
           * @memberof routing.ChunkData
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ChunkData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return ChunkData;
      })();

      routing.Chunk = (function() {

          /**
           * Properties of a Chunk.
           * @memberof routing
           * @interface IChunk
           * @property {routing.IChunkHeader|null} [header] Chunk header
           * @property {routing.IChunkData|null} [data] Chunk data
           */

          /**
           * Constructs a new Chunk.
           * @memberof routing
           * @classdesc Represents a Chunk.
           * @implements IChunk
           * @constructor
           * @param {routing.IChunk=} [properties] Properties to set
           */
          function Chunk(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Chunk header.
           * @member {routing.IChunkHeader|null|undefined} header
           * @memberof routing.Chunk
           * @instance
           */
          Chunk.prototype.header = null;

          /**
           * Chunk data.
           * @member {routing.IChunkData|null|undefined} data
           * @memberof routing.Chunk
           * @instance
           */
          Chunk.prototype.data = null;

          // OneOf field names bound to virtual getters and setters
          var $oneOfFields;

          /**
           * Chunk content.
           * @member {"header"|"data"|undefined} content
           * @memberof routing.Chunk
           * @instance
           */
          Object.defineProperty(Chunk.prototype, "content", {
              get: $util.oneOfGetter($oneOfFields = ["header", "data"]),
              set: $util.oneOfSetter($oneOfFields)
          });

          /**
           * Creates a new Chunk instance using the specified properties.
           * @function create
           * @memberof routing.Chunk
           * @static
           * @param {routing.IChunk=} [properties] Properties to set
           * @returns {routing.Chunk} Chunk instance
           */
          Chunk.create = function create(properties) {
              return new Chunk(properties);
          };

          /**
           * Encodes the specified Chunk message. Does not implicitly {@link routing.Chunk.verify|verify} messages.
           * @function encode
           * @memberof routing.Chunk
           * @static
           * @param {routing.IChunk} message Chunk message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Chunk.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.header != null && message.hasOwnProperty("header"))
                  $root.routing.ChunkHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.data != null && message.hasOwnProperty("data"))
                  $root.routing.ChunkData.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified Chunk message, length delimited. Does not implicitly {@link routing.Chunk.verify|verify} messages.
           * @function encodeDelimited
           * @memberof routing.Chunk
           * @static
           * @param {routing.IChunk} message Chunk message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Chunk.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Chunk message from the specified reader or buffer.
           * @function decode
           * @memberof routing.Chunk
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {routing.Chunk} Chunk
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Chunk.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.routing.Chunk();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.header = $root.routing.ChunkHeader.decode(reader, reader.uint32());
                      break;
                  case 2:
                      message.data = $root.routing.ChunkData.decode(reader, reader.uint32());
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a Chunk message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof routing.Chunk
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {routing.Chunk} Chunk
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Chunk.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Chunk message.
           * @function verify
           * @memberof routing.Chunk
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Chunk.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              var properties = {};
              if (message.header != null && message.hasOwnProperty("header")) {
                  properties.content = 1;
                  {
                      var error = $root.routing.ChunkHeader.verify(message.header);
                      if (error)
                          return "header." + error;
                  }
              }
              if (message.data != null && message.hasOwnProperty("data")) {
                  if (properties.content === 1)
                      return "content: multiple values";
                  properties.content = 1;
                  {
                      var error = $root.routing.ChunkData.verify(message.data);
                      if (error)
                          return "data." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a Chunk message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof routing.Chunk
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {routing.Chunk} Chunk
           */
          Chunk.fromObject = function fromObject(object) {
              if (object instanceof $root.routing.Chunk)
                  return object;
              var message = new $root.routing.Chunk();
              if (object.header != null) {
                  if (typeof object.header !== "object")
                      throw TypeError(".routing.Chunk.header: object expected");
                  message.header = $root.routing.ChunkHeader.fromObject(object.header);
              }
              if (object.data != null) {
                  if (typeof object.data !== "object")
                      throw TypeError(".routing.Chunk.data: object expected");
                  message.data = $root.routing.ChunkData.fromObject(object.data);
              }
              return message;
          };

          /**
           * Creates a plain object from a Chunk message. Also converts values to other types if specified.
           * @function toObject
           * @memberof routing.Chunk
           * @static
           * @param {routing.Chunk} message Chunk
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Chunk.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (message.header != null && message.hasOwnProperty("header")) {
                  object.header = $root.routing.ChunkHeader.toObject(message.header, options);
                  if (options.oneofs)
                      object.content = "header";
              }
              if (message.data != null && message.hasOwnProperty("data")) {
                  object.data = $root.routing.ChunkData.toObject(message.data, options);
                  if (options.oneofs)
                      object.content = "data";
              }
              return object;
          };

          /**
           * Converts this Chunk to JSON.
           * @function toJSON
           * @memberof routing.Chunk
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Chunk.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, minimal$1.util.toJSONOptions);
          };

          return Chunk;
      })();

      return routing;
  })();

  var rnodeProtos = $root;

  var decodePar = function (par) {
      var a = rnodeProtos.Par.decode(par);
      return a.toJSON();
  };

  exports.decodePar = decodePar;
  exports.rhoExprToVar = rhoExprToVar;
  exports.rhoValToJs = rhoValToJs;

  return exports;

}({}));
